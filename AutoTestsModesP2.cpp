/*!
 *  \file      AutoTestsModesP2.cpp
 *
 *  \brief     Содержит реализацию класса, включающего кейсы Режимы работы
 *
 */

//! Подключение заголовочных файлов

#include "AutoTestsModesP2.h"

//! Реализация класса

AutoTestsModesP2 *AutoTestsModesP2::s_at_modes_p2 = 0;

AutoTestsModesP2::AutoTestsModesP2()
{
    memset(m_curr_fw_ver,
           0,
           sizeof(m_curr_fw_ver));
}

AutoTestsModesP2::~AutoTestsModesP2()
{
    delete s_at_modes_p2;
    
    delete p_ppp_func_x96;
    delete p_ppp_func_m96;
    delete p_ppp_func_a96;
    delete p_ppp_func_e96;
    delete p_ppp_func_s96;
    delete p_ppp_func_x96v2;
     
    delete p_cap_sensor_func_x96;
    delete p_cap_sensor_func_m96;    
    delete p_cap_sensor_func_a96;
    delete p_cap_sensor_func_e96;
    delete p_cap_sensor_func_s96;
    delete p_cap_sensor_func_x96v2;
    
    delete p_cap_can_slave_func_x96;
    delete p_cap_can_slave_func_a96;
    delete p_cap_can_slave_func_e96;
    delete p_cap_can_slave_func_s96;
    delete p_cap_can_slave_func_x96v2;
    
    delete p_cap_analog_slave_func_x96;
    delete p_cap_analog_slave_func_a96;
    delete p_cap_analog_slave_func_e96;
    delete p_cap_analog_slave_func_s96;
    delete p_cap_analog_slave_func_x96v2;
    
    delete p_hood_analog_slave_func_x96;
    delete p_hood_analog_slave_func_a96;
    delete p_hood_analog_slave_func_e96;
    delete p_hood_analog_slave_func_s96;
    delete p_hood_analog_slave_func_x96v2;

    delete p_analog_can_slave_func_a96;
    delete p_analog_can_slave_func_x96;
    delete p_analog_can_slave_func_e96;
    delete p_analog_can_slave_func_x96v2;
    delete p_analog_can_slave_func_s96;

    delete p_rearm_breake_func_m96;
    delete p_rearm_breake_func_x96v2;

    delete p_hood_trunk_doors_e96;                                          
    delete p_hood_trunk_doors_s96;

    delete p_c1827097;
    delete p_c1827097_func_a96;
    delete p_c1827097_func_e96;
    delete p_c1827097_func_s96;
    delete p_c1827097_func_x96v2;

    delete p_c2198656_func_a96;
    delete p_c2198656_func_e96;
    delete p_c2198656_func_s96;
    delete p_c2198656_func_x96v2;

    delete p_no_siren_func_a96;
    delete p_no_siren_func_e96;
    delete p_no_siren_func_s96;
    delete p_no_siren_func_x96v2;

    delete p_c2799852_func_a96;
    delete p_c2799852_func_e96;
    delete p_c2799852_func_s96;
    delete p_c2799852_func_x96v2;
    delete p_c2799854_func_x96v2;

    delete p_c187478_func_a96;
    delete p_c187478_func_e96;
    delete p_c187478_func_s96;
    delete p_c187478_func_x96v2;

    delete p_c3688075_func_a96;

    delete p_c168671_master_stg;
    delete p_c168671;
    
    delete p_c168672_master_stg;
    delete p_c168672;    
    
    delete p_c168685_master_stg;
    delete p_c168685;
    
    delete p_c168686_master_stg;
    delete p_c168686;
    
    delete p_c168687_master_stg;
    delete p_c168687;
    
    delete p_c168688_master_stg;
    delete p_c168688;
    
    delete p_c168703_master_stg;
    delete p_c168703;

    delete p_c168707_master_stg;
    delete p_c168707;
    
    delete p_c168714_master_stg;
    delete p_c168714;
    
    delete p_c168723_master_stg;
    delete p_c168723;
    
    delete p_c170781_master_stg;
    delete p_c170781;
    
    delete p_c170782_master_stg;
    delete p_c170782;
    
    delete p_c170784_master_stg;
    delete p_c170784;
    
    delete p_c170792_master_stg;
    delete p_c170792;
    
    delete p_c170799_master_stg;
    delete p_c170799;
    
    delete p_c170800_master_stg;
    delete p_c170800;
    
    delete p_c170808;
    
    delete p_c170821_master_stg;
    delete p_c170821;
    
    delete p_c171184_master_stg;
    delete p_c171184;
    
    delete p_c169641_master_stg;
    delete p_c169641;
    
    delete p_c169642_master_stg;
    delete p_c169642;
    
    delete p_c169643_master_stg;
    delete p_c169643;
    
    delete p_c169644_master_stg;
    delete p_c169644;
    
    delete p_c169645_master_stg;
    delete p_c169645;
    
    delete p_c169648_master_stg;
    delete p_c169648;
    
    delete p_c169656_master_stg;
    delete p_c169656;
    
    delete p_c1578122_master_stg;
    delete p_c1578122;
    
    delete p_c169657_master_stg;
    delete p_c169657;
    
    delete p_c169659_master_stg;
    delete p_c169659;
    
    delete p_c1578123_master_stg;
    delete p_c1578123;
    
    delete p_c169639_master_stg;
    delete p_c169639;
    
    delete p_c169640_master_stg;
    delete p_c169640;
    
    delete p_c1616162_master_stg;
    delete p_c1616162;
    
    delete p_c1616163_master_stg;
    delete p_c1616163;
    
    delete p_c1616164_master_stg;
    delete p_c1616164;
    
    delete p_c1624514_master_stg;
    delete p_c1624514;
     
    delete p_c1624516_master_stg;
    delete p_c1624516;
     
    delete p_c1624517_master_stg;
    delete p_c1624517;
     
    delete p_c1624518_master_stg;
    delete p_c1624518;

    delete p_c172480_master_stg;
    delete p_c172480;

    delete p_c172498_master_stg;
    delete p_c172498;

    delete p_c172473_master_stg;
    delete p_c172473;

    delete p_c2043655_master_stg;
    delete p_c2043655;

    delete p_c2043657_master_stg;
    delete p_c2043657;

    delete p_c2043659_master_stg;
    delete p_c2043659;

    delete p_c2043661_master_stg;
    delete p_c2043661;

    delete p_c1981106_master_stg;
    delete p_c1981106;

    delete p_c1981107_master_stg;
    delete p_c1981107;
           
    delete p_c1981112_master_stg;
    delete p_c1981112;
           
    delete p_c1981115_master_stg;
    delete p_c1981115;

    delete p_c1981121_master_stg;
    delete p_c1981121;

    delete p_c1981125_master_stg;
    delete p_c1981125;

    delete p_c1981136_master_stg;
    delete p_c1981136;
    
    delete p_c2405376_master_stg;
    delete p_c2405376;
    
    delete p_c2405378_master_stg;
    delete p_c2405378;
    
    delete p_c2405379_master_stg;
    delete p_c2405379;
    
    delete p_c2424871_master_stg;
    delete p_c2424871;

    delete p_c2424871_2_master_stg;
    delete p_c2424871_2;

    delete p_c2424873_master_stg;
    delete p_c2424873;

    delete p_c2424875_master_stg;
    delete p_c2424875;

    delete p_c2424876_master_stg;
    delete p_c2424876;

    delete p_c2438277_master_stg;
    delete p_c2438277;

    delete p_c2424878_master_stg;
    delete p_c2424878;

    delete p_c2424879_master_stg;
    delete p_c2424879;

    delete p_c2424880_master_stg;
    delete p_c2424880;

    delete p_c2424881_master_stg;
    delete p_c2424881;

    delete p_c2424882_master_stg;
    delete p_c2424882;

    delete p_c2424883_master_stg;
    delete p_c2424883;

    delete p_c2424884_master_stg;
    delete p_c2424884;

    delete p_c2424885_master_stg;
    delete p_c2424885;

    delete p_c2424886_master_stg;
    delete p_c2424886;

    delete p_c2424887_master_stg;
    delete p_c2424887;

    delete p_c2424888_master_stg;
    delete p_c2424888;

    delete p_c2424889_master_stg;
    delete p_c2424889;

    delete p_c2728677_master_stg;
    delete p_c2728677;

    delete p_c2728678_master_stg;
    delete p_c2728678;

    delete p_c2728679_master_stg;
    delete p_c2728679;

    delete p_c2728682_master_stg;
    delete p_c2728682;

    delete p_c2728683_master_stg;
    delete p_c2728683;

    delete p_c2728684_master_stg;
    delete p_c2728684;

    delete p_c172464_master_stg;
    delete p_c172464;

    delete p_c1662256_master_stg;
    delete p_c1662256;

    delete p_c1662261_master_stg;
    delete p_c1662261;

    delete p_c169588_master_stg;
    delete p_c169588;

    delete p_c2198656_master_stg;
    delete p_c2198656;

    delete p_c2198680_master_stg;
    delete p_c2198680;

    delete p_c2198684_master_stg;
    delete p_c2198684;

    delete p_c2198685_master_stg;
    delete p_c2198685;

    delete p_c169591_master_stg;
    delete p_c169591;

    delete p_c169592_master_stg;
    delete p_c169592;

    delete p_c169593_master_stg;
    delete p_c169593;

    delete p_c169594;
    
    delete p_c2889927_master_stg;
    delete p_c2889927;
    
    delete p_c2889927_no_hf_master_stg;
    delete p_c2889927_no_hf;

    delete p_c3052203_master_stg;
    delete p_c3052203;

    delete p_c3052206_master_stg;
    delete p_c3052206;

    delete p_c2799849_master_stg;
    delete p_c2799849;

    delete p_c2799850_master_stg;
    delete p_c2799850;

    delete p_c2799851;

    delete p_c2799852_master_stg;
    delete p_c2799852;

    delete p_c2799853_master_stg;
    delete p_c2799853;

    delete p_c2799854_master_stg;
    delete p_c2799854;

    delete p_c3202904_master_stg;
    delete p_c3202904;

    delete p_c20461_master_stg;
    delete p_c20461;

    delete p_c20462_master_stg;
    delete p_c20462;

    delete p_c20463_master_stg;
    delete p_c20463;

    delete p_auth_no_tag_needed_master_stg;
    delete p_auth_no_tag_needed;

    delete p_c3752984_master_stg;
    delete p_c3752984;

    delete p_c3752985_master_stg;
    delete p_c3752985;

    delete p_c3752986_master_stg;
    delete p_c3752986;

    delete p_c3752987_master_stg;
    delete p_c3752987;

    delete p_c3136858_master_stg;
    delete p_c3136858;

    delete p_c3688077_master_stg;
    delete p_c3688077;

    delete p_no_rearm_master_stg;
    delete p_no_rearm;

    delete p_c3697245_master_stg;
    delete p_c3697245;

    delete p_c3688075_master_stg;
    delete p_c3688075;

    delete p_c3688076_master_stg;
    delete p_c3688076;

    delete p_no_auth_master_stg;
    delete p_no_auth;

    delete p_c3136863_master_stg;
    delete p_c3136863;

    delete p_c3136864_master_stg;
    delete p_c3136864;

    delete p_c170806_master_stg;
    delete p_c170806;

    delete p_c187473_master_stg;
    delete p_c187473;

    delete p_c187475_master_stg;
    delete p_c187475;

    delete p_c187457_master_stg;
    delete p_c187457;

    delete p_c187458_master_stg;
    delete p_c187458;

    delete p_c187459_master_stg;
    delete p_c187459;

    delete p_c187462_master_stg;
    delete p_c187462;

    delete p_c187463_master_stg;
    delete p_c187463;

    delete p_c187464_master_stg;
    delete p_c187464;

    delete p_c187471_master_stg;
    delete p_c187471;

    delete p_c187478;

    delete p_c4045282_master_stg;
    delete p_c4045282;

    delete p_c4045283_master_stg;
    delete p_c4045283;

    delete p_c4045286_master_stg;
    delete p_c4045286;

    delete p_c4045290_master_stg;
    delete p_c4045290;

    delete p_c4045291_master_stg;
    delete p_c4045291;

    delete p_c4045294_master_stg;
    delete p_c4045294;

    delete p_c2898585_master_stg;
    delete p_c2898585;

    delete p_c170805_master_stg;
    delete p_c170805;

    delete p_c4559714_func_a96;
    delete p_c4559714_func_e96;
    delete p_c4559714_func_s96;
    delete p_c4559714_func_x96v2;

    delete p_c4559714_master_stg;
    delete p_c4559714;

    delete p_can_ovl_one_dis_master_stg;
    delete p_can_ovl_one_dis;

    delete p_c4695722_master_stg;
    delete p_c4695722;

    delete p_c4686621_master_stg;
    delete p_c4686621;

    delete p_c4695725_master_stg;
    delete p_c4695725;

    delete p_c4695726_master_stg;
    delete p_c4695726;

    delete p_c4801978_master_stg;
    delete p_c4801978;

    delete p_c4801979_master_stg;
    delete p_c4801979;

    delete p_c4801981_master_stg;
    delete p_c4801981;

    delete p_c4828410_master_stg;
    delete p_c4828410;

    delete p_c4828414_master_stg;
    delete p_c4828414;

    delete p_c4559732_master_stg;
    delete p_c4559732;

    delete p_c4559733_master_stg;
    delete p_c4559733;

    delete p_c4559734_master_stg;
    delete p_c4559734;

    delete p_c4559735_master_stg;
    delete p_c4559735;

    delete p_c3357809_master_stg;
    delete p_c3357809;

    delete p_c3357810_master_stg;
    delete p_c3357810;

    delete p_c4360828_func_x96v2;

    delete p_c4360828_master_stg;
    delete p_c4360828;

    delete p_c4360832_master_stg;
    delete p_c4360832;

    delete p_c4360836_master_stg;
    delete p_c4360836;

    delete p_c4360840_master_stg;
    delete p_c4360840;

    delete p_c9257883_master_stg;
    delete p_c9257883;

    delete p_c9257885;

    delete p_c9257887_master_stg;
    delete p_c9257887;

    delete p_c9257888_master_stg;
    delete p_c9257888;

    delete p_c9257889_master_stg;
    delete p_c9257889;

    delete p_c9257890_master_stg;
    delete p_c9257890;

    delete p_c9377438_master_stg;
    delete p_c9377438;

    delete p_c3407086_master_stg;
    delete p_c3407086;

    delete p_c3407087_master_stg;
    delete p_c3407087;

    delete p_c9501311_master_stg;
    delete p_c9501311;

    delete p_c9501313_master_stg;
    delete p_c9501313;

    delete p_c9491969_master_stg;
    delete p_c9491969;

    delete p_c9491974_master_stg;
    delete p_c9491974;

    delete p_c9491977_master_stg;
    delete p_c9491977;

    delete p_c9491979_master_stg;
    delete p_c9491979;

    delete p_c9491980_master_stg;
    delete p_c9491980;

    delete p_c9491981_master_stg;
    delete p_c9491981;

    delete p_c9491982_master_stg;
    delete p_c9491982;

    delete p_c9501309_master_stg;
    delete p_c9501309;

    delete p_c9501310_master_stg;
    delete p_c9501310;

    delete p_c9501320_master_stg;
    delete p_c9501320;

    delete p_c9501322_master_stg;
    delete p_c9501322;

    delete p_c9508185_master_stg;
    delete p_c9508185;

    delete p_c9508187_master_stg;
    delete p_c9508187;

    delete p_c9645313_master_stg;
    delete p_c9645313;

    delete p_c9645315_master_stg;
    delete p_c9645315;

    delete p_c9645320_master_stg;
    delete p_c9645320;

    delete p_c9645322_master_stg;
    delete p_c9645322;

    delete p_c9658745_master_stg;
    delete p_c9658745;

    delete p_c9658747_master_stg;
    delete p_c9658747;

    delete p_c9658752_master_stg;
    delete p_c9658752;

    delete p_c9658754_master_stg;
    delete p_c9658754;

    delete p_c9745928_master_stg;
    delete p_c9745928;

    delete p_c9745929_master_stg;
    delete p_c9745929;

    delete p_c9745930_master_stg;
    delete p_c9745930;

    delete p_c9745931_master_stg;
    delete p_c9745931;

    delete p_c4930044_master_stg;
    delete p_c4930044;

    delete p_c4930051_master_stg;
    delete p_c4930051;

    delete p_c9801189_master_stg;
    delete p_c9801189;

    delete p_c9801190_master_stg;
    delete p_c9801190;

    delete p_c9913925_master_stg;
    delete p_c9913925;

    delete p_c9913926_master_stg;
    delete p_c9913926;

    delete p_c4363738_master_stg;
    delete p_c4363738;

    delete p_c4363739_master_stg;
    delete p_c4363739;

    delete p_c2874561_master_stg;
    delete p_c2874561;

    delete p_c2907769_master_stg;
    delete p_c2907769;

    delete p_c170801_master_stg;
    delete p_c170801;

    delete p_c10369958_func_a96;
    delete p_c10369958_func_e96;
    delete p_c10369958_func_s96;
    delete p_c10369958_func_x96v2;

    delete p_c10369958_master_stg;
    delete p_c10369958;

    delete p_c10419622_func_x96v2;

    delete p_c10369962_master_stg;
    delete p_c10369962;

    delete p_c10369966_master_stg;
    delete p_c10369966;

    delete p_c2874875_master_stg;
    delete p_c2874875;

    delete p_c10288872_func_r6eco;

    delete p_c10288872_master_stg;
    delete p_c10288872;

    delete p_c10419622_master_stg;
    delete p_c10419622;

    delete p_c10419629_master_stg;
    delete p_c10419629;

    delete p_c10419630_master_stg;
    delete p_c10419630;

    delete p_c10645338;

    delete p_c10485319_master_stg;
    delete p_c10485319;

    delete p_c10485321_master_stg;
    delete p_c10485321;

    delete p_c10634826_master_stg;
    delete p_c10634826;

    delete p_c10861710_master_stg;
    delete p_c10861710;

    delete p_c10861711_master_stg;
    delete p_c10861711;

    delete p_c10861712_master_stg;
    delete p_c10861712;

    delete p_c10861713_master_stg;
    delete p_c10861713;

    delete p_c10854614_func_a96;
    delete p_c10854614_func_e96;
    delete p_c10854614_func_s96;
    delete p_c10854614_func_x96v2;

    delete p_c10854614_master_stg;
    delete p_c10854614;

    delete p_c10854615_master_stg;
    delete p_c10854615;

    delete p_c10854594_master_stg;
    delete p_c10854594;

    delete p_c10854596_master_stg;
    delete p_c10854596;

    delete p_c10854607_master_stg;
    delete p_c10854607;

    delete p_c10854603_master_stg;
    delete p_c10854603;

    delete p_c10832739_master_stg;
    delete p_c10832739;

    delete p_c10964449_func_a96;
    delete p_c10964449_func_e96;
    delete p_c10964449_func_s96;
    delete p_c10964449_func_x96v2;

    delete p_c10964449_master_stg;
    delete p_c10964449;

    delete p_c10964450_master_stg;
    delete p_c10964450;

    delete p_c10634817_master_stg;
    delete p_c10634817;

    delete p_c11110395_master_stg;
    delete p_c11110395;

    delete p_video_reg_func_a96;
    delete p_video_reg_func_e96;
    delete p_video_reg_func_s96;
    delete p_video_reg_func_x96v2;

    delete p_c10415982;

    delete p_c11846848_master_stg;
    delete p_c11846848;

    delete p_c11946743_master_stg;
    delete p_c11946743;
}

AutoTestsModesP2 *AutoTestsModesP2::getInstance()
{
    // выделение памяти выполняется единожды
    if (!s_at_modes_p2)
    {
        s_at_modes_p2 = new AutoTestsModesP2();
    }

    return s_at_modes_p2;
}

void AutoTestsModesP2::addSim900(Sim900 *sim900)
{
    p_gsm = sim900;
}

void AutoTestsModesP2::addShieldPhone(const char *phone)
{
    m_shield_phones.insert(m_shield_phones.end(), phone);
    printf("DEBUG AutoTestsModesP2: Добавлен телефон GSM Shield-a: %s\n", phone);
}

void AutoTestsModesP2::init()
{
    if (m_shield_phones.size() < 1)
    {
        printf("DEBUG AutoTestsModesP2: Недостаточное кол-во телефонов Shield-a\n");
        return;
    }

    initR6EcoWires();

    switch (p_gen6->getDeviceName())
    {
        case GEN6_X96:
            initX96Settings();
            break;

        case GEN6_M96:
            initM96Settings();
            break;

        case GEN6_A96:
            initA96Settings();
            break;

        case GEN6_E96:
            initE96Settings();
            break;
        
        case GEN6_S96:
            initS96Settings();
            break;
        
        case GEN6_X96V2:
            initX96v2Settings();
            break;

        default:
            printf("FAIL Инициализация настроек: имя устройства не определено\n");
            break;
    }
}

void AutoTestsModesP2::initR6EcoWires()
{
    p_c10288872_func_r6eco             = new R6EcoChannels(ChannelsStruct::OUT_PN_HOOD_LOCK_A,       // синий
                                                           ChannelsStruct::OUT_PN_ENG_BLOCK);        // зеленый
}

void AutoTestsModesP2::initX96Wires()
{
    p_ppp_func_x96                     = new X96Channels(ChannelsStruct::OUT_P_SIREN,                // X96_XS1_01_OUT_GREY
                                                         ChannelsStruct::IN_N_TRUNK,                 // X96_XS1_02_IN_ORANGE_AND_GREY
                                                         ChannelsStruct::OUT_N_LOCK_B,               // X96_XS1_04_OUT_BLACK_AND_RED
                                                         ChannelsStruct::IN_P_IGN,                   // X96_XS1_05_IN_YELLOW
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96_XS1_06_CAN1_BROWN_AND_WHITE
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96_XS1_07_CAN1_BROWN
                                                         ChannelsStruct::OUT_P_LIGHTS,               // X96_XS1_08_OUT_GREEN_AND_BLACK
                                                         ChannelsStruct::OUT_P_ENG_BLOCK,            // X96_XS1_09_OUT_GREEN_AND_YELLOW
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_13_CAN2_GREEN
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_14_CAN2_BLUE

                                                         ChannelsStruct::IN_N_CAP_SENSOR,            // X96_XS2_01_OUT_YELLOW_AND_BLACK
                                                         ChannelsStruct::IN_P_GEARBOX_P,             // X96_XS2_02_OUT_ORANGE_AND_PURPLE
                                                         ChannelsStruct::OUT_N_HEAT_CTRL,            // X96_XS2_03_IN_YELLOW_AND_RED
                                                         ChannelsStruct::OUT_N_IMMO,                 // X96_XS2_04_OUT_PINK
                                                         ChannelsStruct::IN_N_DOORS,                 // X96_XS2_05_IN_ORANGE_AND_BLUE
                                                         ChannelsStruct::IN_P_RPM,                   // X96_XS2_06_IN_GREY_AND_BLACK
                                                         ChannelsStruct::IN_N_HOOD,                  // X96_XS2_07_IN_ORANGE_AND_WHITE
                                                         ChannelsStruct::IN_N_HAND_BRAKE,            // X96_XS2_08_IN_BLUE_AND_RED
                                                         ChannelsStruct::LIN_N_NONE,                 // X96_XS2_09_LIN
                                                         ChannelsStruct::OUT_N_LOCK_A,               // X96_XS2_10_OUT_ORANGE_AND_GREEN

                                                         ChannelsStruct::OUT_N_IGN2,                 // X96_XS3_01_OUT_GREEN
                                                         ChannelsStruct::OUT_N_IGN1,                 // X96_XS3_02_OUT_YELLOW
                                                         ChannelsStruct::OUT_N_ACC,                  // X96_XS3_03_OUT_BLUE
                                                         ChannelsStruct::OUT_N_STARTER);             // X96_XS3_04_OUT_BLACK_AND_YELLOW

    p_cap_sensor_func_x96              = new X96Channels(ChannelsStruct::OUT_P_SIREN,                // X96_XS1_01_OUT_GREY
                                                         ChannelsStruct::IN_N_TRUNK,                 // X96_XS1_02_IN_ORANGE_AND_GREY
                                                         ChannelsStruct::OUT_N_LOCK_B,               // X96_XS1_04_OUT_BLACK_AND_RED
                                                         ChannelsStruct::IN_P_IGN,                   // X96_XS1_05_IN_YELLOW
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96_XS1_06_CAN1_BROWN_AND_WHITE
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96_XS1_07_CAN1_BROWN
                                                         ChannelsStruct::OUT_P_LIGHTS,               // X96_XS1_08_OUT_GREEN_AND_BLACK
                                                         ChannelsStruct::OUT_P_ENG_BLOCK,            // X96_XS1_09_OUT_GREEN_AND_YELLOW
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_13_CAN2_GREEN
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_14_CAN2_BLUE

                                                         ChannelsStruct::IN_N_CAP_SENSOR,            // X96_XS2_01_OUT_YELLOW_AND_BLACK
                                                         ChannelsStruct::IN_P_GEARBOX_P,             // X96_XS2_02_OUT_ORANGE_AND_PURPLE
                                                         ChannelsStruct::OUT_N_TAG_STATUS_1,         // X96_XS2_03_IN_YELLOW_AND_RED
                                                         ChannelsStruct::OUT_N_IMMO,                 // X96_XS2_04_OUT_PINK
                                                         ChannelsStruct::IN_N_DOORS,                 // X96_XS2_05_IN_ORANGE_AND_BLUE
                                                         ChannelsStruct::IN_P_RPM,                   // X96_XS2_06_IN_GREY_AND_BLACK
                                                         ChannelsStruct::IN_N_HOOD,                  // X96_XS2_07_IN_ORANGE_AND_WHITE
                                                         ChannelsStruct::IN_N_HAND_BRAKE,            // X96_XS2_08_IN_BLUE_AND_RED
                                                         ChannelsStruct::LIN_N_NONE,                 // X96_XS2_09_LIN
                                                         ChannelsStruct::OUT_N_LOCK_A,               // X96_XS2_10_OUT_ORANGE_AND_GREEN

                                                         ChannelsStruct::OUT_N_IGN2,                 // X96_XS3_01_OUT_GREEN
                                                         ChannelsStruct::OUT_N_IGN1,                 // X96_XS3_02_OUT_YELLOW
                                                         ChannelsStruct::OUT_N_ACC,                  // X96_XS3_03_OUT_BLUE
                                                         ChannelsStruct::OUT_N_STARTER);             // X96_XS3_04_OUT_BLACK_AND_YELLOW

    p_cap_can_slave_func_x96           = new X96Channels(ChannelsStruct::OUT_P_SIREN,                // X96_XS1_01_OUT_GREY
                                                         ChannelsStruct::IN_N_CAP_SENSOR,            // X96_XS1_02_IN_ORANGE_AND_GREY
                                                         ChannelsStruct::OUT_N_ENG_BLOCK,            // X96_XS1_04_OUT_BLACK_AND_RED
                                                         ChannelsStruct::IN_P_IGN,                   // X96_XS1_05_IN_YELLOW
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96_XS1_06_CAN1_BROWN_AND_WHITE
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96_XS1_07_CAN1_BROWN
                                                         ChannelsStruct::IN_P_LIGHT_L,               // X96_XS1_08_OUT_GREEN_AND_BLACK
                                                         ChannelsStruct::IN_P_LOCK_A,                // X96_XS1_09_OUT_GREEN_AND_YELLOW
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_13_CAN2_GREEN
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_14_CAN2_BLUE

                                                         ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96_XS2_01_OUT_YELLOW_AND_BLACK
                                                         ChannelsStruct::IN_P_LIGHT_R,               // X96_XS2_02_OUT_ORANGE_AND_PURPLE
                                                         ChannelsStruct::IN_N_DOORS,                 // X96_XS2_03_IN_YELLOW_AND_RED
                                                         ChannelsStruct::OUT_N_IMMO,                 // X96_XS2_04_OUT_PINK
                                                         ChannelsStruct::OUT_N_LOCK_A,               // X96_XS2_05_IN_ORANGE_AND_BLUE
                                                         ChannelsStruct::IN_P_RPM,                   // X96_XS2_06_IN_GREY_AND_BLACK
                                                         ChannelsStruct::IN_N_LOCK_B,                // X96_XS2_07_IN_ORANGE_AND_WHITE
                                                         ChannelsStruct::IN_N_HAND_BRAKE,            // X96_XS2_08_IN_BLUE_AND_RED
                                                         ChannelsStruct::LIN_N_NONE,                 // X96_XS2_09_LIN
                                                         ChannelsStruct::OUT_N_LOCK_B,               // X96_XS2_10_OUT_ORANGE_AND_GREEN

                                                         ChannelsStruct::OUT_N_IGN2,                 // X96_XS3_01_OUT_GREEN
                                                         ChannelsStruct::OUT_N_IGN1,                 // X96_XS3_02_OUT_YELLOW
                                                         ChannelsStruct::OUT_N_ACC,                  // X96_XS3_03_OUT_BLUE
                                                         ChannelsStruct::OUT_N_STARTER);             // X96_XS3_04_OUT_BLACK_AND_YELLOW

    p_cap_analog_slave_func_x96        = p_cap_can_slave_func_x96;
    
    p_start_1_1_func_x96               = new X96Channels(ChannelsStruct::OUT_P_SIREN,                // X96_XS1_01_OUT_GREY
                                                         ChannelsStruct::IN_N_TRUNK,                 // X96_XS1_02_IN_ORANGE_AND_GREY
                                                         ChannelsStruct::OUT_N_HEAT_CTRL,            // X96_XS1_04_OUT_BLACK_AND_RED
                                                         ChannelsStruct::IN_P_NONE,                  // X96_XS1_05_IN_YELLOW
                                                         ChannelsStruct::IN_P_NONE,                  // X96_XS1_06_CAN1_BROWN_AND_WHITE
                                                         ChannelsStruct::IN_P_NONE,                  // X96_XS1_07_CAN1_BROWN
                                                         ChannelsStruct::OUT_P_LIGHT_L,              // X96_XS1_08_OUT_GREEN_AND_BLACK
                                                         ChannelsStruct::OUT_P_COMFORT,              // X96_XS1_09_OUT_GREEN_AND_YELLOW
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_13_CAN2_GREEN
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_14_CAN2_BLUE

                                                         ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96_XS2_01_OUT_YELLOW_AND_BLACK
                                                         ChannelsStruct::IN_P_IGN,                   // X96_XS2_02_OUT_ORANGE_AND_PURPLE
                                                         ChannelsStruct::IN_N_GEARBOX_P,             // X96_XS2_03_IN_YELLOW_AND_RED
                                                         ChannelsStruct::OUT_N_IMMO,                 // X96_XS2_04_OUT_PINK
                                                         ChannelsStruct::IN_N_DOORS,                 // X96_XS2_05_IN_ORANGE_AND_BLUE
                                                         ChannelsStruct::IN_P_RPM,                   // X96_XS2_06_IN_GREY_AND_BLACK
                                                         ChannelsStruct::IN_N_HEAT_CTRL,             // X96_XS2_07_IN_ORANGE_AND_WHITE
                                                         ChannelsStruct::IN_N_HAND_BRAKE,            // X96_XS2_08_IN_BLUE_AND_RED
                                                         ChannelsStruct::LIN_N_NONE,                 // X96_XS2_09_LIN
                                                         ChannelsStruct::OUT_N_LOCK_A,               // X96_XS2_10_OUT_ORANGE_AND_GREEN

                                                         ChannelsStruct::OUT_N_IGN2,                 // X96_XS3_01_OUT_GREEN
                                                         ChannelsStruct::OUT_N_IGN1,                 // X96_XS3_02_OUT_YELLOW
                                                         ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96_XS3_03_OUT_BLUE
                                                         ChannelsStruct::OUT_N_START_STOP_BTN);      // X96_XS3_04_OUT_BLACK_AND_YELLOW

    p_analog_can_slave_func_x96        = new X96Channels(ChannelsStruct::OUT_P_SIREN,                // X96_XS1_01_OUT_GREY
                                                         ChannelsStruct::IN_N_TRUNK,                 // X96_XS1_02_IN_ORANGE_AND_GREY
                                                         ChannelsStruct::OUT_N_ENG_BLOCK,            // X96_XS1_04_OUT_BLACK_AND_RED
                                                         ChannelsStruct::IN_P_IGN,                   // X96_XS1_05_IN_YELLOW
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96_XS1_06_CAN1_BROWN_AND_WHITE
                                                         ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96_XS1_07_CAN1_BROWN
                                                         ChannelsStruct::IN_P_LIGHT_L,               // X96_XS1_08_OUT_GREEN_AND_BLACK
                                                         ChannelsStruct::IN_P_LOCK_A,                // X96_XS1_09_OUT_GREEN_AND_YELLOW
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_13_CAN2_GREEN
                                                         ChannelsStruct::OUT_P_NONE,                 // X96_XS1_14_CAN2_BLUE

                                                         ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96_XS2_01_OUT_YELLOW_AND_BLACK
                                                         ChannelsStruct::IN_P_LIGHT_R,               // X96_XS2_02_OUT_ORANGE_AND_PURPLE
                                                         ChannelsStruct::IN_N_DOORS,                 // X96_XS2_03_IN_YELLOW_AND_RED
                                                         ChannelsStruct::OUT_N_IMMO,                 // X96_XS2_04_OUT_PINK
                                                         ChannelsStruct::OUT_N_LOCK_A,               // X96_XS2_05_IN_ORANGE_AND_BLUE
                                                         ChannelsStruct::IN_P_RPM,                   // X96_XS2_06_IN_GREY_AND_BLACK
                                                         ChannelsStruct::IN_N_LOCK_B,                // X96_XS2_07_IN_ORANGE_AND_WHITE
                                                         ChannelsStruct::IN_N_HAND_BRAKE,            // X96_XS2_08_IN_BLUE_AND_RED
                                                         ChannelsStruct::LIN_N_NONE,                 // X96_XS2_09_LIN
                                                         ChannelsStruct::OUT_N_LOCK_B,               // X96_XS2_10_OUT_ORANGE_AND_GREEN

                                                         ChannelsStruct::OUT_N_IGN2,                 // X96_XS3_01_OUT_GREEN
                                                         ChannelsStruct::OUT_N_IGN1,                 // X96_XS3_02_OUT_YELLOW
                                                         ChannelsStruct::OUT_N_ACC,                  // X96_XS3_03_OUT_BLUE
                                                         ChannelsStruct::OUT_N_STARTER);             // X96_XS3_04_OUT_BLACK_AND_YELLOW
}

void AutoTestsModesP2::initM96Wires()
{
    p_cap_sensor_func_m96                = new M96Channels(ChannelsStruct::LIN_N_NONE,                 // M96_XS1_01_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // M96_XS1_02_BLACK_AND_RED
                                                           ChannelsStruct::OUT_N_STARTER,              // M96_XS1_03_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // M96_XS1_04_GREEN
                                                           ChannelsStruct::OUT_N_ACC,                  // M96_XS1_05_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // M96_XS1_06_YELLOW_AND_GREEN
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // M96_XS1_07_BLACK_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN);                  // M96_XS1_13_YELLOW

    p_rearm_breake_func_m96              = new M96Channels(ChannelsStruct::LIN_N_NONE,                 // M96_XS1_01_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // M96_XS1_02_BLACK_AND_RED
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // M96_XS1_03_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // M96_XS1_04_GREEN
                                                           ChannelsStruct::OUT_N_ACC,                  // M96_XS1_05_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // M96_XS1_06_YELLOW_AND_GREEN
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // M96_XS1_07_BLACK_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN);                  // M96_XS1_13_YELLOW
    
    p_start_1_1_func_m96                 = new M96Channels(ChannelsStruct::LIN_N_NONE,                 // M96_XS1_01_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_NONE,                 // M96_XS1_02_BLACK_AND_RED
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // M96_XS1_03_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_NONE,                 // M96_XS1_04_GREEN
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // M96_XS1_05_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // M96_XS1_06_YELLOW_AND_GREEN
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // M96_XS1_07_BLACK_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN);                  // M96_XS1_13_YELLOW

    p_start_1_1_func_m96                 = new M96Channels(ChannelsStruct::LIN_N_NONE,                 // M96_XS1_01_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_NONE,                 // M96_XS1_02_BLACK_AND_RED
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // M96_XS1_03_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_NONE,                 // M96_XS1_04_GREEN
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // M96_XS1_05_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // M96_XS1_06_YELLOW_AND_GREEN
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // M96_XS1_07_BLACK_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN);                  // M96_XS1_13_YELLOW
}

void AutoTestsModesP2::initA96Wires()
{
    p_ppp_func_a96                       = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_cap_sensor_func_a96                = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_cap_can_slave_func_a96             = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_CAP_SENSOR,            // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_cap_analog_slave_func_a96          = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_LOCK_A,                // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_CAP_SENSOR,            // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_hood_analog_slave_func_a96         = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_LOCK_A,                // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_HOOD,                  // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_start_1_1_func_a96                 = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c1827097_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_analog_can_slave_func_a96          = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_LOCK_A,                // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c2198656_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_no_siren_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_NONE,                 // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c2799852_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c187478_func_a96                   = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_NONE,                  // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_NONE,                  // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_NONE,                  // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_NONE,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c4559714_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DRIVER_DOOR,           // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_PASSENGERS_DOOR,       // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_WBUS,                 // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c3688075_func_a96                  = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c10369958_func_a96                 = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c10854614_func_a96                 = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_COMFORT,              // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_NONE,                  // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_c10964449_func_a96                 = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_PROT_STAT,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC_EXC,              // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED

    p_video_reg_func_a96                 = new A96Channels(ChannelsStruct::OUT_PN_LOCK_B,              // A96_XS1_01_OUT_BLUE
                                                           ChannelsStruct::OUT_PN_LOCK_A,              // A96_XS1_04_OUT_GREEN

                                                           ChannelsStruct::OUT_P_LIGHTS,               // A96_XS2_03_OUT_GREEN_AND_BLACK

                                                           ChannelsStruct::OUT_N_VIDEO_REG,            // A96_XS3_01_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // A96_XS3_02_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // A96_XS3_03_IN_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // A96_XS3_04_OUT_PINK
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_05_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // A96_XS3_06_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // A96_XS3_07_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // A96_XS3_08_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // A96_XS3_09_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_NONE,                 // A96_XS3_10_OUT_BLUE
                                                           ChannelsStruct::IN_P_IGN,                   // A96_XS3_11_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // A96_XS3_12_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // A96_XS3_13_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // A96_XS3_14_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // A96_XS3_15_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // A96_XS3_16_IN_ORANGE_AND_GREY

                                                           ChannelsStruct::OUT_N_ACC,                  // A96_XS4_01_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // A96_XS4_02_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // A96_XS4_03_OUT_GREEN
                                                           ChannelsStruct::OUT_N_STARTER,              // A96_XS4_04_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // A96_XS4_05_OUT_ORANGE

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // A96_XS5_01_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // A96_XS5_02_IN_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // A96_XS5_03_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // A96_XS5_04_IN_BROWN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // A96_XS5_05_IN_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // A96_XS5_06_IN_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // A96_XS5_07_OUT_BLUE_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_ALT);            // A96_XS5_08_OUT_YELLOW_AND_RED
}

void AutoTestsModesP2::initE96Wires()
{
    p_ppp_func_e96                       = new E96Channels(ChannelsStruct::OUT_N_HEAT_CTRL,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_cap_sensor_func_e96                = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_cap_can_slave_func_e96             = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_cap_analog_slave_func_e96          = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_hood_analog_slave_func_e96         = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE
                                                           
    p_start_1_1_func_e96                 = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c1827097_func_e96                  = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_TRUNK,                 // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_analog_can_slave_func_e96          = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_hood_trunk_doors_e96               = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c2198656_func_e96                  = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_no_siren_func_e96                  = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c2799852_func_e96                  = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c187478_func_e96                   = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_NONE,                  // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_NONE,                  // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_NONE,                  // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_NONE,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c4559714_func_e96                  = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DRIVER_DOOR,           // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_PASSENGERS_DOOR,       // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_WBUS,                 // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c10369958_func_e96                 = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c10854614_func_e96                 = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_NONE,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_NONE,                 // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_c10964449_func_e96                 = new E96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC_EXC,              // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE

    p_video_reg_func_e96                 = new E96Channels(ChannelsStruct::OUT_N_NONE,                 // E96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // E96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // E96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // E96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // E96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // E96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // E96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_VIDEO_REG,            // E96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // E96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // E96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // E96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // E96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // E96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // E96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // E96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // E96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // E96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // E96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // E96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // E96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // E96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // E96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // E96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // E96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // E96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // E96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // E96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // E96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // E96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // E96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // E96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // E96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // E96_XS2_15_OUT_ORANGE
}

void AutoTestsModesP2::initS96Wires()
{  
    p_ppp_func_s96                       = new S96Channels(ChannelsStruct::OUT_N_HEAT_CTRL,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_cap_sensor_func_s96                = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_cap_can_slave_func_s96             = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_cap_analog_slave_func_s96          = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_hood_analog_slave_func_s96         = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE
                                                           
    p_start_1_1_func_s96                 = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c1827097_func_s96                  = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_TRUNK,                 // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_analog_can_slave_func_s96          = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_LOCK_B,                // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_hood_trunk_doors_s96               = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c2198656_func_s96                  = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_no_siren_func_s96                  = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_LOCK_A,                // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c2799852_func_s96                  = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c187478_func_s96                   = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_NONE,                  // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_NONE,                  // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_NONE,                  // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_NONE,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c4559714_func_s96                  = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DRIVER_DOOR,           // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_PASSENGERS_DOOR,       // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_WBUS,                 // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c10369958_func_s96                 = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c10854614_func_s96                 = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_TRUNK,                 // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_NONE,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_NONE,                 // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_c10964449_func_s96                 = new S96Channels(ChannelsStruct::OUT_N_PROT_STAT,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC_EXC,              // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE

    p_video_reg_func_s96                 = new S96Channels(ChannelsStruct::OUT_N_VIDEO_REG,            // S96_XS1_02_OUT_BLACK_AND_WHITE
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // S96_XS1_03_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_RPM,                   // S96_XS1_04_PWM_GREY_AND_BLACK
                                                           ChannelsStruct::OUT_N_IMMO,                 // S96_XS1_05_OUT_PINK
                                                           ChannelsStruct::OUT_N_R4_TX,                // S96_XS1_06_OUT_YELLOW_AND_ORANGE
                                                           ChannelsStruct::OUT_P_SIREN,                // S96_XS1_07_OUT_GREY
                                                           ChannelsStruct::OUT_N_TRUNK,                // S96_XS1_08_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // S96_XS1_09_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_LOCK_B,               // S96_XS1_10_OUT_BLUE
                                                           ChannelsStruct::OUT_N_DOORS_IMIT,           // S96_XS1_12_OUT_YELLOW_AND_WHITE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // S96_XS1_13_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::IN_P_IGN,                   // S96_XS1_14_IN_YELLOW
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // S96_XS1_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // S96_XS1_16_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // S96_XS1_17_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_DOORS,                 // S96_XS1_18_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::IN_N_HOOD,                  // S96_XS1_19_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_LOCK_A,               // S96_XS1_20_OUT_GREEN

                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // S96_XS2_01_CAN_B_ORANGE_AND_WHITE
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // S96_XS2_02_CAN_B_ORANGE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // S96_XS2_03_CAN_A_BROWN
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // S96_XS2_04_CAN_A_BROWN_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // S96_XS2_05_LIN_C_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // S96_XS2_06_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // S96_XS2_07_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // S96_XS2_08_OUT_GREEN
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // S96_XS2_09_LIN_A_GREY
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // S96_XS2_10_LIN_B_WHITE
                                                           ChannelsStruct::OUT_N_LIGHT_ALT,            // S96_XS2_11_OUT_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_LOCK_ALT,             // S96_XS2_12_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_NONE,                 // S96_XS2_13_ORANGE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // S96_XS2_14_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK);       // S96_XS2_15_OUT_ORANGE
}

void AutoTestsModesP2::initX96v2Wires()
{
    p_ppp_func_x96v2                   = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_cap_sensor_func_x96v2            = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_IMMO,                 // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::OUT_N_R4_TX);               // X96V2_XS2_20_IN_PURPLE

    p_cap_can_slave_func_x96v2         = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_IMMO,                 // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_cap_analog_slave_func_x96v2      = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_LOCK_B,                // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_LOCK_A,                // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_hood_analog_slave_func_x96v2     = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_LOCK_B,                // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_LOCK_A,                // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_rearm_breake_func_x96v2          = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_LOCK_B,                // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::IN_N_CAP_SENSOR,            // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE
                                                           
    p_start_1_1_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_GEARBOX_P,             // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL);          // X96V2_XS2_20_IN_PURPLE

    p_c1827097_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HOOD,                  // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_analog_can_slave_func_x96v2      = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_LOCK_B,                // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_LOCK_A,                // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_LIGHT_LR,              // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c2198656_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_R4_TX,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_BUZZER_EXT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK 
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_no_siren_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_NONE,                 // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_R4_TX,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_BUZZER_EXT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK 
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c2799852_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_TRUNK,                 // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL);          // X96V2_XS2_20_IN_PURPLE

    p_c2799854_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HOOD,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_TRUNK,                 // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL);          // X96V2_XS2_20_IN_PURPLE

    p_c187478_func_x96v2               = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_BRAKE_PEDAL,           // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_IMMO,                 // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TAG_STATUS_1,         // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::OUT_N_R4_TX);               // X96V2_XS2_20_IN_PURPLE

    p_c4559714_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_PASSENGERS_DOOR,       // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_HEAT_CTRL,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_DOORS,                 // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DRIVER_DOOR,           // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_TRUNK,                 // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_WBUS,                 // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c4360828_func_x96v2              = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HOOD,                  // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LIGHTS,               // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c10369958_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_GEARBOX_P,             // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c10419622_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_NONE,                  // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_BUZZER_EXT,           // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHTS,               // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_NONE,                 // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_HAND_BRAKE,            // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_NONE,                 // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_GEARBOX_P,             // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c10854614_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_TRUNK,                 // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_START_STOP_BTN,       // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_GEARBOX_P,             // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_NONE,                 // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_BRAKE_PEDAL,          // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_NONE,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_NONE,                 // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_c10964449_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_COMFORT,              // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_ENG_BLOCK,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::IN_P_GEARBOX_P,             // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC_EXC,              // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE

    p_video_reg_func_x96v2             = new X96V2Channels(ChannelsStruct::OUT_P_SIREN,                // X96V2_XS1_01_OUT_GREY
                                                           ChannelsStruct::IN_N_HEAT_CTRL,             // X96V2_XS1_02_IN_ORANGE_AND_GREY
                                                           ChannelsStruct::OUT_N_VIDEO_REG,            // X96V2_XS1_04_OUT_BLACK_AND_RED
                                                           ChannelsStruct::IN_P_IGN,                   // X96V2_XS1_05_IN_YELLOW
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AH,         // X96V2_XS1_06_IN_BROWN_AND_WHITE
                                                           ChannelsStruct::CAN1_P_FUNC_CAN_AL,         // X96V2_XS1_07_IN_BROWN
                                                           ChannelsStruct::OUT_P_LIGHT_ALT,            // X96V2_XS1_08_OUT_GREEN_AND_BLACK
                                                           ChannelsStruct::OUT_P_LOCK_ALT,             // X96V2_XS1_09_OUT_GREEN_AND_YELLOW
                                                           ChannelsStruct::OUT_N_LOCK_A,               // X96V2_XS1_13_OUT_GREEN
                                                           ChannelsStruct::OUT_N_LOCK_B,               // X96V2_XS1_14_OUT_BLUE

                                                           ChannelsStruct::OUT_N_TRUNK,                // X96V2_XS2_01_OUT_YELLOW_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BL,         // X96V2_XS2_02_IN_ORANGE
                                                           ChannelsStruct::IN_P_BRAKE_PEDAL,           // X96V2_XS2_03_IN_ORANGE_AND_PURPLE
                                                           ChannelsStruct::OUT_N_LOCK_B_DDOOR,         // X96V2_XS2_04_OUT_YELLOW_AND_RED
                                                           ChannelsStruct::OUT_N_IMMO,                 // X96V2_XS2_05_OUT_PINK
                                                           ChannelsStruct::IN_N_DOORS,                 // X96V2_XS2_06_IN_BLUE_AND_BLACK
                                                           ChannelsStruct::OUT_N_ACC,                  // X96V2_XS2_07_OUT_BLUE
                                                           ChannelsStruct::OUT_N_IGN1,                 // X96V2_XS2_08_OUT_YELLOW
                                                           ChannelsStruct::OUT_N_IGN2,                 // X96V2_XS2_09_OUT_GREEN
                                                           ChannelsStruct::OUT_P_DOORS_IMIT,           // X96V2_XS2_10_OUT_ORANGE_AND_BLACK
                                                           ChannelsStruct::IN_P_RPM,                   // X96V2_XS2_11_IN_GREY_AND_BLACK
                                                           ChannelsStruct::CAN2_P_FUNC_CAN_BH,         // X96V2_XS2_12_IN_ORANGE_AND_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN_B,           // X96V2_XS2_13_IN_WHITE
                                                           ChannelsStruct::LIN_P_FUNC_LIN,             // X96V2_XS2_14_IN_GREY
                                                           ChannelsStruct::IN_N_HAND_BRAKE,            // X96V2_XS2_15_IN_BLUE_AND_RED
                                                           ChannelsStruct::LIN_P_FUNC_LIN_C,           // X96V2_XS2_16_IN_WHITE_AND_BLACK
                                                           ChannelsStruct::OUT_N_STARTER,              // X96V2_XS2_17_OUT_BLACK_AND_YELLOW
                                                           ChannelsStruct::OUT_N_STARTER_BLOCK,        // X96V2_XS2_18_OUT_ORANGE
                                                           ChannelsStruct::IN_N_NONE);                 // X96V2_XS2_20_IN_PURPLE
}

void AutoTestsModesP2::initX96MasterStg()
{
    p_c168671_master_stg = new SlmSettings();
    p_c168671_master_stg->add(MASTER_SETTINGS::ARM_SUPP_TRIG,                                                  "1");
    p_c168671_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c168671_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168671_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    
    p_c168672_master_stg = new SlmSettings();
    p_c168672_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "0");
    p_c168672_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "0");
    
    p_c168685_master_stg = new SlmSettings();
    p_c168685_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168685_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168685_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c168685_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);    
    p_c168685_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "1");
    p_c168685_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                        "1");
    
    p_c168686_master_stg = new SlmSettings();
    p_c168686_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168686_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168686_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c168686_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);    
    p_c168686_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "0");
    p_c168686_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                        "0");
    p_c168686_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                   "1");
    p_c168686_master_stg->add(MASTER_SETTINGS::ANALOG_SLAVE_TIMINGS_LOCK_TIME_MS,                              "5000");
    p_c168686_master_stg->add(MASTER_SETTINGS::ANALOG_SLAVE_TIMINGS_UNLOCK_TIME_MS,                            "5000");
    
    p_c168687_master_stg = new SlmSettings();
    p_c168687_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168687_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168687_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    "+71111111111");
    
    p_c168688_master_stg = new SlmSettings();
    p_c168688_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168688_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168688_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    
    p_c168695_master_stg = new SlmSettings();
    p_c168695_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168695_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168695_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                      "1");
    p_c168695_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "1");
    p_c168695_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(4 | 16));
    p_c168695_master_stg->add(MASTER_SETTINGS::HANDS_FREE_DISABLE_DISARM_PROFILE,                              "0");
    
    p_c168696_master_stg = new SlmSettings();
    p_c168696_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168696_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168696_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                      "1");
    p_c168696_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "1");
    p_c168696_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(8 | 32));
    p_c168696_master_stg->add(MASTER_SETTINGS::HANDS_FREE_DISABLE_DISARM_PROFILE,                              "0");
    
    p_c168703_master_stg = new SlmSettings();
    p_c168703_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168703_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168703_master_stg->add(MASTER_SETTINGS::SENSOR_PIN_ALLOWED,                                             "1");

    p_c168707_master_stg = new SlmSettings();
    p_c168707_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168707_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168707_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                      "0");
    p_c168707_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "0");
    p_c168707_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(1 | 4));
    p_c168707_master_stg->add(MASTER_SETTINGS::HANDS_FREE_DISABLE_DISARM_PROFILE,                              "0");
    
    p_c168714_master_stg = new SlmSettings();
    p_c168714_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168714_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    
    p_c168723_master_stg = new SlmSettings();
    p_c168723_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                       "1");
    p_c168723_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                      "1");
    p_c168723_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                      "1");
    p_c168723_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "1");
    p_c168723_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(8 | 32));
    p_c168723_master_stg->add(MASTER_SETTINGS::HANDS_FREE_DISABLE_DISARM_PROFILE,                              "0");
    p_c168723_master_stg->add(MASTER_SETTINGS::SENSOR_PIN_ALLOWED,                                             "1");
    
    p_c170781_master_stg = new SlmSettings();
    p_c170781_master_stg->add(MASTER_SETTINGS::TSKES_COND_TEMP_LOW_EN,                                         "1");                          // Включить автозапуск по тепературе
    p_c170781_master_stg->add(MASTER_SETTINGS::TSKES_COND_TEMP_LOW_THD,                                        "1");                          // Тепмература запуска 1 градус
    
    p_c170782_master_stg = new SlmSettings();
    p_c170782_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_UNLOCK_PROFILE,                                      "1");
    p_c170782_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_LOCK_PROFILE,                                        "1");
    p_c170782_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_UNLOCK_PROFILE,                                      "1");
    p_c170782_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_LOCK_PROFILE,                                        "1");
    p_c170782_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    
    p_c170792_master_stg = new SlmSettings();
    p_c170792_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "1");
    p_c170792_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(16));
    
    p_c170799_master_stg = new SlmSettings();
    p_c170799_master_stg->add(MASTER_SETTINGS::HANDS_FREE_GLOBAL_ENABLE,                                       "1");
    p_c170799_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(4));
    
    p_c170800_master_stg = new SlmSettings();
    p_c170800_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c170800_master_stg->add(MASTER_SETTINGS::INSURANCE_LEARN_AVAILABLE,                                      "1");
    
    p_c170821_master_stg = new SlmSettings();
    p_c170821_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c170821_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                             StringConverter<int32_t>::toString(16));

    p_c171184_master_stg = new SlmSettings();
    p_c171184_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_EN,                                           "1");
    p_c171184_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_DELAY_S,                                      "30");
    
    p_c169641_master_stg = new SlmSettings();
    p_c169641_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169641_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_TYPE,                                                 "1");
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    
    p_c169642_master_stg = new SlmSettings();
    p_c169642_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169642_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_TYPE,                                                 "1");
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "1");
    
    p_c169643_master_stg = new SlmSettings();
    p_c169643_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169643_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_TYPE,                                                 "1");
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "1");
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    
    p_c169639_master_stg = new SlmSettings();
    p_c169639_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169639_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_CAN,                                                  "1");
    
    p_c169640_master_stg = new SlmSettings();
    p_c169640_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169640_master_stg->add(MASTER_SETTINGS::CAN_STATUS_IGNITION,                                            "1");
    p_c169640_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_ENGINE_START,                                       "1");
    p_c169640_master_stg->add(MASTER_SETTINGS::ENG_START_BLOCK_CAN,                                            "1");
    
    p_c1616162_master_stg = new SlmSettings();
    p_c1616162_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1616162_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        "1");
    p_c1616162_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      "1");
    p_c1616162_master_stg->add(MASTER_SETTINGS::ENG_START_GENTLE_STOP,                                         "0");
    p_c1616162_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");
    p_c1616162_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "2");
    
    p_c1616163_master_stg = new SlmSettings();
    p_c1616163_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1616163_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        "1");
    p_c1616163_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      "1");
    p_c1616163_master_stg->add(MASTER_SETTINGS::ENG_START_GENTLE_STOP,                                         "1");
    p_c1616163_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");
    p_c1616163_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "2");
    
    p_c1616164_master_stg = new SlmSettings();
    p_c1616164_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1616164_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        "1");
    p_c1616164_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      "1");
    p_c1616164_master_stg->add(MASTER_SETTINGS::ENG_START_GENTLE_STOP,                                         "2");
    p_c1616164_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");
    p_c1616164_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "2");
    
    p_c1624514_master_stg = new SlmSettings();
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_AHJ_EN,                                             "1");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_MS,                                    "10000");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_MS,                                 "5000");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_MS,                           "5000");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_MS,                            "1000");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    
    p_c1624516_master_stg = new SlmSettings();
    p_c1624516_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             "1");
    p_c1624516_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          "0");
    
    p_c1624517_master_stg = new SlmSettings();
    p_c1624517_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             "1");
    p_c1624517_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          "1");
    
    p_c1624518_master_stg = new SlmSettings();
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_UNK_CALL_DIS,                                 "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_OWN_CALL_DIS,                                 "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_SERVER_DIS,                                   "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_HANDS_FREE_DIS,                               "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_MS,                  "15000");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_MS,                      "1000");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_MS,                          "1000");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_MS,                           "1000");

    p_c172480_master_stg = new SlmSettings();
    p_c172480_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");    
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_IGNITION,                                            "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                        "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_CAN,                                                  "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         "0");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_SPEED,                                                "30");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_BRAKE_PEDAL,                                          "0");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_BRAKE_PEDAL,                                         "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_GEAR_P,                                              "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_ENGINE_CONTROL,                                      "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_ACC,                                                 "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_DRIVER_DOOR,                                         "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_TRUNK,                                               "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_HOOD,                                                "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_PARK_BRAKE,                                          "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_LOCK,                                               "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_UNLOCK,                                             "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_LOCK_FACTORY_ARM,                                   "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_UNLOCK_FACTORY_DISARM,                              "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_PARAM_SLAVE_JOINT,                                          "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_DISARM,                                      "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ARM,                                         "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_START_ENABLE,                                               "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                       "0");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         "0");
    p_c172480_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                             "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                     "5");
    p_c172480_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                   "5");
    p_c172480_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                              "1");

    p_c172498_master_stg = new SlmSettings(*p_c172480_master_stg);
    p_c172498_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_BRAKE_PEDAL,                                      "1");
    p_c172498_master_stg->add(MASTER_SETTINGS::CAN_STATUS_BRAKE_PEDAL,                                         "1");

    p_c172473_master_stg = new SlmSettings();
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");    
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_IGNITION,                                            "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                        "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_START_BLOCK_CAN,                                            "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         "0");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_SPEED,                                                "30");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_BRAKE_PEDAL,                                          "0");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_BRAKE_PEDAL,                                         "0");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_GEAR_P,                                              "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_ENGINE_CONTROL,                                      "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_ACC,                                                 "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_DRIVER_DOOR,                                         "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_TRUNK,                                               "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_HOOD,                                                "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::CAN_STATUS_PARK_BRAKE,                                          "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_START_ENABLE,                                               "1");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                       "0");
    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         "0");

    p_c2043655_master_stg = new SlmSettings();
    p_c2043655_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2043655_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "1");
    p_c2043655_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "0");
    p_c2043655_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TRUNK_DOORS_DELAY_EN,                               "0");

    p_c2043657_master_stg = new SlmSettings(*p_c2043655_master_stg);
    p_c2043657_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "0");

    p_c2043659_master_stg = new SlmSettings(*p_c2043655_master_stg);
    p_c2043659_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "0"); 
    p_c2043659_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                              "1");

    p_c2043661_master_stg = new SlmSettings(*p_c2043655_master_stg);
    p_c2043661_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "0"); 
    p_c2043661_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                              "1");
    p_c2043661_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TRUNK_DOORS_DELAY_EN,                           "1");
    

    p_c2405376_master_stg = new SlmSettings();
    p_c2405376_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_BEACH_MODE_EN,                                      "1");
    p_c2405376_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_BEACH_MODE_EN,                                     "1");
    p_c2405376_master_stg->add(MASTER_SETTINGS::SENSOR_PIN_ALLOWED,                                            "1");

    p_c2405378_master_stg = new SlmSettings();
    p_c2405378_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_FOR_TRUNK_NEEDED,                               "1");
    p_c2405378_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_WAIT_S,                                "60");
    p_c2405378_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "1");
    p_c2405378_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                            "60");
    
    p_c2405379_master_stg = new SlmSettings(*p_c2405378_master_stg);
    p_c2405379_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_WAIT_S,                            "15");
    p_c2405379_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                        "15");
    p_c2405379_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2405379_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                      "1");
    p_c2405379_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "0");
    p_c2405379_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "1");
    p_c2405379_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_OPEN_TRUNK,                                        "1");
    p_c2405379_master_stg->add(MASTER_SETTINGS::CAN_STATUS_TRUNK,                                              "1");
    p_c2405379_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG | AUTH_REMOTE));
    p_c2405379_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "15");
    p_c2405379_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                            "0");

    p_c2728677_master_stg = new SlmSettings();
    p_c2728677_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c2728677_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        "0");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_IGNITION,                                           "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_ENGINE_CONTROL,                                     "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_GEAR_P,                                             "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_DISARM,                                     "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ARM,                                        "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                      "1");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2728677_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      "4");
    p_c2728677_master_stg->add(MASTER_SETTINGS::CAN_PARAM_IMMO_BYPASS_TYPE,                                    "2");
    p_c2728677_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "0");
    p_c2728677_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             "0");
    p_c2728677_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "0");
    p_c2728677_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          "0");
    p_c2728677_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_STARTING_CAN,                                 StringConverter<int32_t>::toString(  ARM_STATE
                                                                                                                                                  | WAIT_AUTH_STATE 
                                                                                                                                                  | MOVE_FORBID_STATE));

    p_c2728678_master_stg = new SlmSettings(*p_c2728677_master_stg);
    p_c2728678_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   "4");

    p_c2728679_master_stg = new SlmSettings(*p_c2728677_master_stg);
    p_c2728679_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   "4");
    p_c2728679_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         "1");
    p_c2728679_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                  "1");
    p_c2728679_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                      "0");

    p_c2728682_master_stg = new SlmSettings(*p_c2728677_master_stg);
    p_c2728682_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_STARTING_CAN,                             "0");

    p_c2728683_master_stg = new SlmSettings(*p_c2728682_master_stg);
    p_c2728683_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   "4");

    p_c2728684_master_stg = new SlmSettings(*p_c2728682_master_stg);
    p_c2728684_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   "4");
    p_c2728684_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         "1");
    p_c2728684_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                  "1");
    p_c2728684_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                      "0");

    p_c172464_master_stg = new SlmSettings();
    p_c172464_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_HOOD_TRANSFER,                                      "1");

    p_c1662256_master_stg = new SlmSettings(*p_c172464_master_stg);
    p_c1662256_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "1");
    p_c1662256_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_LOCK_TIME_100MS,                    "50");
    p_c1662256_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_UNLOCK_TIME_100MS,                  "50");
    p_c1662256_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TRUNK_DOORS_DELAY_EN,                               "1");

    p_c1662261_master_stg = new SlmSettings(*p_c172464_master_stg);
    p_c1662261_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1662261_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                      "1");
    p_c1662261_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "1");
    p_c1662261_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ARM,                                        "1");
    p_c1662261_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_DISARM,                                     "1");
    p_c1662261_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "0");

    p_c169588_master_stg = new SlmSettings(*p_c172464_master_stg);
    p_c169588_master_stg->replace(MASTER_SETTINGS::R6_SETTINGS_HOOD_TRANSFER,                                  "0");

    p_c169591_master_stg = new SlmSettings(*p_c169588_master_stg);
    p_c169591_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_SIREN_TYPE,                                         "0");

    p_c169592_master_stg = new SlmSettings(*p_c169588_master_stg);
    p_c169592_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_SIREN_TYPE,                                         "1");

    p_c169593_master_stg = new SlmSettings(*p_c169588_master_stg);
    p_c169593_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_SIREN_TYPE,                                         "2");

    p_c2889927_master_stg = new SlmSettings();
    p_c2889927_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2889927_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                      "1");
    p_c2889927_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                     "1");
    p_c2889927_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "1");
    p_c2889927_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                            StringConverter<int32_t>::toString(A96_HF_TAG_DISARM | A96_HF_TAG_ARM));
    p_c2889927_master_stg->add(MASTER_SETTINGS::HANDS_FREE_DISABLE_ARM_PROFILE,                                StringConverter<int32_t>::toString(HF_ARM_OFF_BY_DOUBLE_DISARM));
    p_c2889927_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c2889927_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "30");

    p_c2889927_no_hf_master_stg = new SlmSettings();
    p_c2889927_no_hf_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                               "0");

    p_c3052203_master_stg = new SlmSettings();
    p_c3052203_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c3052203_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c3052203_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_BTN | AUTH_SMART_TAG));
    p_c3052203_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));

    p_c3052206_master_stg = new SlmSettings(*p_c3052203_master_stg);
    p_c3052206_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                      StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_IGN_OFF));

    p_c2799849_master_stg = new SlmSettings();
    p_c2799849_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_SIREN_TYPE,                                        StringConverter<int32_t>::toString(R6_SIREN));

    p_c2799850_master_stg = new SlmSettings();
    p_c2799850_master_stg->add(MASTER_SETTINGS::R6_SETTINGS_SIREN_TYPE,                                        StringConverter<int32_t>::toString(R6_NONE));

    p_c3202904_master_stg = new SlmSettings();
    p_c3202904_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");    
    p_c3202904_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                      "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_LOCK_SLAVE_PROFILE,                                 "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_LOCK_SLAVE_PROFILE,                                 "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::LOCK_WITH_DOORS,                                               "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_LOCK_WITH_DOORS_EN,                                 "1");
    p_c3202904_master_stg->add(MASTER_SETTINGS::ANALOG_SLAVE_TIMINGS_LOCK_TIME_MS,                             "5000");
    p_c3202904_master_stg->add(MASTER_SETTINGS::ANALOG_SLAVE_TIMINGS_UNLOCK_TIME_MS,                           "5000");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_LOCK_TIME_100MS,                    "50");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_UNLOCK_TIME_100MS,                  "50");
    p_c3202904_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TRUNK_DOORS_DELAY_EN,                               "1");

    p_c20461_master_stg = new SlmSettings();
    p_c20461_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_REMOTE,                                    "1");
    p_c20461_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_GSM,                                       "0");
    p_c20461_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_SERVER,                                    "0");
    p_c20461_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                     m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c20462_master_stg = new SlmSettings();
    p_c20462_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_REMOTE,                                    "0");
    p_c20462_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_GSM,                                       "1");
    p_c20462_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_SERVER,                                    "0");
    p_c20462_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                     m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c20463_master_stg = new SlmSettings();
    p_c20463_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_REMOTE,                                    "0");
    p_c20463_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_GSM,                                       "0");
    p_c20463_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_SERVER,                                    "1");
    p_c20463_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                     m_shield_phones[SHIELD_PHONE_NO_1]);

    p_auth_no_tag_needed_master_stg = new SlmSettings();
    p_auth_no_tag_needed_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_REMOTE,                        "0");
    p_auth_no_tag_needed_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_GSM,                           "0");
    p_auth_no_tag_needed_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_SERVER,                        "0");
    p_auth_no_tag_needed_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                         m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c2799852_master_stg = new SlmSettings();
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_MANUAL));
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c2799852_master_stg->add(MASTER_SETTINGS::CAN_PARAM_IMMO_BYPASS_TYPE,                                    StringConverter<int32_t>::toString(ENG_IMMO_BYPASS_ANALOG));
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_IMMO_BYPASS_CTRL_TYPE,                               StringConverter<int32_t>::toString(ENG_IMMO_ALWAYS_WITH_TT));
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_TRIES_NUM,                                           "1");
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                            "1");
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_FIRST_ON_DELAY_100MS,                      "50");
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_ON_DELAY_S,                           "5");
    p_c2799852_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_DURATION_100MS,                       "50");
    p_c2799852_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c2799853_master_stg = new SlmSettings(*p_c2799852_master_stg);
    p_c2799853_master_stg->replace(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                        "2");

    p_c2799854_master_stg = new SlmSettings(*p_c2799852_master_stg);
    p_c2799854_master_stg->replace(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                        "3");

    p_c3752984_master_stg = new SlmSettings();
    p_c3752984_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c3752984_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c3752984_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_MANUAL));
    p_c3752984_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c3752984_master_stg->add(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                            "1");
    p_c3752984_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_LOCK_PROFILE,                                       StringConverter<int32_t>::toString(GUARD_LOCK_PROFILE_SPEED_LIMIT));
    p_c3752984_master_stg->add(MASTER_SETTINGS::GUARD_LOCK_LOCK_SPEED_KMPH,                                    "50");
    p_c3752984_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                        StringConverter<int32_t>::toString(SERVICE_EXIT_COND_MASK_SPEED));
    p_c3752984_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                       "30");
    p_c3752984_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c3752985_master_stg = new SlmSettings(*p_c3752984_master_stg);
    p_c3752985_master_stg->replace(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                  StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));
    p_c3752985_master_stg->add(MASTER_SETTINGS::ENG_START_IGN_SUPP_TYPE,                                       StringConverter<int32_t>::toString(IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING));

    p_c3752986_master_stg = new SlmSettings(*p_c3752985_master_stg);
    p_c3752986_master_stg->replace(MASTER_SETTINGS::ENG_START_IGN_SUPP_TYPE,                                   StringConverter<int32_t>::toString(IGN_SUPP_TYPE_IGN_OFF));

    p_c3752987_master_stg = new SlmSettings(*p_c3752984_master_stg);
    p_c3752987_master_stg->replace(MASTER_SETTINGS::GUARD_LOCK_LOCK_PROFILE,                                   StringConverter<int32_t>::toString(GUARD_LOCK_PROFILE_HAND_BRAKE_OFF));

    p_c3136858_master_stg = new SlmSettings();
    p_c3136858_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3136858_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_IGN_OFF));
    p_c3136858_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_no_rearm_master_stg = new SlmSettings();
    p_no_rearm_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_EN,                                          "0");

    p_c3688077_master_stg = new SlmSettings();
    p_c3688077_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_EN,                                          "1");
    p_c3688077_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_DELAY_S,                                     "10");

    p_c3697245_master_stg = new SlmSettings();
    p_c3697245_master_stg->add(MASTER_SETTINGS::ENG_START_IGN_SUPP_TYPE,                                       StringConverter<int32_t>::toString(IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING));
    p_c3697245_master_stg->add(MASTER_SETTINGS::ENG_START_NEUTRAL_DETECT_TYPE,                                 StringConverter<int32_t>::toString(NEUTRAL_DETECT_TYPE_DOOR));
    p_c3697245_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_MANUAL));
    p_c3697245_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c3697245_master_stg->add(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                            "1");
    p_c3697245_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_EN,                                          "1");
    p_c3697245_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_DELAY_S,                                     "5");
    p_c3697245_master_stg->add(MASTER_SETTINGS::DOOR_IMIT_CTRL,                                                StringConverter<int32_t>::toString(DOOR_IMIT_ALWAYS));
    p_c3697245_master_stg->add(MASTER_SETTINGS::OUTS_CTRL_DOORS_IMIT_PAUSE_MS,                                 "5000");
    p_c3697245_master_stg->add(MASTER_SETTINGS::OUTS_CTRL_DOORS_IMIT_DURATION_MS,                              "20000");
    p_c3697245_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c3688075_master_stg = new SlmSettings(*p_c3697245_master_stg);
    p_c3688075_master_stg->replace(MASTER_SETTINGS::OUTS_CTRL_DOORS_IMIT_DURATION_MS,                          "10000");
    p_c3688075_master_stg->replace(MASTER_SETTINGS::GUARD_REARM_REARM_DELAY_S,                                 "20");

    p_c3688076_master_stg = new SlmSettings();
    p_c3688076_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_EN,                                          "1");
    p_c3688076_master_stg->add(MASTER_SETTINGS::GUARD_REARM_REARM_DELAY_S,                                     "10");

    p_no_auth_master_stg = new SlmSettings();
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                        StringConverter<int32_t>::toString(AUTH_NONE));
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                    "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                       "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_SERVER_DIS,                                    "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_OWN_CALL_DIS,                                  "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_HANDS_FREE_DIS,                                "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                           StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                              "0");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                         "1");
    p_no_auth_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                      "0");

    p_c3136863_master_stg = new SlmSettings();
    p_c3136863_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c3136863_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c3136863_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                        StringConverter<int32_t>::toString(SERVICE_EXIT_COND_MASK_MILEAGE));
    p_c3136863_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                       "20");
    p_c3136863_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                        "100");
    p_c3136863_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c3136864_master_stg = new SlmSettings(*p_c3136863_master_stg);
    p_c3136864_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                    StringConverter<int32_t>::toString(SERVICE_EXIT_COND_MASK_SPEED));
    p_c3136864_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "15");
    p_c3136864_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "500");

    p_c170806_master_stg = new SlmSettings();
    p_c170806_master_stg->add(MASTER_SETTINGS::ENG_START_ENABLE,                                               "1");
    p_c170806_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c170806_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                       StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));
    p_c170806_master_stg->add(MASTER_SETTINGS::CAN_PARAM_IMMO_BYPASS_TYPE,                                     StringConverter<int32_t>::toString(ENG_IMMO_BYPASS_ANALOG));
    p_c170806_master_stg->add(MASTER_SETTINGS::ENG_START_IMMO_BYPASS_CTRL_TYPE,                                StringConverter<int32_t>::toString(ENG_IMMO_ALWAYS_WITH_TT));
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ON,                                                        "241");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_TRIGGER_START_0_GROUP_ID,                                  "3083");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_TRIGGER_START_0_TYPE,                                      "6");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_GROUP_ID,                                         "3082");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_TYPE,                                             "1");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_DELAY,                                            "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_TRIGGER_START_0_RANGE_LOW,                                 "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_TRIGGER_START_0_RANGE_HIGH,                                "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_T1,                                               "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_T2,                                               "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_T3,                                               "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_T4,                                               "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_REPEAT_COUNT,                                     "0");
    p_c170806_master_stg->add(MASTER_SETTINGS::FL_0_ACTION_0_ZONE_MASK,                                        "0");

    p_c187473_master_stg = new SlmSettings();
    p_c187473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c187473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                        StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));
    p_c187473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");

    p_c187475_master_stg = new SlmSettings(*p_c187473_master_stg);
    p_c187475_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                    StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_IGN_ON));

    p_c187457_master_stg = new SlmSettings();
    p_c187457_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NC));
    p_c187457_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
    p_c187457_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c187457_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c187457_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                         "1");

    p_c187458_master_stg = new SlmSettings(*p_c187457_master_stg);
    p_c187458_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c187458_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c187458_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c187458_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                               "1");

    p_c187459_master_stg = new SlmSettings(*p_c187457_master_stg);
    p_c187459_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                   "1");
    p_c187459_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                       "3");

    p_c187462_master_stg = new SlmSettings(*p_c187458_master_stg);
    p_c187462_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                   "1");
    p_c187462_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                       "3");

    p_c187463_master_stg = new SlmSettings(*p_c187462_master_stg);
    p_c187463_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                               "0");

    p_c187464_master_stg = new SlmSettings(*p_c187458_master_stg);
    p_c187464_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                   "0");

    p_c187471_master_stg = new SlmSettings(*p_c187458_master_stg);
    p_c187471_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                               "0");
    p_c187471_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                   "0");

    p_c4045282_master_stg = new SlmSettings();
    p_c4045282_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c4045282_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "1");
    p_c4045282_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                            "15");

    p_c4045283_master_stg = new SlmSettings(*p_c4045282_master_stg);
    p_c4045283_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c4045286_master_stg = new SlmSettings(*p_c4045282_master_stg);
    p_c4045286_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_NONE));

    p_c4045290_master_stg = new SlmSettings(*p_c4045282_master_stg);
    p_c4045290_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "0");

    p_c4045291_master_stg = new SlmSettings(*p_c4045283_master_stg);
    p_c4045291_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "0");

    p_c4045294_master_stg = new SlmSettings(*p_c4045286_master_stg);
    p_c4045294_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "0");

    p_c2898585_master_stg = new SlmSettings();
    p_c2898585_master_stg->add(MASTER_SETTINGS::CAN_OVL_ONE,                                                   "1");
    p_c2898585_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "3732");
    p_c2898585_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ALARM,                                      "1");
    p_c2898585_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c2898585_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY0_PHONE,                                         StringConverter<int32_t>::toString(M1_CALL | M1_SMS));

    p_c170805_master_stg = new SlmSettings();
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_LOCK_FACTORY_ARM,                                   "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_PARAM_SLAVE_JOINT,                                          "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_DISARM,                                      "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ARM,                                         "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                       "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                         StringConverter<uint32_t>::toString(ENG_GEARBOX_AUTO));
    p_c170805_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                       StringConverter<uint32_t>::toString(ENG_START_START_STOP));
    p_c170805_master_stg->add(MASTER_SETTINGS::ENG_START_ENABLE,                                               "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::SLAVE_ENG_START_EN,                                             "1");
    p_c170805_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                    m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c4559714_master_stg = new SlmSettings();
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "15");
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                       "1");
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                           "10");
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                            "15");
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_DOOR_EN,                                      StringConverter<int32_t>::toString(GUARD_AUTH_SLAVE_DOOR_EN_DOOR_OR_TRUNK));
    p_c4559714_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c4695722_master_stg = new SlmSettings();
    p_c4695722_master_stg->add(MASTER_SETTINGS::CAN_OVL_ONE,                                                   "1");    // Включение индивидуальной прошивки (т.к. только в ней есть нужный автомобиль)
    p_c4695722_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9942"); // Автомобиль с возможностью блокировки АКПП
    p_c4695722_master_stg->add(MASTER_SETTINGS::CAN_STATUS_GEAR_P,                                             "1");
    p_c4695722_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c4695722_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c4695722_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                        "1");
    p_c4695722_master_stg->add(MASTER_SETTINGS::GEARBOX_BLOCK_EN,                                              "1");

    p_can_ovl_one_dis_master_stg = new SlmSettings();
    p_can_ovl_one_dis_master_stg->add(MASTER_SETTINGS::CAN_OVL_ONE,                                            "0");    // Выключение индивидуальной прошивки
    p_can_ovl_one_dis_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                            "0");    // Во время смены настроек должна быть выбрана машина из списка текущей прошивки

    p_c4686621_master_stg = new SlmSettings(*p_c4695722_master_stg);
    p_c4686621_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG | GUARD_AHJ_KEYRING));
    p_c4686621_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    p_c4686621_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c4686621_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "1");
    p_c4686621_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "10");
    p_c4686621_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c4695725_master_stg = new SlmSettings(*p_c4695722_master_stg);
    p_c4695725_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");
    p_c4695725_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");
    p_c4695725_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_BTN));

    p_c4695726_master_stg = new SlmSettings(*p_c4695722_master_stg);
    p_c4695726_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));
    p_c4695726_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_BTN));

    p_c4801978_master_stg = new SlmSettings();
    p_c4801978_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c4801978_master_stg->add(MASTER_SETTINGS::CAN_STATUS_OPEN_TRUNK_CMD,                                     "1");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                       "0");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                  "0");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "0");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                            "15");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "15");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                       "1");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                           "0");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                            "0");
    p_c4801978_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");

    p_c4801979_master_stg = new SlmSettings(*p_c4801978_master_stg);
    p_c4801979_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "1");
    p_c4801979_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));

    p_c4801981_master_stg = new SlmSettings(*p_c4801978_master_stg);
    p_c4801981_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));

    p_c4828410_master_stg = new SlmSettings(*p_c4801978_master_stg);
    p_c4828410_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "1");

    p_c4828414_master_stg = new SlmSettings(*p_c4801978_master_stg);
    p_c4828414_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                   "1");
    p_c4828414_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                        "20");
    p_c4828414_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,               "20");

    p_c4559732_master_stg = new SlmSettings();
    p_c4559732_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                         StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NC));
    p_c4559732_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                      "0");

    p_c4559733_master_stg = new SlmSettings(*p_c4559732_master_stg);
    p_c4559733_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "1");
    p_c4559733_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                      "0");
    p_c4559733_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                      "6");

    p_c4559734_master_stg = new SlmSettings();
    p_c4559734_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                         StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c4559734_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));

    p_c4559735_master_stg = new SlmSettings(*p_c4559734_master_stg);
    p_c4559735_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                   StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_IGN_ON));

    p_c4360828_master_stg = new SlmSettings();
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            StringConverter<int32_t>::toString(GUARD_AHJ_NONE));
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "5");
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "5");
    p_c4360828_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                        "1");

    p_c4360832_master_stg = new SlmSettings(*p_c4360828_master_stg);
    p_c4360832_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c4360836_master_stg = new SlmSettings(*p_c4360828_master_stg);
    p_c4360836_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));

    p_c4360840_master_stg = new SlmSettings(*p_c4360828_master_stg);
    p_c4360840_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG | GUARD_AHJ_KEYRING));

    p_c9257883_master_stg = new SlmSettings();
    p_c9257883_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "15");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                       "15");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                           "5");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                            "5");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_BTN));
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                   "1");

    p_c9257887_master_stg = new SlmSettings(*p_c9257883_master_stg);
    p_c9257887_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                   "1");

    p_c9257888_master_stg = new SlmSettings(*p_c9257883_master_stg);
    p_c9257888_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                   "60");
    p_c9257888_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                       "0");
    p_c9257888_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                        "0");

    p_c9257889_master_stg = new SlmSettings(*p_c9257883_master_stg);
    p_c9257889_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,               "60");
    p_c9257889_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                   "1");

    p_c9257890_master_stg = new SlmSettings(*p_c9257883_master_stg);
    p_c9257890_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                   "60");

    p_c9377438_master_stg = new SlmSettings(*p_c4360828_master_stg);
    p_c9377438_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG | GUARD_AHJ_KEYRING));

    p_c3407086_master_stg = new SlmSettings();
    p_c3407086_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       "0");
    p_c3407086_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                     "1");
    p_c3407086_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                            StringConverter<int32_t>::toString(A96_HF_TAG_DISARM | A96_HF_TAG_ARM));
    p_c3407086_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S,                             "5");
    p_c3407086_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S,                            "10");
    p_c3407086_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c3407087_master_stg = new SlmSettings(*p_c3407086_master_stg);
    p_c3407087_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S,                         "15");
    p_c3407087_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S,                        "5");

    p_c9501311_master_stg = new SlmSettings();
    p_c9501311_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c9501311_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                   "30");
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                         StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NC));
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                      "10");
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                      "1");
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                      "6");
    p_c9501311_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                  "0");
    p_c9501311_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                        "1");

    p_c9501313_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9501313_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                              "1");

    p_c9491969_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491969_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "2");
    p_c9491969_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9491974_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491974_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "3");
    p_c9491974_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "10");

    p_c9491977_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491977_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "3");
    p_c9491977_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "50");

    p_c9491979_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491979_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "3");
    p_c9491979_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "60");

    p_c9491980_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491980_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "3");
    p_c9491980_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "1");

    p_c9491981_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491981_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "60");
    p_c9491981_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9491982_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9491982_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "0");
    p_c9491982_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9501309_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9501309_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "0");
    p_c9501309_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9501310_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9501310_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "10");
    p_c9501310_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "6");

    p_c9501320_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9501320_master_stg->replace(MASTER_SETTINGS::CAN_CAR_NUM,                                               "0000");
    p_c9501320_master_stg->replace(MASTER_SETTINGS::CAN_STATUS_SPEED,                                          "0");
    p_c9501320_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "0");
    p_c9501320_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "0");
    p_c9501320_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9501320_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    p_c9501320_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c9501320_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "3");
    p_c9501320_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "3");

    p_c9501322_master_stg = new SlmSettings(*p_c9501320_master_stg);
    p_c9501322_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                              "1");

    p_c9508185_master_stg = new SlmSettings(*p_c9501320_master_stg);
    p_c9508185_master_stg->replace(MASTER_SETTINGS::CAN_CAR_NUM,                                               "9999");
    p_c9508185_master_stg->replace(MASTER_SETTINGS::CAN_STATUS_SPEED,                                          "1");
    p_c9508185_master_stg->add(MASTER_SETTINGS::CAN_STATUS_BRAKE_PEDAL,                                        "0");

    p_c9508187_master_stg = new SlmSettings(*p_c9508185_master_stg);
    p_c9508187_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                              "1");

    p_c9645313_master_stg = new SlmSettings(*p_c9501320_master_stg);
    p_c9645313_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "1");
    p_c9645313_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9645315_master_stg = new SlmSettings(*p_c9501322_master_stg);
    p_c9645315_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "1");
    p_c9645315_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9645320_master_stg = new SlmSettings(*p_c9508185_master_stg);
    p_c9645320_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "1");
    p_c9645320_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9645322_master_stg = new SlmSettings(*p_c9508187_master_stg);
    p_c9645322_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "1");
    p_c9645322_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");

    p_c9658745_master_stg = new SlmSettings(*p_c9645313_master_stg);
    p_c9658745_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "0");
    p_c9658745_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                     StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c9658745_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));

    p_c9658747_master_stg = new SlmSettings(*p_c9645315_master_stg);
    p_c9658747_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "0");
    p_c9658747_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                     StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c9658747_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));

    p_c9658752_master_stg = new SlmSettings(*p_c9645320_master_stg);
    p_c9658752_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "0");
    p_c9658752_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                     StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c9658752_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));

    p_c9658754_master_stg = new SlmSettings(*p_c9645322_master_stg);
    p_c9658754_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                  "0");
    p_c9658754_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                     StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c9658754_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_ARM_OFF));

    p_c9745928_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c9745928_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745928_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));
    p_c9745928_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "0");
    p_c9745928_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "5");
    p_c9745928_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c9745929_master_stg = new SlmSettings(*p_c9745928_master_stg);
    p_c9745929_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "2");
    p_c9745929_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "6");

    p_c9745930_master_stg = new SlmSettings(*p_c9745928_master_stg);
    p_c9745930_master_stg->replace(MASTER_SETTINGS::CAN_CAR_NUM,                                               "0000");
    p_c9745930_master_stg->replace(MASTER_SETTINGS::CAN_STATUS_SPEED,                                          "0");

    p_c9745931_master_stg = new SlmSettings(*p_c9745930_master_stg);
    p_c9745931_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                  "5");
    p_c9745931_master_stg->replace(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                  "7");

    p_c4930044_master_stg = new SlmSettings();
    p_c4930044_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4930044_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_IGN_OFF));
    p_c4930044_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IGN_OFF_VALIDATOR_TOUT_MIN,                      "1");

    p_c4930051_master_stg = new SlmSettings(*p_c4930044_master_stg);
    p_c4930051_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IGN_OFF_VALIDATOR_TOUT_MIN,                  "60");

    p_c9801189_master_stg = new SlmSettings(*p_c4695722_master_stg);
    p_c9801189_master_stg->replace(MASTER_SETTINGS::GEARBOX_BLOCK_EN,                                          "0");

    p_c9801190_master_stg = new SlmSettings(*p_c9801189_master_stg);
    p_c9801190_master_stg->replace(MASTER_SETTINGS::GEARBOX_BLOCK_EN,                                          "1");
    p_c9801190_master_stg->replace(MASTER_SETTINGS::CAN_STATUS_GEAR_P,                                         "0");

    p_c9913925_master_stg = new SlmSettings();
    p_c9913925_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c9913925_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "1");
    p_c9913925_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                            "15");

    p_c9913926_master_stg = new SlmSettings(*p_c9913925_master_stg);
    p_c9913926_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c4363738_master_stg = new SlmSettings();
    p_c4363738_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c4363738_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c4363738_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c4363738_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                        StringConverter<int32_t>::toString(SERVICE_EXIT_COND_MASK_MILEAGE));
    p_c4363738_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                        "100");
    p_c4363738_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                       "20");
    p_c4363738_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        StringConverter<int32_t>::toString(M1_SMS));
    p_c4363738_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c4363739_master_stg = new SlmSettings(*p_c4363738_master_stg);
    p_c4363739_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "500");
    p_c4363739_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "15");
    p_c4363739_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                    StringConverter<int32_t>::toString(SERVICE_EXIT_COND_MASK_SPEED));

    p_c2907769_master_stg = new SlmSettings();
    p_c2907769_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2907769_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_IMMO_BYPASS,                                       "1");
    p_c2907769_master_stg->add(MASTER_SETTINGS::ENG_START_ENABLE,                                              "1");
    p_c2907769_master_stg->add(MASTER_SETTINGS::ENG_START_NEUTRAL_DETECT_TYPE,                                 StringConverter<int32_t>::toString(NEUTRAL_DETECT_TYPE_ARM));
    p_c2907769_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_MANUAL));
    p_c2907769_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));
    p_c2907769_master_stg->add(MASTER_SETTINGS::CAN_PARAM_IMMO_BYPASS_TYPE,                                    StringConverter<int32_t>::toString(ENG_IMMO_BYPASS_CAN_LIN));
    p_c2907769_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_STARTING_CAN,                                 StringConverter<int32_t>::toString(  ARM_STATE
                                                                                                                                                  | WAIT_AUTH_STATE
                                                                                                                                                  | MOVE_FORBID_STATE));
    p_c2907769_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c2907769_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    p_c2907769_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c2907769_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "5");
    p_c2907769_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "5");
    p_c2907769_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c2874561_master_stg = new SlmSettings();
    p_c2874561_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c2874561_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c170801_master_stg = new SlmSettings();
    p_c170801_master_stg->add(MASTER_SETTINGS::CAN_OVL_ONE,                                                    "1");
    p_c170801_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "5272");
    p_c170801_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_OBD_DTC_READ,                                       "1");

    p_c10369958_master_stg = new SlmSettings();
    p_c10369958_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                      StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                      "1");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                 "1");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_DOOR_EN,                                     StringConverter<int32_t>::toString(GUARD_AUTH_SLAVE_DOOR_EN_OFF));
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                  "15");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                      "15");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                          "10");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                           "10");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                          "0");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                       StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                     StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_RUN_TIME_MINUTES,                               "3");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_BYPASS_ON_DELAY_100MS,                              "10");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                           "1");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_FIRST_ON_DELAY_100MS,                     "30");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_ON_DELAY_S,                          "3");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_DURATION_100MS,                      "30");
    p_c10369958_master_stg->add(MASTER_SETTINGS::ENG_START_RPM_CHECK_TIME_S,                                   "3");
    p_c10369958_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c10369962_master_stg = new SlmSettings(*p_c10369958_master_stg);
    p_c10369962_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_DOOR_EN,                                 StringConverter<int32_t>::toString(GUARD_AUTH_SLAVE_DOOR_EN_DOOR_ENG_RUN));

    p_c10369966_master_stg = new SlmSettings(*p_c10369958_master_stg);
    p_c10369966_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_DOOR_EN,                                 StringConverter<int32_t>::toString(GUARD_AUTH_SLAVE_DOOR_EN_DOOR_OR_TRUNK));

    p_c2874875_master_stg = new SlmSettings();
    p_c2874875_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                          StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));
    p_c2874875_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                             StringConverter<int32_t>::toString(AUTH_BTN));

    p_c10288872_master_stg = new SlmSettings();
    p_c10288872_master_stg->add(MASTER_SETTINGS::BUILD_TYPE_TYPE,                                              StringConverter<int32_t>::toString(BUILD_TYPE_BETA));
    p_c10288872_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                        StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NC));

    p_c10419622_master_stg = new SlmSettings();
    p_c10419622_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10419622_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                       StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c10419622_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                     StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));

    p_c10419629_master_stg = new SlmSettings();
    p_c10419629_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10419629_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                  "1");
    p_c10419629_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                     "1");
    p_c10419629_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                      StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10419630_master_stg = new SlmSettings();
    p_c10419630_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10419630_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                         StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));
    p_c10419630_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                            StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10485319_master_stg = new SlmSettings();
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                      StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                  "1");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_OWN_CALL_DIS,                                "1");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                  "15");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                          "0");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                           "0");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                    "1");
    p_c10485319_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                           StringConverter<int32_t>::toString(A96_HF_TAG_DISARM | A96_HF_TAG_ARM));
    p_c10485319_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S,                            "25");
    p_c10485319_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S,                           "25");
    p_c10485319_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c10485321_master_stg = new SlmSettings(*p_c10485319_master_stg);
    p_c10485321_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,              "20");
    p_c10485321_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S,                        "10");
    p_c10485321_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S,                       "10");

    p_c10634826_master_stg = new SlmSettings(*p_c9501311_master_stg);
    p_c10634826_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                           StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING | GUARD_AHJ_SMART_TAG));
    p_c10634826_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                   "5");
    p_c10634826_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                 "5");
    p_c10634826_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                           "3");
    p_c10634826_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                            "3");
    p_c10634826_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c10634826_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY27_PHONE,                                       StringConverter<int32_t>::toString(M1_SMS));

    p_c10861710_master_stg = new SlmSettings();
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                      StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                  "1");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                     "1");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                  "30");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                      "1");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                          "0");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                           "0");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                          "1");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                           "15");
    p_c10861710_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c10861711_master_stg = new SlmSettings(*p_c10861710_master_stg);
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,              "15");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S,                       "30");

    p_c10861712_master_stg = new SlmSettings(*p_c10861710_master_stg);
    p_c10861712_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10861712_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                              "0");

    p_c10861713_master_stg = new SlmSettings(*p_c10861710_master_stg);
    p_c10861713_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10861713_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "0");

    p_c10854614_master_stg = new SlmSettings();
    p_c10854614_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                     StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c10854614_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                       StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c10854614_master_stg->add(MASTER_SETTINGS::ENG_FLAGS_BTN_BLOCK,                                          "1");
    p_c10854614_master_stg->add(MASTER_SETTINGS::ENG_BTN_BLOCK_TIME_100MS,                                     "10");
    p_c10854614_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                       "1");
    p_c10854614_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c10854615_master_stg = new SlmSettings(*p_c10854614_master_stg);
    p_c10854615_master_stg->replace(MASTER_SETTINGS::ENG_BTN_BLOCK_TIME_100MS,                                 "600");

    p_c10854594_master_stg = new SlmSettings(*p_c10854614_master_stg);
    p_c10854594_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10854594_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                             "1");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                      StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                                  "1");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_OWN_CALL_DIS,                                "1");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                  "15");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                      "1");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_BUZZER_WARNING_S,                          "0");
    p_c10854594_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                           "0");

    p_c10854596_master_stg = new SlmSettings(*p_c10854614_master_stg);
    p_c10854596_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10854596_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                             "1");
    p_c10854596_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                            StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10854596_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                         StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_DISARM));

    p_c10854607_master_stg = new SlmSettings(*p_c10854614_master_stg);
    p_c10854607_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10854607_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                             "1");

    p_c10854603_master_stg = new SlmSettings(*p_c10854607_master_stg);
    p_c10854603_master_stg->replace(MASTER_SETTINGS::CAN_STATUS_SPEED,                                         "0");

    p_c10832739_master_stg = new SlmSettings();
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                     "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_LOCK_FACTORY_ARM,                                 "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_CONTROL_UNLOCK_FACTORY_DISARM,                            "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_PARAM_SLAVE_JOINT,                                        "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_DISARM,                                    "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_STATUS_FACTORY_ARM,                                       "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SLAVE_SUPPORT,                                     "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_CAN_EN,                                      "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_AN_SLAVE_EN,                                 "1");
    p_c10832739_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_LOCK_TIME_100MS,                   "50");
    p_c10832739_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_ANALOG_SLAVE_UNLOCK_TIME_100MS,                 "50");
    p_c10832739_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_NEEDED_SLAVE,                                  "1");

    p_c10964449_master_stg = new SlmSettings();
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                        StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO));
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                      StringConverter<int32_t>::toString(ENG_BLOCK_TYPE_NO_AND_IGN_ON));
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                     "0");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                     StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                       StringConverter<int32_t>::toString(ENG_GEARBOX_AUTO));
    p_c10964449_master_stg->add(MASTER_SETTINGS::CAN_PARAM_IMMO_BYPASS_TYPE,                                   StringConverter<int32_t>::toString(ENG_IMMO_BYPASS_ANALOG));
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_IMMO_BYPASS_CTRL_TYPE,                              StringConverter<int32_t>::toString(ENG_IMMO_ALWAYS_WITH_TT));
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_BYPASS_ON_DELAY_100MS,                              "10");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_ACC_ON_DELAY_100MS,                                 "30");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_IGN_ON_DELAY_100MS,                                 "30");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_STARTER_ON_DELAY_S,                                 "3");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_STARTER_ON_MAX_TIME_100MS,                          "50");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_STARTER_OFF_ACC_OFF_DELAY_100MS,                    "30");
    p_c10964449_master_stg->add(MASTER_SETTINGS::ENG_START_IMMO_BYPASS_OFF_DELAY_100MS,                        "60");
    p_c10964449_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c10964450_master_stg = new SlmSettings(*p_c10964449_master_stg);
    p_c10964450_master_stg->replace(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                 StringConverter<int32_t>::toString(ENG_START_START_STOP));
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_RUN_TIME_MINUTES,                               "3");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_BYPASS_ON_DELAY_100MS,                              "10");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_PUSH_NUM,                                           "3");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_FIRST_ON_DELAY_100MS,                     "50");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_ON_DELAY_S,                          "5");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_START_BTN_LAST_DURATION_100MS,                      "50");
    p_c10964450_master_stg->add(MASTER_SETTINGS::ENG_START_RPM_CHECK_TIME_S,                                   "5");

    p_c11110395_master_stg = new SlmSettings();
    p_c11110395_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c11110395_master_stg->add(MASTER_SETTINGS::CAN_PARAM_DISABLE_BUTTONS,                                    "0");

    p_c10634817_master_stg = new SlmSettings();
    p_c10634817_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                  "9999");
    p_c10634817_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                            StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10634817_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_IGN_OFF_VALIDATOR_TOUT_ON,                         StringConverter<int32_t>::toString(GUARD_AUTH_PROFILE_MOVING_IGN_OFF));

    p_c11846848_master_stg = new SlmSettings();
    p_c11846848_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_HANDS_FREE_EN,                                    "1");
    p_c11846848_master_stg->add(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                           StringConverter<int32_t>::toString(A96_HF_TAG_DISARM | A96_HF_TAG_ARM));
    p_c11846848_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S,                            "5");
    p_c11846848_master_stg->add(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S,                           "5");
    p_c11846848_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);

    p_c11946743_master_stg = new SlmSettings();
    p_c11946743_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                  m_shield_phones[SHIELD_PHONE_NO_1]);
}

void AutoTestsModesP2::initM96MasterStg()
{
    initX96MasterStg();
}

void AutoTestsModesP2::initA96MasterStg()
{
    initX96MasterStg();
    
    p_c170821_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                         StringConverter<int32_t>::toString(4));

    p_c168723_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                         StringConverter<int32_t>::toString(4 | 8));
    
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169641_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
                                                                                                             
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169642_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "1");
                                                                                                             
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "1");
    p_c169643_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    
    p_c169644_master_stg = new SlmSettings();
    p_c169644_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169644_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169644_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169644_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169644_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c169644_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c169644_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
    p_c169644_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                         "1");
    
    p_c169645_master_stg = new SlmSettings();
    p_c169645_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169645_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "1");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
    p_c169645_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_BLOCK_S,                                       "5");
    p_c169645_master_stg->add(MASTER_SETTINGS::GUARD_ZONE_MASKING_SENSORS_MASK_TIME_S,                         "1");
    
    p_c169648_master_stg = new SlmSettings();
    p_c169648_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169648_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169648_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169648_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169648_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "1");
    p_c169648_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c169648_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
    
    p_c169656_master_stg = new SlmSettings();
    p_c169656_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169656_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169656_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "1");
    p_c169656_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                       "0");
    p_c169656_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c169656_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "0");
    p_c169656_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
    
    p_c1578122_master_stg = new SlmSettings();
    p_c1578122_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1578122_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c1578122_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                         "1");
    p_c1578122_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_RUNNING,                                      "0");
    p_c1578122_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                  "0");
    p_c1578122_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                   "0");
    p_c1578122_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                      "60");
    
    p_c169657_master_stg = new SlmSettings();
    p_c169657_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169657_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169657_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "0");
    p_c169657_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                        "0");
    p_c169657_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c169657_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
                                                                                                             
    p_c169659_master_stg = new SlmSettings();                                                                  
    p_c169659_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                    "9999");
    p_c169659_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                               "1");
    p_c169659_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                          "0");
    p_c169659_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                        "1");
    p_c169659_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");
    p_c169659_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                       "0");
                                                                                                             
    p_c1578123_master_stg = new SlmSettings();                                                                 
    p_c1578123_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c1578123_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c1578123_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_TYPE,                                         "0");
    p_c1578123_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_IGN_ON,                                       "1");
    p_c1578123_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                  "0");
    p_c1578123_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S,                                      "60");
    
    p_c169639_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_CAN,                                           "1");
    
    p_c169640_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_STARTING_CAN,                                  "1");
    
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            "1");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "10");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "5");
    p_c1624514_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "5");
    
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_TAG_REM_WAIT_S,                   "15");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SECONDARY_VLD_WAIT_S,                       "1");
    p_c1624518_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_IMMO_SIREN_WARNING_S,                            "1");

    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_CAN,                                           "1");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c172480_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "0");

    p_c172498_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_CAN,                                           "1");
    p_c172498_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_SPEED_KMPH,                                    "30");
    p_c172498_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_BRAKE_PEDAL,                                   "1");

    p_c172473_master_stg->add(MASTER_SETTINGS::ENG_BLOCK_COMMON_STARTING_CAN,                                  "1");

    p_c1981106_master_stg = new SlmSettings();
    p_c1981106_master_stg->add(MASTER_SETTINGS::MERGE_CHANNELS,                                                "1");
    p_c1981106_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "0");

    p_c1981107_master_stg = new SlmSettings();
    p_c1981107_master_stg->add(MASTER_SETTINGS::MERGE_CHANNELS,                                                "0");
    p_c1981107_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "0");

    p_c1981112_master_stg = new SlmSettings();
    p_c1981112_master_stg->add(MASTER_SETTINGS::MERGE_CHANNELS,                                                "2"); 
    p_c1981112_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "0");

    p_c1981115_master_stg = new SlmSettings();
    p_c1981115_master_stg->add(MASTER_SETTINGS::MERGE_CHANNELS,                                                "3");
    p_c1981115_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                           "0");

    p_c1981121_master_stg = new SlmSettings(*p_c1981106_master_stg);
    p_c1981121_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "1"); 

    p_c1981125_master_stg = new SlmSettings(*p_c1981112_master_stg);
    p_c1981125_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "1"); 

    p_c1981136_master_stg = new SlmSettings(*p_c1981115_master_stg);
    p_c1981136_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED,                       "1"); 

    p_c168695_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                         StringConverter<int32_t>::toString(1 | 4));

    p_c168696_master_stg->replace(MASTER_SETTINGS::HANDS_FREE_PROFILE,                                         StringConverter<int32_t>::toString(2 | 8));
    
    p_c2424871_master_stg = new SlmSettings();
    p_c2424871_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2424871_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c2424871_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG | AUTH_REMOTE));
    p_c2424871_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                        "3");
    p_c2424871_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                        "500");
    p_c2424871_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                       "20");
    
    p_c2424871_2_master_stg = new SlmSettings(*p_c2424871_master_stg);
    p_c2424871_2_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                  "0");
    
    p_c2424873_master_stg = new SlmSettings();
    p_c2424873_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2424873_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c2424873_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                       StringConverter<int32_t>::toString(AUTH_SMART_TAG | AUTH_REMOTE));
    p_c2424873_master_stg->add(MASTER_SETTINGS::GSM_OWNER_ACCESS_PHONE_MAIN,                                   m_shield_phones[SHIELD_PHONE_NO_1]);
    p_c2424873_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                        "1");
    p_c2424873_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                        "500");
    p_c2424873_master_stg->add(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                       "20");
    
    p_c2424875_master_stg = new SlmSettings(*p_c2424873_master_stg);
    p_c2424875_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "100");
    p_c2424875_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "2");
    
    p_c2424876_master_stg = new SlmSettings(*p_c2424873_master_stg);
    p_c2424876_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "5000");
    p_c2424876_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "0");
    
    p_c2438277_master_stg = new SlmSettings(*p_c2424873_master_stg);
    p_c2438277_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "2");
    
    p_c2424877_master_stg = new SlmSettings(*p_c2424873_master_stg);
    p_c2424877_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                    "2");
    p_c2424877_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "50");
    
    p_c2424878_master_stg = new SlmSettings(*p_c2424877_master_stg);
    p_c2424878_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "20");
    
    p_c2424879_master_stg = new SlmSettings(*p_c2424877_master_stg);
    p_c2424879_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "15");
    p_c2424879_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "2");
    
    p_c2424880_master_stg = new SlmSettings(*p_c2424877_master_stg);
    p_c2424880_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "80");
    p_c2424880_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "0");
        
    p_c2424881_master_stg = new SlmSettings(*p_c2424877_master_stg);
    p_c2424881_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "20");
    p_c2424881_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "2");
        
    p_c2424882_master_stg = new SlmSettings(*p_c2424873_master_stg);
    p_c2424882_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_COND_MASK,                                    "3");
    
    p_c2424883_master_stg = new SlmSettings(*p_c2424882_master_stg);
    p_c2424883_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "100");
    p_c2424883_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "60");
    p_c2424883_master_stg->add(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                        "2");
    
    p_c2424884_master_stg = new SlmSettings(*p_c2424883_master_stg);
    p_c2424884_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "5000");
    p_c2424884_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "80");
    p_c2424884_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "0");
    
    p_c2424885_master_stg = new SlmSettings(*p_c2424884_master_stg);
    p_c2424885_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "15");
    p_c2424885_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "2");
    
    p_c2424886_master_stg = new SlmSettings(*p_c2424884_master_stg);
    p_c2424886_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "80");
    p_c2424886_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "0");
    
    p_c2424887_master_stg = new SlmSettings(*p_c2424884_master_stg);
    p_c2424887_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "20");
    p_c2424887_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "2");
    
    p_c2424888_master_stg = new SlmSettings(*p_c2424884_master_stg);
    p_c2424888_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_MILEAGE_M,                                    "100");
    p_c2424888_master_stg->replace(MASTER_SETTINGS::SERVICE_EXIT_SPEED_KMPH,                                   "15");
    p_c2424888_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "2");
    
    p_c2424889_master_stg = new SlmSettings(*p_c2424888_master_stg);
    p_c2424889_master_stg->replace(MASTER_SETTINGS::ALARM_PROPERTY25_PHONE,                                    "0");

    p_c2198656_master_stg = new SlmSettings();
    p_c2198656_master_stg->add(MASTER_SETTINGS::CAN_CAR_NUM,                                                   "9999");
    p_c2198656_master_stg->add(MASTER_SETTINGS::CAN_STATUS_IGNITION,                                           "1");
    p_c2198656_master_stg->add(MASTER_SETTINGS::CAN_STATUS_SPEED,                                              "1");
    p_c2198656_master_stg->add(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                            "2");
    p_c2198656_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_PAUSE_2S,                                    "5");
    p_c2198656_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_WAIT_TAG_S,                                  "5");
    p_c2198656_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_BUZZER_WARNING_S,                            "5");
    p_c2198656_master_stg->add(MASTER_SETTINGS::GUARD_TIMINGS_AHJ_SIREN_WARNING_S,                             "5");

    p_c2198680_master_stg = new SlmSettings(*p_c2198656_master_stg);
    p_c2198680_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        "0");

    p_c2198684_master_stg = new SlmSettings(*p_c2198656_master_stg);
    p_c2198684_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        "1");

    p_c2198685_master_stg = new SlmSettings(*p_c2198656_master_stg);
    p_c2198685_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        "5");

    p_c3752984_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c3752985_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c3752986_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c3752987_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        p_c4559714_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                               StringConverter<int32_t>::toString(AUTH_REMOTE));
    }

    p_c3357809_master_stg = new SlmSettings(*p_c2198656_master_stg);
    p_c3357809_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c3357809_master_stg->add(MASTER_SETTINGS::ENG_START_GEARBOX_TYPE,                                        StringConverter<int32_t>::toString(ENG_GEARBOX_MANUAL));
    p_c3357809_master_stg->add(MASTER_SETTINGS::ENG_START_ENG_START_TYPE,                                      StringConverter<int32_t>::toString(ENG_START_IGN_LOCK));
    p_c3357809_master_stg->add(MASTER_SETTINGS::ENG_START_IGN_SUPP_TYPE,                                       StringConverter<int32_t>::toString(IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING));
    p_c3357809_master_stg->add(MASTER_SETTINGS::RPM_TRUE_RPM_EN,                                               "0");
    p_c3357809_master_stg->add(MASTER_SETTINGS::ENG_START_TT_TIME_MINUTES,                                     "1");

    p_c3357810_master_stg = new SlmSettings(*p_c3357809_master_stg);
    p_c3357810_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));

    p_c9501320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9501322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9508185_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9508187_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9645313_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9645315_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9645320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9645322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9658745_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9658747_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9658752_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));
    p_c9658754_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));

    p_c9745928_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_BTN));
    p_c9745929_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_BTN));
    p_c9745930_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_BTN));
    p_c9745931_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_BTN));

    p_c4363738_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c4363739_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE));

    p_c2907769_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));

    p_c10369958_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10369962_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10369966_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10419629_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_BTN));

    p_c10419630_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));

    p_c10634826_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                       StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));
    p_c10854594_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "0");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "0");

    p_c10854596_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));
    p_c10634817_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));
}

void AutoTestsModesP2::initE96MasterStg()
{
    initA96MasterStg();

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        p_c3752984_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                               StringConverter<int32_t>::toString(AUTH_SMART_TAG));
        p_c3752985_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                               StringConverter<int32_t>::toString(AUTH_SMART_TAG));
        p_c3752986_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                               StringConverter<int32_t>::toString(AUTH_SMART_TAG));
        p_c3752987_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                               StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    }

    p_c4559714_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4686621_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG | GUARD_AHJ_KEYRING));
    p_c9501320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9501322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508185_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508187_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645313_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645315_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658745_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658747_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658752_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658754_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c9745928_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745929_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745930_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745931_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c4363738_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c4363739_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));

    p_c2874561_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c2907769_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c10369958_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369962_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369966_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10419629_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10419630_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10634826_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                       StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING | GUARD_AHJ_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c10854594_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");

    p_c10854596_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10634817_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));
}

void AutoTestsModesP2::initS96MasterStg()
{
    initA96MasterStg();

    p_c3752984_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752985_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752986_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752987_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4559714_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4686621_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c9257883_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                               "0");
    p_c9257883_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");

    p_c9257887_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                               "0");
    p_c9257887_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");

    p_c9257888_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                               "0");
    p_c9257888_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");

    p_c9257889_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                               "0");
    p_c9257889_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");

    p_c9257890_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                               "0");
    p_c9257890_master_stg->add(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                      "1");

    p_c9501320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9501322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508185_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508187_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645313_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645315_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658745_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658747_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658752_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658754_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c9745928_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745929_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745930_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745931_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4363738_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4363739_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c2874561_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c2907769_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c10369958_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369962_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369966_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10419629_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_BTN));

    p_c10419630_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));

    p_c10634826_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                       StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10854594_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                              "0");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_REMOTE_DIS,                              "0");

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");

    p_c10854596_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));
    p_c10634817_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_BTN));
}

void AutoTestsModesP2::initX96v2MasterStg()
{
    initA96MasterStg();

    p_c3752984_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752985_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752986_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c3752987_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4559714_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c4686621_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG | GUARD_AHJ_KEYRING));
    p_c9501320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9501322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508185_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9508187_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645313_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645315_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645320_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9645322_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658745_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658747_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658752_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c9658754_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c9745928_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745929_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745930_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c9745931_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                         StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c4363738_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c4363739_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                   StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));

    p_c2874561_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));
    p_c2907769_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                        StringConverter<int32_t>::toString(GUARD_AHJ_SMART_TAG));

    p_c10369958_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369962_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10369966_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10419629_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10419630_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10634826_master_stg->replace(MASTER_SETTINGS::GUARD_FLAGS_AHJ_EN,                                       StringConverter<int32_t>::toString(GUARD_AHJ_KEYRING | GUARD_AHJ_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_REMOTE | AUTH_SMART_TAG));
    p_c10854594_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_IMMO,                                  StringConverter<int32_t>::toString(AUTH_SMART_TAG));

    p_c10861710_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");
    p_c10861711_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_SLAVE_TAG_DIS,                                 "1");

    p_c10854596_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));
    p_c10634817_master_stg->replace(MASTER_SETTINGS::GUARD_AUTH_PROFILE_MOVING_ALLOWED,                        StringConverter<int32_t>::toString(AUTH_SMART_TAG));
}

void AutoTestsModesP2::initX96Settings()
{
    initX96Wires();
    initX96MasterStg();

    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_x96);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_x96);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_can_slave_func_x96);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_analog_slave_func_x96);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_analog_slave_func_x96);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_analog_slave_func_x96);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_x96);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_x96);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_x96);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_x96);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_x96);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_x96);
    p_c170781                                  = new GEN6_AT_OPTIONS(p_c170781_master_stg,                        p_cap_sensor_func_x96);
    p_c170782                                  = new GEN6_AT_OPTIONS(p_c170782_master_stg,                        p_cap_sensor_func_x96);
    p_c170792                                  = new GEN6_AT_OPTIONS(p_c170792_master_stg,                        p_cap_sensor_func_x96);
    p_c170799                                  = new GEN6_AT_OPTIONS(p_c170799_master_stg,                        p_cap_sensor_func_x96);
    p_c170800                                  = new GEN6_AT_OPTIONS(p_c170800_master_stg,                        p_cap_sensor_func_x96);
    p_c170808                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_ppp_func_x96);
    p_c170821                                  = new GEN6_AT_OPTIONS(p_c170821_master_stg,                        p_cap_sensor_func_x96);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_cap_can_slave_func_x96);
    
    p_c169641                                  = new GEN6_AT_OPTIONS(p_c169641_master_stg,                        p_cap_sensor_func_x96);
    p_c169642                                  = new GEN6_AT_OPTIONS(p_c169642_master_stg,                        p_cap_sensor_func_x96);
    p_c169643                                  = new GEN6_AT_OPTIONS(p_c169643_master_stg,                        p_cap_sensor_func_x96);
    p_c169639                                  = new GEN6_AT_OPTIONS(p_c169639_master_stg,                        p_cap_sensor_func_x96);
    p_c169640                                  = new GEN6_AT_OPTIONS(p_c169640_master_stg,                        p_cap_sensor_func_x96);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_x96);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_x96);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_x96);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_x96);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_x96);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_x96);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_x96);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_can_slave_func_x96);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_can_slave_func_x96);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_can_slave_func_x96);

    p_c2043655                                 = new GEN6_AT_OPTIONS(p_c2043655_master_stg,                       p_cap_sensor_func_x96);
    p_c2043657                                 = new GEN6_AT_OPTIONS(p_c2043657_master_stg,                       p_cap_sensor_func_x96);
    p_c2043659                                 = new GEN6_AT_OPTIONS(p_c2043659_master_stg,                       p_analog_can_slave_func_x96);
    p_c2043661                                 = new GEN6_AT_OPTIONS(p_c2043661_master_stg,                       p_analog_can_slave_func_x96);
    p_c2405376                                 = new GEN6_AT_OPTIONS(p_c2405376_master_stg,                       p_cap_sensor_func_x96);
}

void AutoTestsModesP2::initM96Settings()
{
    initM96Wires();
    initM96MasterStg();
    
    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_m96);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_m96);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_sensor_func_m96);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_sensor_func_m96);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_sensor_func_m96);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_sensor_func_m96);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_m96);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_m96);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_m96);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_m96);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_m96);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_m96);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_rearm_breake_func_m96);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_m96);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_m96);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_m96);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_m96);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_m96);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_m96);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_m96);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_sensor_func_m96);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_sensor_func_m96);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_sensor_func_m96);
}

void AutoTestsModesP2::initA96Settings()
{
    initA96Wires();
    initA96MasterStg();
    
    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_a96);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_a96);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_can_slave_func_a96);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_analog_slave_func_a96);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_analog_slave_func_a96);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_analog_slave_func_a96);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_a96);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_a96);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_a96);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_a96);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_a96);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_a96);
    p_c170781                                  = new GEN6_AT_OPTIONS(p_c170781_master_stg,                        p_cap_sensor_func_a96);
    p_c170782                                  = new GEN6_AT_OPTIONS(p_c170782_master_stg,                        p_cap_sensor_func_a96);
    p_c170792                                  = new GEN6_AT_OPTIONS(p_c170792_master_stg,                        p_cap_sensor_func_a96);
    p_c170799                                  = new GEN6_AT_OPTIONS(p_c170799_master_stg,                        p_cap_sensor_func_a96);
    p_c170800                                  = new GEN6_AT_OPTIONS(p_c170800_master_stg,                        p_cap_sensor_func_a96);
    p_c170808                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_ppp_func_a96);
    p_c170821                                  = new GEN6_AT_OPTIONS(p_c170821_master_stg,                        p_cap_sensor_func_a96);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_ppp_func_a96);

    p_c169641                                  = new GEN6_AT_OPTIONS(p_c169641_master_stg,                        p_cap_sensor_func_a96);
    p_c169642                                  = new GEN6_AT_OPTIONS(p_c169642_master_stg,                        p_cap_sensor_func_a96);
    p_c169643                                  = new GEN6_AT_OPTIONS(p_c169643_master_stg,                        p_cap_sensor_func_a96);
    p_c169644                                  = new GEN6_AT_OPTIONS(p_c169644_master_stg,                        p_cap_sensor_func_a96);
    p_c169645                                  = new GEN6_AT_OPTIONS(p_c169645_master_stg,                        p_cap_sensor_func_a96);
    p_c169648                                  = new GEN6_AT_OPTIONS(p_c169648_master_stg,                        p_cap_sensor_func_a96);
    p_c169656                                  = new GEN6_AT_OPTIONS(p_c169656_master_stg,                        p_cap_sensor_func_a96);
    p_c1578122                                 = new GEN6_AT_OPTIONS(p_c1578122_master_stg,                       p_cap_sensor_func_a96);
                                                                                                                  
    p_c169657                                  = new GEN6_AT_OPTIONS(p_c169657_master_stg,                        p_cap_sensor_func_a96);
    p_c169659                                  = new GEN6_AT_OPTIONS(p_c169659_master_stg,                        p_cap_sensor_func_a96);
    p_c1578123                                 = new GEN6_AT_OPTIONS(p_c1578123_master_stg,                       p_cap_sensor_func_a96);
    p_c169639                                  = new GEN6_AT_OPTIONS(p_c169639_master_stg,                        p_cap_sensor_func_a96);
    p_c169640                                  = new GEN6_AT_OPTIONS(p_c169640_master_stg,                        p_cap_sensor_func_a96);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_a96);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_a96);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_a96);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_a96);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_a96);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_a96);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_a96);

    p_c1827097                                 = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_c1827097_func_a96);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_can_slave_func_a96);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_can_slave_func_a96);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_can_slave_func_a96);

    p_c2043655                                 = new GEN6_AT_OPTIONS(p_c2043655_master_stg,                       p_ppp_func_a96);
    p_c2043657                                 = new GEN6_AT_OPTIONS(p_c2043657_master_stg,                       p_ppp_func_a96);
    p_c2043659                                 = new GEN6_AT_OPTIONS(p_c2043659_master_stg,                       p_analog_can_slave_func_a96);
    p_c2043661                                 = new GEN6_AT_OPTIONS(p_c2043661_master_stg,                       p_analog_can_slave_func_a96);

    p_c1981106                                 = new GEN6_AT_OPTIONS(p_c1981106_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981107                                 = new GEN6_AT_OPTIONS(p_c1981107_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981112                                 = new GEN6_AT_OPTIONS(p_c1981112_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981115                                 = new GEN6_AT_OPTIONS(p_c1981115_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981121                                 = new GEN6_AT_OPTIONS(p_c1981121_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981125                                 = new GEN6_AT_OPTIONS(p_c1981125_master_stg,                       p_cap_can_slave_func_a96);
    p_c1981136                                 = new GEN6_AT_OPTIONS(p_c1981136_master_stg,                       p_cap_can_slave_func_a96);

    p_c2405376                                 = new GEN6_AT_OPTIONS(p_c2405376_master_stg,                       p_cap_sensor_func_a96);
    
    p_c2405378                                 = new GEN6_AT_OPTIONS(p_c2405378_master_stg,                       p_cap_sensor_func_a96);
    p_c2405379                                 = new GEN6_AT_OPTIONS(p_c2405379_master_stg,                       p_cap_sensor_func_a96);
    
    p_c2424871                                 = new GEN6_AT_OPTIONS(p_c2424871_master_stg,                       p_cap_sensor_func_a96);
    p_c2424871_2                               = new GEN6_AT_OPTIONS(p_c2424871_2_master_stg,                     p_cap_sensor_func_a96);
    p_c2424873                                 = new GEN6_AT_OPTIONS(p_c2424873_master_stg,                       p_cap_sensor_func_a96);
    p_c2424875                                 = new GEN6_AT_OPTIONS(p_c2424875_master_stg,                       p_cap_sensor_func_a96);
    p_c2424876                                 = new GEN6_AT_OPTIONS(p_c2424876_master_stg,                       p_cap_sensor_func_a96);
    p_c2438277                                 = new GEN6_AT_OPTIONS(p_c2438277_master_stg,                       p_cap_sensor_func_a96);
    p_c2424877                                 = new GEN6_AT_OPTIONS(p_c2424877_master_stg,                       p_cap_sensor_func_a96);
    p_c2424878                                 = new GEN6_AT_OPTIONS(p_c2424878_master_stg,                       p_cap_sensor_func_a96);
    p_c2424879                                 = new GEN6_AT_OPTIONS(p_c2424879_master_stg,                       p_cap_sensor_func_a96);
    p_c2424880                                 = new GEN6_AT_OPTIONS(p_c2424880_master_stg,                       p_cap_sensor_func_a96);
    p_c2424881                                 = new GEN6_AT_OPTIONS(p_c2424881_master_stg,                       p_cap_sensor_func_a96);
    p_c2424882                                 = new GEN6_AT_OPTIONS(p_c2424882_master_stg,                       p_cap_sensor_func_a96);
    p_c2424883                                 = new GEN6_AT_OPTIONS(p_c2424883_master_stg,                       p_cap_sensor_func_a96);
    p_c2424884                                 = new GEN6_AT_OPTIONS(p_c2424884_master_stg,                       p_cap_sensor_func_a96);
    p_c2424885                                 = new GEN6_AT_OPTIONS(p_c2424885_master_stg,                       p_cap_sensor_func_a96);
    p_c2424886                                 = new GEN6_AT_OPTIONS(p_c2424886_master_stg,                       p_cap_sensor_func_a96);
    p_c2424887                                 = new GEN6_AT_OPTIONS(p_c2424887_master_stg,                       p_cap_sensor_func_a96);
    p_c2424888                                 = new GEN6_AT_OPTIONS(p_c2424888_master_stg,                       p_cap_sensor_func_a96);
    p_c2424889                                 = new GEN6_AT_OPTIONS(p_c2424889_master_stg,                       p_cap_sensor_func_a96);

    p_c2728677                                 = new GEN6_AT_OPTIONS(p_c2728677_master_stg,                       p_cap_sensor_func_a96);
    p_c2728678                                 = new GEN6_AT_OPTIONS(p_c2728678_master_stg,                       p_cap_sensor_func_a96);
    p_c2728679                                 = new GEN6_AT_OPTIONS(p_c2728679_master_stg,                       p_cap_sensor_func_a96);
    p_c2728682                                 = new GEN6_AT_OPTIONS(p_c2728682_master_stg,                       p_cap_sensor_func_a96);
    p_c2728683                                 = new GEN6_AT_OPTIONS(p_c2728683_master_stg,                       p_cap_sensor_func_a96);
    p_c2728684                                 = new GEN6_AT_OPTIONS(p_c2728684_master_stg,                       p_cap_sensor_func_a96);

    p_c172464                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_can_slave_func_a96);
    p_c1662256                                 = new GEN6_AT_OPTIONS(p_c1662256_master_stg,                       p_hood_analog_slave_func_a96);
    p_c1662261                                 = new GEN6_AT_OPTIONS(p_c1662261_master_stg,                       p_cap_can_slave_func_a96);
    p_c169588                                  = new GEN6_AT_OPTIONS(p_c169588_master_stg,                        p_cap_sensor_func_a96);
    p_c2198656                                 = new GEN6_AT_OPTIONS(p_c2198656_master_stg,                       p_c2198656_func_a96);
    p_c2198680                                 = new GEN6_AT_OPTIONS(p_c2198680_master_stg,                       p_c2198656_func_a96);
    p_c2198684                                 = new GEN6_AT_OPTIONS(p_c2198684_master_stg,                       p_c2198656_func_a96);
    p_c2198685                                 = new GEN6_AT_OPTIONS(p_c2198685_master_stg,                       p_c2198656_func_a96);
    p_c169591                                  = new GEN6_AT_OPTIONS(p_c169591_master_stg,                        p_cap_sensor_func_a96);
    p_c169592                                  = new GEN6_AT_OPTIONS(p_c169592_master_stg,                        p_cap_sensor_func_a96);
    p_c169593                                  = new GEN6_AT_OPTIONS(p_c169593_master_stg,                        p_cap_sensor_func_a96);
    p_c169594                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_sensor_func_a96);
    p_c2889927                                 = new GEN6_AT_OPTIONS(p_c2889927_master_stg,                       p_cap_can_slave_func_a96);
    p_c2889927_no_hf                           = new GEN6_AT_OPTIONS(p_c2889927_no_hf_master_stg,                 p_cap_can_slave_func_a96);
    p_c3052203                                 = new GEN6_AT_OPTIONS(p_c3052203_master_stg,                       p_cap_can_slave_func_a96);
    p_c3052206                                 = new GEN6_AT_OPTIONS(p_c3052206_master_stg,                       p_cap_can_slave_func_a96);
    p_c2799849                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_no_siren_func_a96);
    p_c2799850                                 = new GEN6_AT_OPTIONS(p_c2799850_master_stg,                       p_cap_can_slave_func_a96);
    p_c2799851                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_cap_can_slave_func_a96);
    p_c3202904                                 = new GEN6_AT_OPTIONS(p_c3202904_master_stg,                       p_hood_analog_slave_func_a96);
    p_c2799852                                 = new GEN6_AT_OPTIONS(p_c2799852_master_stg,                       p_c2799852_func_a96);
    p_c2799853                                 = new GEN6_AT_OPTIONS(p_c2799853_master_stg,                       p_c2799852_func_a96);
    p_c2799854                                 = new GEN6_AT_OPTIONS(p_c2799854_master_stg,                       p_c2799852_func_a96);
    p_c20461                                   = new GEN6_AT_OPTIONS(p_c20461_master_stg,                         p_hood_analog_slave_func_a96);
    p_c20462                                   = new GEN6_AT_OPTIONS(p_c20462_master_stg,                         p_hood_analog_slave_func_a96);
    p_c20463                                   = new GEN6_AT_OPTIONS(p_c20463_master_stg,                         p_hood_analog_slave_func_a96);
    p_auth_no_tag_needed                       = new GEN6_AT_OPTIONS(p_auth_no_tag_needed_master_stg,             p_hood_analog_slave_func_a96);
    p_c3752984                                 = new GEN6_AT_OPTIONS(p_c3752984_master_stg,                       p_c2799852_func_a96);
    p_c3752985                                 = new GEN6_AT_OPTIONS(p_c3752985_master_stg,                       p_c2799852_func_a96);
    p_c3752986                                 = new GEN6_AT_OPTIONS(p_c3752986_master_stg,                       p_c2799852_func_a96);
    p_c3752987                                 = new GEN6_AT_OPTIONS(p_c3752987_master_stg,                       p_c2799852_func_a96);
    p_c3136858                                 = new GEN6_AT_OPTIONS(p_c3136858_master_stg,                       p_c2799852_func_a96);
    p_c3688077                                 = new GEN6_AT_OPTIONS(p_c3688077_master_stg,                       p_cap_sensor_func_a96);
    p_no_rearm                                 = new GEN6_AT_OPTIONS(p_no_rearm_master_stg,                       p_cap_sensor_func_a96);
    p_c3697245                                 = new GEN6_AT_OPTIONS(p_c3697245_master_stg,                       p_c3688075_func_a96);
    p_c3688075                                 = new GEN6_AT_OPTIONS(p_c3688075_master_stg,                       p_c3688075_func_a96);
    p_c3688076                                 = new GEN6_AT_OPTIONS(p_c3688076_master_stg,                       p_cap_can_slave_func_a96);
    p_no_auth                                  = new GEN6_AT_OPTIONS(p_no_auth_master_stg,                        p_c2799852_func_a96);
    p_c3136863                                 = new GEN6_AT_OPTIONS(p_c3136863_master_stg,                       p_c2799852_func_a96);
    p_c3136864                                 = new GEN6_AT_OPTIONS(p_c3136864_master_stg,                       p_c2799852_func_a96);
    p_c170806                                  = new GEN6_AT_OPTIONS(p_c170806_master_stg,                        p_cap_sensor_func_a96);
    p_c187473                                  = new GEN6_AT_OPTIONS(p_c187473_master_stg,                        p_cap_sensor_func_a96);
    p_c187475                                  = new GEN6_AT_OPTIONS(p_c187475_master_stg,                        p_cap_sensor_func_a96);
    p_c187457                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_cap_sensor_func_a96);
    p_c187458                                  = new GEN6_AT_OPTIONS(p_c187458_master_stg,                        p_cap_sensor_func_a96);
    p_c187459                                  = new GEN6_AT_OPTIONS(p_c187459_master_stg,                        p_cap_sensor_func_a96);
    p_c187462                                  = new GEN6_AT_OPTIONS(p_c187462_master_stg,                        p_cap_sensor_func_a96);
    p_c187463                                  = new GEN6_AT_OPTIONS(p_c187463_master_stg,                        p_cap_sensor_func_a96);
    p_c187464                                  = new GEN6_AT_OPTIONS(p_c187464_master_stg,                        p_cap_sensor_func_a96);
    p_c187471                                  = new GEN6_AT_OPTIONS(p_c187471_master_stg,                        p_cap_sensor_func_a96);
    p_c187478                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_c187478_func_a96);
    p_c4045282                                 = new GEN6_AT_OPTIONS(p_c4045282_master_stg,                       p_cap_sensor_func_a96);
    p_c4045283                                 = new GEN6_AT_OPTIONS(p_c4045283_master_stg,                       p_cap_sensor_func_a96);
    p_c4045286                                 = new GEN6_AT_OPTIONS(p_c4045286_master_stg,                       p_cap_sensor_func_a96);
    p_c4045290                                 = new GEN6_AT_OPTIONS(p_c4045290_master_stg,                       p_cap_sensor_func_a96);
    p_c4045291                                 = new GEN6_AT_OPTIONS(p_c4045291_master_stg,                       p_cap_sensor_func_a96);
    p_c4045294                                 = new GEN6_AT_OPTIONS(p_c4045294_master_stg,                       p_cap_sensor_func_a96);
    p_c2898585                                 = new GEN6_AT_OPTIONS(p_c2898585_master_stg,                       p_cap_can_slave_func_a96);
    p_c170805                                  = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_start_1_1_func_a96);
    p_c4559714                                 = new GEN6_AT_OPTIONS(p_c4559714_master_stg,                       p_c4559714_func_a96);
    p_can_ovl_one_dis                          = new GEN6_AT_OPTIONS(p_can_ovl_one_dis_master_stg,                p_analog_can_slave_func_a96);
    p_c4695722                                 = new GEN6_AT_OPTIONS(p_c4695722_master_stg,                       p_analog_can_slave_func_a96);
    p_c4686621                                 = new GEN6_AT_OPTIONS(p_c4686621_master_stg,                       p_analog_can_slave_func_a96);
    p_c4695725                                 = new GEN6_AT_OPTIONS(p_c4695725_master_stg,                       p_analog_can_slave_func_a96);
    p_c4695726                                 = new GEN6_AT_OPTIONS(p_c4695726_master_stg,                       p_analog_can_slave_func_a96);
    p_c4801978                                 = new GEN6_AT_OPTIONS(p_c4801978_master_stg,                       p_analog_can_slave_func_a96);
    p_c4801979                                 = new GEN6_AT_OPTIONS(p_c4801979_master_stg,                       p_analog_can_slave_func_a96);
    p_c4801981                                 = new GEN6_AT_OPTIONS(p_c4801981_master_stg,                       p_analog_can_slave_func_a96);
    p_c4828410                                 = new GEN6_AT_OPTIONS(p_c4828410_master_stg,                       p_analog_can_slave_func_a96);
    p_c4828414                                 = new GEN6_AT_OPTIONS(p_c4828414_master_stg,                       p_analog_can_slave_func_a96);
    p_c4559732                                 = new GEN6_AT_OPTIONS(p_c4559732_master_stg,                       p_analog_can_slave_func_a96);
    p_c4559733                                 = new GEN6_AT_OPTIONS(p_c4559733_master_stg,                       p_analog_can_slave_func_a96);
    p_c4559734                                 = new GEN6_AT_OPTIONS(p_c4559734_master_stg,                       p_analog_can_slave_func_a96);
    p_c4559735                                 = new GEN6_AT_OPTIONS(p_c4559735_master_stg,                       p_analog_can_slave_func_a96);
    p_c3357809                                 = new GEN6_AT_OPTIONS(p_c3357809_master_stg,                       p_c2198656_func_a96);
    p_c3357810                                 = new GEN6_AT_OPTIONS(p_c3357810_master_stg,                       p_c2198656_func_a96);
    p_c4360828                                 = new GEN6_AT_OPTIONS(p_c4360828_master_stg,                       p_c1827097_func_a96);
    p_c4360832                                 = new GEN6_AT_OPTIONS(p_c4360832_master_stg,                       p_c1827097_func_a96);
    p_c4360836                                 = new GEN6_AT_OPTIONS(p_c4360836_master_stg,                       p_c1827097_func_a96);
    p_c4360840                                 = new GEN6_AT_OPTIONS(p_c4360840_master_stg,                       p_c1827097_func_a96);
    p_c9257883                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c1827097_func_a96);
    p_c9257885                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c4559714_func_a96);
    p_c9257887                                 = new GEN6_AT_OPTIONS(p_c9257887_master_stg,                       p_c4559714_func_a96);
    p_c9257888                                 = new GEN6_AT_OPTIONS(p_c9257888_master_stg,                       p_c4559714_func_a96);
    p_c9257889                                 = new GEN6_AT_OPTIONS(p_c9257889_master_stg,                       p_c4559714_func_a96);
    p_c9257890                                 = new GEN6_AT_OPTIONS(p_c9257890_master_stg,                       p_c4559714_func_a96);
    p_c9377438                                 = new GEN6_AT_OPTIONS(p_c9377438_master_stg,                       p_c1827097_func_a96);
    p_c3407086                                 = new GEN6_AT_OPTIONS(p_c3407086_master_stg,                       p_c1827097_func_a96);
    p_c3407087                                 = new GEN6_AT_OPTIONS(p_c3407087_master_stg,                       p_c1827097_func_a96);
    p_c9501311                                 = new GEN6_AT_OPTIONS(p_c9501311_master_stg,                       p_c2198656_func_a96);
    p_c9501313                                 = new GEN6_AT_OPTIONS(p_c9501313_master_stg,                       p_c2198656_func_a96);
    p_c9491969                                 = new GEN6_AT_OPTIONS(p_c9491969_master_stg,                       p_c2198656_func_a96);
    p_c9491974                                 = new GEN6_AT_OPTIONS(p_c9491974_master_stg,                       p_c2198656_func_a96);
    p_c9491977                                 = new GEN6_AT_OPTIONS(p_c9491977_master_stg,                       p_c2198656_func_a96);
    p_c9491979                                 = new GEN6_AT_OPTIONS(p_c9491979_master_stg,                       p_c2198656_func_a96);
    p_c9491980                                 = new GEN6_AT_OPTIONS(p_c9491980_master_stg,                       p_c2198656_func_a96);
    p_c9491981                                 = new GEN6_AT_OPTIONS(p_c9491981_master_stg,                       p_c2198656_func_a96);
    p_c9491982                                 = new GEN6_AT_OPTIONS(p_c9491982_master_stg,                       p_c2198656_func_a96);
    p_c9501309                                 = new GEN6_AT_OPTIONS(p_c9501309_master_stg,                       p_c2198656_func_a96);
    p_c9501310                                 = new GEN6_AT_OPTIONS(p_c9501310_master_stg,                       p_c2198656_func_a96);
    p_c9501320                                 = new GEN6_AT_OPTIONS(p_c9501320_master_stg,                       p_c2198656_func_a96);
    p_c9501322                                 = new GEN6_AT_OPTIONS(p_c9501322_master_stg,                       p_c2198656_func_a96);
    p_c9508185                                 = new GEN6_AT_OPTIONS(p_c9508185_master_stg,                       p_c2198656_func_a96);
    p_c9508187                                 = new GEN6_AT_OPTIONS(p_c9508187_master_stg,                       p_c2198656_func_a96);
    p_c9645313                                 = new GEN6_AT_OPTIONS(p_c9645313_master_stg,                       p_c2198656_func_a96);
    p_c9645315                                 = new GEN6_AT_OPTIONS(p_c9645315_master_stg,                       p_c2198656_func_a96);
    p_c9645320                                 = new GEN6_AT_OPTIONS(p_c9645320_master_stg,                       p_c2198656_func_a96);
    p_c9645322                                 = new GEN6_AT_OPTIONS(p_c9645322_master_stg,                       p_c2198656_func_a96);
    p_c9658745                                 = new GEN6_AT_OPTIONS(p_c9658745_master_stg,                       p_c2198656_func_a96);
    p_c9658747                                 = new GEN6_AT_OPTIONS(p_c9658747_master_stg,                       p_c2198656_func_a96);
    p_c9658752                                 = new GEN6_AT_OPTIONS(p_c9658752_master_stg,                       p_c2198656_func_a96);
    p_c9658754                                 = new GEN6_AT_OPTIONS(p_c9658754_master_stg,                       p_c2198656_func_a96);
    p_c9745928                                 = new GEN6_AT_OPTIONS(p_c9745928_master_stg,                       p_c2198656_func_a96);
    p_c9745929                                 = new GEN6_AT_OPTIONS(p_c9745929_master_stg,                       p_c2198656_func_a96);
    p_c9745930                                 = new GEN6_AT_OPTIONS(p_c9745930_master_stg,                       p_c2198656_func_a96);
    p_c9745931                                 = new GEN6_AT_OPTIONS(p_c9745931_master_stg,                       p_c2198656_func_a96);
    p_c4930044                                 = new GEN6_AT_OPTIONS(p_c4930044_master_stg,                       p_c2198656_func_a96);
    p_c4930051                                 = new GEN6_AT_OPTIONS(p_c4930051_master_stg,                       p_c2198656_func_a96);
    p_c9801189                                 = new GEN6_AT_OPTIONS(p_c9801189_master_stg,                       p_start_1_1_func_a96);
    p_c9801190                                 = new GEN6_AT_OPTIONS(p_c9801190_master_stg,                       p_start_1_1_func_a96);
    p_c9913925                                 = new GEN6_AT_OPTIONS(p_c9913925_master_stg,                       p_c2198656_func_a96);
    p_c9913926                                 = new GEN6_AT_OPTIONS(p_c9913926_master_stg,                       p_c2198656_func_a96);
    p_c4363738                                 = new GEN6_AT_OPTIONS(p_c4363738_master_stg,                       p_c2198656_func_a96);
    p_c4363739                                 = new GEN6_AT_OPTIONS(p_c4363739_master_stg,                       p_c2198656_func_a96);
    p_c2874561                                 = new GEN6_AT_OPTIONS(p_c2874561_master_stg,                       p_c2198656_func_a96);
    p_c2907769                                 = new GEN6_AT_OPTIONS(p_c2907769_master_stg,                       p_c2198656_func_a96);
    p_c170801                                  = new GEN6_AT_OPTIONS(p_c170801_master_stg,                        p_c2198656_func_a96);
    p_c10369958                                = new GEN6_AT_OPTIONS(p_c10369958_master_stg,                      p_c10369958_func_a96);
    p_c10369962                                = new GEN6_AT_OPTIONS(p_c10369962_master_stg,                      p_c10369958_func_a96);
    p_c10369966                                = new GEN6_AT_OPTIONS(p_c10369966_master_stg,                      p_c10369958_func_a96);
    p_c2874875                                 = new GEN6_AT_OPTIONS(p_c2874875_master_stg,                       p_c10369958_func_a96);
    p_c10288872                                = new GEN6_AT_OPTIONS(p_c10288872_master_stg,
                                                                     p_cap_sensor_func_a96,
                                                                     p_c10288872_func_r6eco);
    p_c10419622                                = new GEN6_AT_OPTIONS(p_c10419622_master_stg,                      p_c10369958_func_a96);
    p_c10419629                                = new GEN6_AT_OPTIONS(p_c10419629_master_stg,                      p_c10369958_func_a96);
    p_c10419630                                = new GEN6_AT_OPTIONS(p_c10419630_master_stg,                      p_c10369958_func_a96);
    p_c10485319                                = new GEN6_AT_OPTIONS(p_c10485319_master_stg,                      p_c10369958_func_a96);
    p_c10485321                                = new GEN6_AT_OPTIONS(p_c10485321_master_stg,                      p_c10369958_func_a96);
    p_c10645338                                = new GEN6_AT_OPTIONS(p_c187457_master_stg,
                                                                     p_cap_sensor_func_a96,
                                                                     p_c10288872_func_r6eco);
    p_c10634826                                = new GEN6_AT_OPTIONS(p_c10634826_master_stg,                      p_c10369958_func_a96);
    p_c10861710                                = new GEN6_AT_OPTIONS(p_c10861710_master_stg,                      p_c10369958_func_a96);
    p_c10861711                                = new GEN6_AT_OPTIONS(p_c10861711_master_stg,                      p_c10369958_func_a96);
    p_c10861712                                = new GEN6_AT_OPTIONS(p_c10861712_master_stg,                      p_c10369958_func_a96);
    p_c10861713                                = new GEN6_AT_OPTIONS(p_c10861713_master_stg,                      p_c10369958_func_a96);
    p_c10854614                                = new GEN6_AT_OPTIONS(p_c10854614_master_stg,                      p_c10854614_func_a96);
    p_c10854615                                = new GEN6_AT_OPTIONS(p_c10854615_master_stg,                      p_c10854614_func_a96);
    p_c10854594                                = new GEN6_AT_OPTIONS(p_c10854594_master_stg,                      p_c10854614_func_a96);
    p_c10854596                                = new GEN6_AT_OPTIONS(p_c10854596_master_stg,                      p_c10854614_func_a96);
    p_c10854607                                = new GEN6_AT_OPTIONS(p_c10854607_master_stg,                      p_c10854614_func_a96);
    p_c10854603                                = new GEN6_AT_OPTIONS(p_c10854603_master_stg,                      p_c10854614_func_a96);
    p_c10832739                                = new GEN6_AT_OPTIONS(p_c10832739_master_stg,                      p_analog_can_slave_func_a96);
    p_c10964449                                = new GEN6_AT_OPTIONS(p_c10964449_master_stg,                      p_c10964449_func_a96);
    p_c10964450                                = new GEN6_AT_OPTIONS(p_c10964450_master_stg,                      p_start_1_1_func_a96);
    p_c10634817                                = new GEN6_AT_OPTIONS(p_c10634817_master_stg,                      p_analog_can_slave_func_a96);
    p_c10415982                                = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_video_reg_func_a96);
    p_c11110395                                = new GEN6_AT_OPTIONS(p_c11110395_master_stg,                      p_analog_can_slave_func_a96);
    p_c11846848                                = new GEN6_AT_OPTIONS(p_c11846848_master_stg,                      p_c2198656_func_a96);
    p_c11946743                                = new GEN6_AT_OPTIONS(p_c11946743_master_stg,                      p_c2198656_func_a96);
}

void AutoTestsModesP2::initE96Settings()
{
    initE96Wires();
    initE96MasterStg();
    
    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_e96);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_e96);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_can_slave_func_e96);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_analog_slave_func_e96);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_analog_slave_func_e96);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_analog_slave_func_e96);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_e96);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_e96);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_e96);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_e96);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_e96);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_e96);
    p_c170781                                  = new GEN6_AT_OPTIONS(p_c170781_master_stg,                        p_cap_sensor_func_e96);
    p_c170782                                  = new GEN6_AT_OPTIONS(p_c170782_master_stg,                        p_cap_sensor_func_e96);
    p_c170792                                  = new GEN6_AT_OPTIONS(p_c170792_master_stg,                        p_cap_sensor_func_e96);
    p_c170799                                  = new GEN6_AT_OPTIONS(p_c170799_master_stg,                        p_cap_sensor_func_e96);
    p_c170800                                  = new GEN6_AT_OPTIONS(p_c170800_master_stg,                        p_cap_sensor_func_e96);
    p_c170808                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_ppp_func_e96);
    p_c170821                                  = new GEN6_AT_OPTIONS(p_c170821_master_stg,                        p_cap_sensor_func_e96);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_ppp_func_e96);

    p_c169641                                  = new GEN6_AT_OPTIONS(p_c169641_master_stg,                        p_cap_sensor_func_e96);
    p_c169642                                  = new GEN6_AT_OPTIONS(p_c169642_master_stg,                        p_cap_sensor_func_e96);
    p_c169643                                  = new GEN6_AT_OPTIONS(p_c169643_master_stg,                        p_cap_sensor_func_e96);
    p_c169644                                  = new GEN6_AT_OPTIONS(p_c169644_master_stg,                        p_cap_sensor_func_e96);
    p_c169645                                  = new GEN6_AT_OPTIONS(p_c169645_master_stg,                        p_cap_sensor_func_e96);
    p_c169648                                  = new GEN6_AT_OPTIONS(p_c169648_master_stg,                        p_cap_sensor_func_e96);
    p_c169656                                  = new GEN6_AT_OPTIONS(p_c169656_master_stg,                        p_cap_sensor_func_e96);
    p_c1578122                                 = new GEN6_AT_OPTIONS(p_c1578122_master_stg,                       p_cap_sensor_func_e96);
                                                                                                                  
    p_c169657                                  = new GEN6_AT_OPTIONS(p_c169657_master_stg,                        p_cap_sensor_func_e96);
    p_c169659                                  = new GEN6_AT_OPTIONS(p_c169659_master_stg,                        p_cap_sensor_func_e96);
    p_c1578123                                 = new GEN6_AT_OPTIONS(p_c1578123_master_stg,                       p_cap_sensor_func_e96);
    p_c169639                                  = new GEN6_AT_OPTIONS(p_c169639_master_stg,                        p_cap_sensor_func_e96);
    p_c169640                                  = new GEN6_AT_OPTIONS(p_c169640_master_stg,                        p_cap_sensor_func_e96);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_e96);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_e96);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_e96);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_e96);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_e96);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_e96);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_e96);

    p_c1827097                                 = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_c1827097_func_e96);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_can_slave_func_e96);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_can_slave_func_e96);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_can_slave_func_e96);

    p_c2043655                                 = new GEN6_AT_OPTIONS(p_c2043655_master_stg,                       p_ppp_func_e96);
    p_c2043657                                 = new GEN6_AT_OPTIONS(p_c2043657_master_stg,                       p_ppp_func_e96);
    p_c2043659                                 = new GEN6_AT_OPTIONS(p_c2043659_master_stg,                       p_analog_can_slave_func_e96);
    p_c2043661                                 = new GEN6_AT_OPTIONS(p_c2043661_master_stg,                       p_analog_can_slave_func_e96);

    p_c1981106                                 = new GEN6_AT_OPTIONS(p_c1981106_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981107                                 = new GEN6_AT_OPTIONS(p_c1981107_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981112                                 = new GEN6_AT_OPTIONS(p_c1981112_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981115                                 = new GEN6_AT_OPTIONS(p_c1981115_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981121                                 = new GEN6_AT_OPTIONS(p_c1981121_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981125                                 = new GEN6_AT_OPTIONS(p_c1981125_master_stg,                       p_hood_trunk_doors_e96);
    p_c1981136                                 = new GEN6_AT_OPTIONS(p_c1981136_master_stg,                       p_hood_trunk_doors_e96);

    p_c2405376                                 = new GEN6_AT_OPTIONS(p_c2405376_master_stg,                       p_cap_sensor_func_e96);

    p_c2405378                                 = new GEN6_AT_OPTIONS(p_c2405378_master_stg,                       p_cap_sensor_func_e96);
    p_c2405379                                 = new GEN6_AT_OPTIONS(p_c2405379_master_stg,                       p_cap_sensor_func_e96);
    
    p_c2424871                                 = new GEN6_AT_OPTIONS(p_c2424871_master_stg,                       p_cap_sensor_func_e96);
    p_c2424871_2                               = new GEN6_AT_OPTIONS(p_c2424871_2_master_stg,                     p_cap_sensor_func_e96);
    p_c2424873                                 = new GEN6_AT_OPTIONS(p_c2424873_master_stg,                       p_cap_sensor_func_e96);
    p_c2424875                                 = new GEN6_AT_OPTIONS(p_c2424875_master_stg,                       p_cap_sensor_func_e96);
    p_c2424876                                 = new GEN6_AT_OPTIONS(p_c2424876_master_stg,                       p_cap_sensor_func_e96);
    p_c2438277                                 = new GEN6_AT_OPTIONS(p_c2438277_master_stg,                       p_cap_sensor_func_e96);
    p_c2424877                                 = new GEN6_AT_OPTIONS(p_c2424877_master_stg,                       p_cap_sensor_func_e96);
    p_c2424878                                 = new GEN6_AT_OPTIONS(p_c2424878_master_stg,                       p_cap_sensor_func_e96);
    p_c2424879                                 = new GEN6_AT_OPTIONS(p_c2424879_master_stg,                       p_cap_sensor_func_e96);
    p_c2424880                                 = new GEN6_AT_OPTIONS(p_c2424880_master_stg,                       p_cap_sensor_func_e96);
    p_c2424881                                 = new GEN6_AT_OPTIONS(p_c2424881_master_stg,                       p_cap_sensor_func_e96);
    p_c2424882                                 = new GEN6_AT_OPTIONS(p_c2424882_master_stg,                       p_cap_sensor_func_e96);
    p_c2424883                                 = new GEN6_AT_OPTIONS(p_c2424883_master_stg,                       p_cap_sensor_func_e96);
    p_c2424884                                 = new GEN6_AT_OPTIONS(p_c2424884_master_stg,                       p_cap_sensor_func_e96);
    p_c2424885                                 = new GEN6_AT_OPTIONS(p_c2424885_master_stg,                       p_cap_sensor_func_e96);
    p_c2424886                                 = new GEN6_AT_OPTIONS(p_c2424886_master_stg,                       p_cap_sensor_func_e96);
    p_c2424887                                 = new GEN6_AT_OPTIONS(p_c2424887_master_stg,                       p_cap_sensor_func_e96);
    p_c2424888                                 = new GEN6_AT_OPTIONS(p_c2424888_master_stg,                       p_cap_sensor_func_e96);
    p_c2424889                                 = new GEN6_AT_OPTIONS(p_c2424889_master_stg,                       p_cap_sensor_func_e96);

    p_c2728677                                 = new GEN6_AT_OPTIONS(p_c2728677_master_stg,                       p_cap_sensor_func_e96);
    p_c2728678                                 = new GEN6_AT_OPTIONS(p_c2728678_master_stg,                       p_cap_sensor_func_e96);
    p_c2728679                                 = new GEN6_AT_OPTIONS(p_c2728679_master_stg,                       p_cap_sensor_func_e96);
    p_c2728682                                 = new GEN6_AT_OPTIONS(p_c2728682_master_stg,                       p_cap_sensor_func_e96);
    p_c2728683                                 = new GEN6_AT_OPTIONS(p_c2728683_master_stg,                       p_cap_sensor_func_e96);
    p_c2728684                                 = new GEN6_AT_OPTIONS(p_c2728684_master_stg,                       p_cap_sensor_func_e96);

    p_c172464                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_can_slave_func_e96);
    p_c1662256                                 = new GEN6_AT_OPTIONS(p_c1662256_master_stg,                       p_hood_analog_slave_func_e96);
    p_c1662261                                 = new GEN6_AT_OPTIONS(p_c1662261_master_stg,                       p_cap_can_slave_func_e96);
    p_c169588                                  = new GEN6_AT_OPTIONS(p_c169588_master_stg,                        p_cap_sensor_func_e96);
    p_c2198656                                 = new GEN6_AT_OPTIONS(p_c2198656_master_stg,                       p_c2198656_func_e96);
    p_c2198680                                 = new GEN6_AT_OPTIONS(p_c2198680_master_stg,                       p_c2198656_func_e96);
    p_c2198684                                 = new GEN6_AT_OPTIONS(p_c2198684_master_stg,                       p_c2198656_func_e96);
    p_c2198685                                 = new GEN6_AT_OPTIONS(p_c2198685_master_stg,                       p_c2198656_func_e96);
    p_c169591                                  = new GEN6_AT_OPTIONS(p_c169591_master_stg,                        p_cap_sensor_func_e96);
    p_c169592                                  = new GEN6_AT_OPTIONS(p_c169592_master_stg,                        p_cap_sensor_func_e96);
    p_c169593                                  = new GEN6_AT_OPTIONS(p_c169593_master_stg,                        p_cap_sensor_func_e96);
    p_c169594                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_sensor_func_e96);
    p_c2889927                                 = new GEN6_AT_OPTIONS(p_c2889927_master_stg,                       p_cap_can_slave_func_e96);
    p_c2889927_no_hf                           = new GEN6_AT_OPTIONS(p_c2889927_no_hf_master_stg,                 p_cap_can_slave_func_e96);
    p_c3052203                                 = new GEN6_AT_OPTIONS(p_c3052203_master_stg,                       p_cap_can_slave_func_e96);
    p_c3052206                                 = new GEN6_AT_OPTIONS(p_c3052206_master_stg,                       p_cap_can_slave_func_e96);
    p_c2799849                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_no_siren_func_e96);
    p_c2799850                                 = new GEN6_AT_OPTIONS(p_c2799850_master_stg,                       p_cap_can_slave_func_e96);
    p_c2799851                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_cap_can_slave_func_e96);
    p_c3202904                                 = new GEN6_AT_OPTIONS(p_c3202904_master_stg,                       p_hood_analog_slave_func_e96);
    p_c2799852                                 = new GEN6_AT_OPTIONS(p_c2799852_master_stg,                       p_c2799852_func_e96);
    p_c2799853                                 = new GEN6_AT_OPTIONS(p_c2799853_master_stg,                       p_c2799852_func_e96);
    p_c2799854                                 = new GEN6_AT_OPTIONS(p_c2799854_master_stg,                       p_c2799852_func_e96);
    p_c20461                                   = new GEN6_AT_OPTIONS(p_c20461_master_stg,                         p_hood_analog_slave_func_e96);
    p_c20462                                   = new GEN6_AT_OPTIONS(p_c20462_master_stg,                         p_hood_analog_slave_func_e96);
    p_c20463                                   = new GEN6_AT_OPTIONS(p_c20463_master_stg,                         p_hood_analog_slave_func_e96);
    p_auth_no_tag_needed                       = new GEN6_AT_OPTIONS(p_auth_no_tag_needed_master_stg,             p_hood_analog_slave_func_e96);
    p_c3752984                                 = new GEN6_AT_OPTIONS(p_c3752984_master_stg,                       p_c2799852_func_e96);
    p_c3752985                                 = new GEN6_AT_OPTIONS(p_c3752985_master_stg,                       p_c2799852_func_e96);
    p_c3752986                                 = new GEN6_AT_OPTIONS(p_c3752986_master_stg,                       p_c2799852_func_e96);
    p_c3752987                                 = new GEN6_AT_OPTIONS(p_c3752987_master_stg,                       p_c2799852_func_e96);
    p_c3136858                                 = new GEN6_AT_OPTIONS(p_c3136858_master_stg,                       p_c2799852_func_e96);
    p_c3688077                                 = new GEN6_AT_OPTIONS(p_c3688077_master_stg,                       p_cap_sensor_func_e96);
    p_no_rearm                                 = new GEN6_AT_OPTIONS(p_no_rearm_master_stg,                       p_cap_sensor_func_e96);
    p_c3697245                                 = new GEN6_AT_OPTIONS(p_c3697245_master_stg,                       p_start_1_1_func_e96);
    p_c3688075                                 = new GEN6_AT_OPTIONS(p_c3688075_master_stg,                       p_start_1_1_func_e96);
    p_c3688076                                 = new GEN6_AT_OPTIONS(p_c3688076_master_stg,                       p_cap_sensor_func_e96);
    p_no_auth                                  = new GEN6_AT_OPTIONS(p_no_auth_master_stg,                        p_c2799852_func_e96);
    p_c3136863                                 = new GEN6_AT_OPTIONS(p_c3136863_master_stg,                       p_c2799852_func_e96);
    p_c3136864                                 = new GEN6_AT_OPTIONS(p_c3136864_master_stg,                       p_c2799852_func_e96);
    p_c170806                                  = new GEN6_AT_OPTIONS(p_c170806_master_stg,                        p_cap_sensor_func_e96);
    p_c187473                                  = new GEN6_AT_OPTIONS(p_c187473_master_stg,                        p_cap_sensor_func_e96);
    p_c187475                                  = new GEN6_AT_OPTIONS(p_c187475_master_stg,                        p_cap_sensor_func_e96);
    p_c187457                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_cap_sensor_func_e96);
    p_c187458                                  = new GEN6_AT_OPTIONS(p_c187458_master_stg,                        p_cap_sensor_func_e96);
    p_c187459                                  = new GEN6_AT_OPTIONS(p_c187459_master_stg,                        p_cap_sensor_func_e96);
    p_c187462                                  = new GEN6_AT_OPTIONS(p_c187462_master_stg,                        p_cap_sensor_func_e96);
    p_c187463                                  = new GEN6_AT_OPTIONS(p_c187463_master_stg,                        p_cap_sensor_func_e96);
    p_c187464                                  = new GEN6_AT_OPTIONS(p_c187464_master_stg,                        p_cap_sensor_func_e96);
    p_c187471                                  = new GEN6_AT_OPTIONS(p_c187471_master_stg,                        p_cap_sensor_func_e96);
    p_c187478                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_c187478_func_e96);
    p_c4045282                                 = new GEN6_AT_OPTIONS(p_c4045282_master_stg,                       p_cap_sensor_func_e96);
    p_c4045283                                 = new GEN6_AT_OPTIONS(p_c4045283_master_stg,                       p_cap_sensor_func_e96);
    p_c4045286                                 = new GEN6_AT_OPTIONS(p_c4045286_master_stg,                       p_cap_sensor_func_e96);
    p_c4045290                                 = new GEN6_AT_OPTIONS(p_c4045290_master_stg,                       p_cap_sensor_func_e96);
    p_c4045291                                 = new GEN6_AT_OPTIONS(p_c4045291_master_stg,                       p_cap_sensor_func_e96);
    p_c4045294                                 = new GEN6_AT_OPTIONS(p_c4045294_master_stg,                       p_cap_sensor_func_e96);
    p_c2898585                                 = new GEN6_AT_OPTIONS(p_c2898585_master_stg,                       p_cap_can_slave_func_e96);
    p_c170805                                  = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_start_1_1_func_e96);
    p_c4559714                                 = new GEN6_AT_OPTIONS(p_c4559714_master_stg,                       p_c4559714_func_e96);
    p_can_ovl_one_dis                          = new GEN6_AT_OPTIONS(p_can_ovl_one_dis_master_stg,                p_analog_can_slave_func_e96);
    p_c4695722                                 = new GEN6_AT_OPTIONS(p_c4695722_master_stg,                       p_analog_can_slave_func_e96);
    p_c4686621                                 = new GEN6_AT_OPTIONS(p_c4686621_master_stg,                       p_analog_can_slave_func_e96);
    p_c4695725                                 = new GEN6_AT_OPTIONS(p_c4695725_master_stg,                       p_analog_can_slave_func_e96);
    p_c4695726                                 = new GEN6_AT_OPTIONS(p_c4695726_master_stg,                       p_analog_can_slave_func_e96);
    p_c4801978                                 = new GEN6_AT_OPTIONS(p_c4801978_master_stg,                       p_analog_can_slave_func_e96);
    p_c4801979                                 = new GEN6_AT_OPTIONS(p_c4801979_master_stg,                       p_analog_can_slave_func_e96);
    p_c4801981                                 = new GEN6_AT_OPTIONS(p_c4801981_master_stg,                       p_analog_can_slave_func_e96);
    p_c4828410                                 = new GEN6_AT_OPTIONS(p_c4828410_master_stg,                       p_analog_can_slave_func_e96);
    p_c4828414                                 = new GEN6_AT_OPTIONS(p_c4828414_master_stg,                       p_analog_can_slave_func_e96);
    p_c4559732                                 = new GEN6_AT_OPTIONS(p_c4559732_master_stg,                       p_analog_can_slave_func_e96);
    p_c4559733                                 = new GEN6_AT_OPTIONS(p_c4559733_master_stg,                       p_analog_can_slave_func_e96);
    p_c4559734                                 = new GEN6_AT_OPTIONS(p_c4559734_master_stg,                       p_analog_can_slave_func_e96);
    p_c4559735                                 = new GEN6_AT_OPTIONS(p_c4559735_master_stg,                       p_analog_can_slave_func_e96);
    p_c3357809                                 = new GEN6_AT_OPTIONS(p_c3357809_master_stg,                       p_c2198656_func_e96);
    p_c3357810                                 = new GEN6_AT_OPTIONS(p_c3357810_master_stg,                       p_c2198656_func_e96);
    p_c4360828                                 = new GEN6_AT_OPTIONS(p_c4360828_master_stg,                       p_c1827097_func_e96);
    p_c4360832                                 = new GEN6_AT_OPTIONS(p_c4360832_master_stg,                       p_c1827097_func_e96);
    p_c4360836                                 = new GEN6_AT_OPTIONS(p_c4360836_master_stg,                       p_c1827097_func_e96);
    p_c4360840                                 = new GEN6_AT_OPTIONS(p_c4360840_master_stg,                       p_c1827097_func_e96);
    p_c9257883                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c1827097_func_e96);
    p_c9257885                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c4559714_func_e96);
    p_c9257887                                 = new GEN6_AT_OPTIONS(p_c9257887_master_stg,                       p_c4559714_func_e96);
    p_c9257888                                 = new GEN6_AT_OPTIONS(p_c9257888_master_stg,                       p_c4559714_func_e96);
    p_c9257889                                 = new GEN6_AT_OPTIONS(p_c9257889_master_stg,                       p_c4559714_func_e96);
    p_c9257890                                 = new GEN6_AT_OPTIONS(p_c9257890_master_stg,                       p_c4559714_func_e96);
    p_c9377438                                 = new GEN6_AT_OPTIONS(p_c9377438_master_stg,                       p_c1827097_func_e96);
    p_c3407086                                 = new GEN6_AT_OPTIONS(p_c3407086_master_stg,                       p_c1827097_func_e96);
    p_c3407087                                 = new GEN6_AT_OPTIONS(p_c3407087_master_stg,                       p_c1827097_func_e96);
    p_c9501311                                 = new GEN6_AT_OPTIONS(p_c9501311_master_stg,                       p_c2198656_func_e96);
    p_c9501313                                 = new GEN6_AT_OPTIONS(p_c9501313_master_stg,                       p_c2198656_func_e96);
    p_c9491969                                 = new GEN6_AT_OPTIONS(p_c9491969_master_stg,                       p_c2198656_func_e96);
    p_c9491974                                 = new GEN6_AT_OPTIONS(p_c9491974_master_stg,                       p_c2198656_func_e96);
    p_c9491977                                 = new GEN6_AT_OPTIONS(p_c9491977_master_stg,                       p_c2198656_func_e96);
    p_c9491979                                 = new GEN6_AT_OPTIONS(p_c9491979_master_stg,                       p_c2198656_func_e96);
    p_c9491980                                 = new GEN6_AT_OPTIONS(p_c9491980_master_stg,                       p_c2198656_func_e96);
    p_c9491981                                 = new GEN6_AT_OPTIONS(p_c9491981_master_stg,                       p_c2198656_func_e96);
    p_c9491982                                 = new GEN6_AT_OPTIONS(p_c9491982_master_stg,                       p_c2198656_func_e96);
    p_c9501309                                 = new GEN6_AT_OPTIONS(p_c9501309_master_stg,                       p_c2198656_func_e96);
    p_c9501310                                 = new GEN6_AT_OPTIONS(p_c9501310_master_stg,                       p_c2198656_func_e96);
    p_c9501320                                 = new GEN6_AT_OPTIONS(p_c9501320_master_stg,                       p_c2198656_func_e96);
    p_c9501322                                 = new GEN6_AT_OPTIONS(p_c9501322_master_stg,                       p_c2198656_func_e96);
    p_c9508185                                 = new GEN6_AT_OPTIONS(p_c9508185_master_stg,                       p_c2198656_func_e96);
    p_c9508187                                 = new GEN6_AT_OPTIONS(p_c9508187_master_stg,                       p_c2198656_func_e96);
    p_c9645313                                 = new GEN6_AT_OPTIONS(p_c9645313_master_stg,                       p_c2198656_func_e96);
    p_c9645315                                 = new GEN6_AT_OPTIONS(p_c9645315_master_stg,                       p_c2198656_func_e96);
    p_c9645320                                 = new GEN6_AT_OPTIONS(p_c9645320_master_stg,                       p_c2198656_func_e96);
    p_c9645322                                 = new GEN6_AT_OPTIONS(p_c9645322_master_stg,                       p_c2198656_func_e96);
    p_c9658745                                 = new GEN6_AT_OPTIONS(p_c9658745_master_stg,                       p_c2198656_func_e96);
    p_c9658747                                 = new GEN6_AT_OPTIONS(p_c9658747_master_stg,                       p_c2198656_func_e96);
    p_c9658752                                 = new GEN6_AT_OPTIONS(p_c9658752_master_stg,                       p_c2198656_func_e96);
    p_c9658754                                 = new GEN6_AT_OPTIONS(p_c9658754_master_stg,                       p_c2198656_func_e96);
    p_c9745928                                 = new GEN6_AT_OPTIONS(p_c9745928_master_stg,                       p_c2198656_func_e96);
    p_c9745929                                 = new GEN6_AT_OPTIONS(p_c9745929_master_stg,                       p_c2198656_func_e96);
    p_c9745930                                 = new GEN6_AT_OPTIONS(p_c9745930_master_stg,                       p_c2198656_func_e96);
    p_c9745931                                 = new GEN6_AT_OPTIONS(p_c9745931_master_stg,                       p_c2198656_func_e96);
    p_c4930044                                 = new GEN6_AT_OPTIONS(p_c4930044_master_stg,                       p_c2198656_func_e96);
    p_c4930051                                 = new GEN6_AT_OPTIONS(p_c4930051_master_stg,                       p_c2198656_func_e96);
    p_c9801189                                 = new GEN6_AT_OPTIONS(p_c9801189_master_stg,                       p_start_1_1_func_e96);
    p_c9801190                                 = new GEN6_AT_OPTIONS(p_c9801190_master_stg,                       p_start_1_1_func_e96);
    p_c9913925                                 = new GEN6_AT_OPTIONS(p_c9913925_master_stg,                       p_c2198656_func_e96);
    p_c9913926                                 = new GEN6_AT_OPTIONS(p_c9913926_master_stg,                       p_c2198656_func_e96);
    p_c4363738                                 = new GEN6_AT_OPTIONS(p_c4363738_master_stg,                       p_c2198656_func_e96);
    p_c4363739                                 = new GEN6_AT_OPTIONS(p_c4363739_master_stg,                       p_c2198656_func_e96);
    p_c2874561                                 = new GEN6_AT_OPTIONS(p_c2874561_master_stg,                       p_c2198656_func_e96);
    p_c2907769                                 = new GEN6_AT_OPTIONS(p_c2907769_master_stg,                       p_c2198656_func_e96);
    p_c170801                                  = new GEN6_AT_OPTIONS(p_c170801_master_stg,                        p_c2198656_func_e96);
    p_c10369958                                = new GEN6_AT_OPTIONS(p_c10369958_master_stg,                      p_c10369958_func_e96);
    p_c10369962                                = new GEN6_AT_OPTIONS(p_c10369962_master_stg,                      p_c10369958_func_e96);
    p_c10369966                                = new GEN6_AT_OPTIONS(p_c10369966_master_stg,                      p_c10369958_func_e96);
    p_c2874875                                 = new GEN6_AT_OPTIONS(p_c2874875_master_stg,                       p_c10369958_func_e96);
    p_c10288872                                = new GEN6_AT_OPTIONS(p_c10288872_master_stg,
                                                                     p_cap_sensor_func_e96,
                                                                     p_c10288872_func_r6eco);
    p_c10419622                                = new GEN6_AT_OPTIONS(p_c10419622_master_stg,                      p_c10369958_func_e96);
    p_c10419629                                = new GEN6_AT_OPTIONS(p_c10419629_master_stg,                      p_c10369958_func_e96);
    p_c10419630                                = new GEN6_AT_OPTIONS(p_c10419630_master_stg,                      p_c10369958_func_e96);
    p_c10485319                                = new GEN6_AT_OPTIONS(p_c10485319_master_stg,                      p_c10369958_func_e96);
    p_c10485321                                = new GEN6_AT_OPTIONS(p_c10485321_master_stg,                      p_c10369958_func_e96);
    p_c10645338                                = new GEN6_AT_OPTIONS(p_c187457_master_stg,
                                                                     p_cap_sensor_func_e96,
                                                                     p_c10288872_func_r6eco);
    p_c10634826                                = new GEN6_AT_OPTIONS(p_c10634826_master_stg,                      p_c10369958_func_e96);
    p_c10861710                                = new GEN6_AT_OPTIONS(p_c10861710_master_stg,                      p_c10369958_func_e96);
    p_c10861711                                = new GEN6_AT_OPTIONS(p_c10861711_master_stg,                      p_c10369958_func_e96);
    p_c10861712                                = new GEN6_AT_OPTIONS(p_c10861712_master_stg,                      p_c10369958_func_e96);
    p_c10861713                                = new GEN6_AT_OPTIONS(p_c10861713_master_stg,                      p_c10369958_func_e96);
    p_c10854614                                = new GEN6_AT_OPTIONS(p_c10854614_master_stg,                      p_c10854614_func_e96);
    p_c10854615                                = new GEN6_AT_OPTIONS(p_c10854615_master_stg,                      p_c10854614_func_e96);
    p_c10854594                                = new GEN6_AT_OPTIONS(p_c10854594_master_stg,                      p_c10854614_func_e96);
    p_c10854596                                = new GEN6_AT_OPTIONS(p_c10854596_master_stg,                      p_c10854614_func_e96);
    p_c10854607                                = new GEN6_AT_OPTIONS(p_c10854607_master_stg,                      p_c10854614_func_e96);
    p_c10854603                                = new GEN6_AT_OPTIONS(p_c10854603_master_stg,                      p_c10854614_func_e96);
    p_c10832739                                = new GEN6_AT_OPTIONS(p_c10832739_master_stg,                      p_analog_can_slave_func_e96);
    p_c10964449                                = new GEN6_AT_OPTIONS(p_c10964449_master_stg,                      p_c10964449_func_e96);
    p_c10964450                                = new GEN6_AT_OPTIONS(p_c10964450_master_stg,                      p_start_1_1_func_e96);
    p_c10634817                                = new GEN6_AT_OPTIONS(p_c10634817_master_stg,                      p_analog_can_slave_func_e96);
    p_c10415982                                = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_video_reg_func_e96);
    p_c11110395                                = new GEN6_AT_OPTIONS(p_c11110395_master_stg,                      p_analog_can_slave_func_e96);
    p_c11846848                                = new GEN6_AT_OPTIONS(p_c11846848_master_stg,                      p_c2198656_func_e96);
    p_c11946743                                = new GEN6_AT_OPTIONS(p_c11946743_master_stg,                      p_c2198656_func_e96);
}

void AutoTestsModesP2::initS96Settings()
{
    initS96Wires();
    initS96MasterStg();

    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_s96);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_s96);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_can_slave_func_s96);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_analog_slave_func_s96);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_analog_slave_func_s96);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_analog_slave_func_s96);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_s96);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_s96);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_s96);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_s96);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_s96);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_s96);
    p_c170781                                  = new GEN6_AT_OPTIONS(p_c170781_master_stg,                        p_cap_sensor_func_s96);
    p_c170782                                  = new GEN6_AT_OPTIONS(p_c170782_master_stg,                        p_cap_sensor_func_s96);
    p_c170792                                  = new GEN6_AT_OPTIONS(p_c170792_master_stg,                        p_cap_sensor_func_s96);
    p_c170799                                  = new GEN6_AT_OPTIONS(p_c170799_master_stg,                        p_cap_sensor_func_s96);
    p_c170800                                  = new GEN6_AT_OPTIONS(p_c170800_master_stg,                        p_cap_sensor_func_s96);
    p_c170808                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_ppp_func_s96);
    p_c170821                                  = new GEN6_AT_OPTIONS(p_c170821_master_stg,                        p_cap_sensor_func_s96);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_cap_sensor_func_s96);

    p_c169641                                  = new GEN6_AT_OPTIONS(p_c169641_master_stg,                        p_cap_sensor_func_s96);
    p_c169642                                  = new GEN6_AT_OPTIONS(p_c169642_master_stg,                        p_cap_sensor_func_s96);
    p_c169643                                  = new GEN6_AT_OPTIONS(p_c169643_master_stg,                        p_cap_sensor_func_s96);
    p_c169644                                  = new GEN6_AT_OPTIONS(p_c169644_master_stg,                        p_cap_sensor_func_s96);
    p_c169645                                  = new GEN6_AT_OPTIONS(p_c169645_master_stg,                        p_cap_sensor_func_s96);
    p_c169648                                  = new GEN6_AT_OPTIONS(p_c169648_master_stg,                        p_cap_sensor_func_s96);
    p_c169656                                  = new GEN6_AT_OPTIONS(p_c169656_master_stg,                        p_cap_sensor_func_s96);
    p_c1578122                                 = new GEN6_AT_OPTIONS(p_c1578122_master_stg,                       p_cap_sensor_func_s96);
    
    p_c169657                                  = new GEN6_AT_OPTIONS(p_c169657_master_stg,                        p_cap_sensor_func_s96);
    p_c169659                                  = new GEN6_AT_OPTIONS(p_c169659_master_stg,                        p_cap_sensor_func_s96);
    p_c1578123                                 = new GEN6_AT_OPTIONS(p_c1578123_master_stg,                       p_cap_sensor_func_s96);
    p_c169639                                  = new GEN6_AT_OPTIONS(p_c169639_master_stg,                        p_cap_sensor_func_s96);
    p_c169640                                  = new GEN6_AT_OPTIONS(p_c169640_master_stg,                        p_cap_sensor_func_s96);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_s96);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_s96);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_s96);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_s96);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_s96);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_s96);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_s96);

    p_c1827097                                 = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_c1827097_func_s96);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_can_slave_func_s96);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_can_slave_func_s96);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_can_slave_func_s96);

    p_c2043655                                 = new GEN6_AT_OPTIONS(p_c2043655_master_stg,                       p_ppp_func_s96);
    p_c2043657                                 = new GEN6_AT_OPTIONS(p_c2043657_master_stg,                       p_ppp_func_s96);
    p_c2043659                                 = new GEN6_AT_OPTIONS(p_c2043659_master_stg,                       p_analog_can_slave_func_s96);
    p_c2043661                                 = new GEN6_AT_OPTIONS(p_c2043661_master_stg,                       p_analog_can_slave_func_s96);

    p_c1981106                                 = new GEN6_AT_OPTIONS(p_c1981106_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981107                                 = new GEN6_AT_OPTIONS(p_c1981107_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981112                                 = new GEN6_AT_OPTIONS(p_c1981112_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981115                                 = new GEN6_AT_OPTIONS(p_c1981115_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981121                                 = new GEN6_AT_OPTIONS(p_c1981121_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981125                                 = new GEN6_AT_OPTIONS(p_c1981125_master_stg,                       p_hood_trunk_doors_s96);
    p_c1981136                                 = new GEN6_AT_OPTIONS(p_c1981136_master_stg,                       p_hood_trunk_doors_s96);
    p_c2405376                                 = new GEN6_AT_OPTIONS(p_c2405376_master_stg,                       p_cap_sensor_func_s96);
    
    p_c2424871                                 = new GEN6_AT_OPTIONS(p_c2424871_master_stg,                       p_cap_sensor_func_s96);
    p_c2424871_2                               = new GEN6_AT_OPTIONS(p_c2424871_2_master_stg,                     p_cap_sensor_func_s96);
    p_c2424873                                 = new GEN6_AT_OPTIONS(p_c2424873_master_stg,                       p_cap_sensor_func_s96);
    p_c2424875                                 = new GEN6_AT_OPTIONS(p_c2424875_master_stg,                       p_cap_sensor_func_s96);
    p_c2424876                                 = new GEN6_AT_OPTIONS(p_c2424876_master_stg,                       p_cap_sensor_func_s96);
    p_c2438277                                 = new GEN6_AT_OPTIONS(p_c2438277_master_stg,                       p_cap_sensor_func_s96);
    p_c2424877                                 = new GEN6_AT_OPTIONS(p_c2424877_master_stg,                       p_cap_sensor_func_s96);
    p_c2424878                                 = new GEN6_AT_OPTIONS(p_c2424878_master_stg,                       p_cap_sensor_func_s96);
    p_c2424879                                 = new GEN6_AT_OPTIONS(p_c2424879_master_stg,                       p_cap_sensor_func_s96);
    p_c2424880                                 = new GEN6_AT_OPTIONS(p_c2424880_master_stg,                       p_cap_sensor_func_s96);
    p_c2424881                                 = new GEN6_AT_OPTIONS(p_c2424881_master_stg,                       p_cap_sensor_func_s96);
    p_c2424882                                 = new GEN6_AT_OPTIONS(p_c2424882_master_stg,                       p_cap_sensor_func_s96);
    p_c2424883                                 = new GEN6_AT_OPTIONS(p_c2424883_master_stg,                       p_cap_sensor_func_s96);
    p_c2424884                                 = new GEN6_AT_OPTIONS(p_c2424884_master_stg,                       p_cap_sensor_func_s96);
    p_c2424885                                 = new GEN6_AT_OPTIONS(p_c2424885_master_stg,                       p_cap_sensor_func_s96);
    p_c2424886                                 = new GEN6_AT_OPTIONS(p_c2424886_master_stg,                       p_cap_sensor_func_s96);
    p_c2424887                                 = new GEN6_AT_OPTIONS(p_c2424887_master_stg,                       p_cap_sensor_func_s96);
    p_c2424888                                 = new GEN6_AT_OPTIONS(p_c2424888_master_stg,                       p_cap_sensor_func_s96);
    p_c2424889                                 = new GEN6_AT_OPTIONS(p_c2424889_master_stg,                       p_cap_sensor_func_s96);

    p_c2728677                                 = new GEN6_AT_OPTIONS(p_c2728677_master_stg,                       p_cap_sensor_func_s96);
    p_c2728678                                 = new GEN6_AT_OPTIONS(p_c2728678_master_stg,                       p_cap_sensor_func_s96);
    p_c2728679                                 = new GEN6_AT_OPTIONS(p_c2728679_master_stg,                       p_cap_sensor_func_s96);
    p_c2728682                                 = new GEN6_AT_OPTIONS(p_c2728682_master_stg,                       p_cap_sensor_func_s96);
    p_c2728683                                 = new GEN6_AT_OPTIONS(p_c2728683_master_stg,                       p_cap_sensor_func_s96);
    p_c2728684                                 = new GEN6_AT_OPTIONS(p_c2728684_master_stg,                       p_cap_sensor_func_s96);

    p_c172464                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_can_slave_func_s96);
    p_c1662256                                 = new GEN6_AT_OPTIONS(p_c1662256_master_stg,                       p_hood_analog_slave_func_s96);
    p_c1662261                                 = new GEN6_AT_OPTIONS(p_c1662261_master_stg,                       p_cap_can_slave_func_s96);
    p_c169588                                  = new GEN6_AT_OPTIONS(p_c169588_master_stg,                        p_cap_sensor_func_s96);
    p_c169591                                  = new GEN6_AT_OPTIONS(p_c169591_master_stg,                        p_cap_sensor_func_s96);
    p_c169592                                  = new GEN6_AT_OPTIONS(p_c169592_master_stg,                        p_cap_sensor_func_s96);
    p_c169593                                  = new GEN6_AT_OPTIONS(p_c169593_master_stg,                        p_cap_sensor_func_s96);
    p_c169594                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_sensor_func_s96);
    p_c3052203                                 = new GEN6_AT_OPTIONS(p_c3052203_master_stg,                       p_cap_can_slave_func_s96);
    p_c3052206                                 = new GEN6_AT_OPTIONS(p_c3052206_master_stg,                       p_cap_can_slave_func_s96);
    p_c2799849                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_no_siren_func_s96);
    p_c2799850                                 = new GEN6_AT_OPTIONS(p_c2799850_master_stg,                       p_cap_can_slave_func_s96);
    p_c2799851                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_cap_can_slave_func_s96);
    p_c3202904                                 = new GEN6_AT_OPTIONS(p_c3202904_master_stg,                       p_hood_analog_slave_func_s96);
    p_c2799852                                 = new GEN6_AT_OPTIONS(p_c2799852_master_stg,                       p_c2799852_func_s96);
    p_c2799853                                 = new GEN6_AT_OPTIONS(p_c2799853_master_stg,                       p_c2799852_func_s96);
    p_c2799854                                 = new GEN6_AT_OPTIONS(p_c2799854_master_stg,                       p_c2799852_func_s96);
    p_c20461                                   = new GEN6_AT_OPTIONS(p_c20461_master_stg,                         p_hood_analog_slave_func_s96);
    p_c20462                                   = new GEN6_AT_OPTIONS(p_c20462_master_stg,                         p_hood_analog_slave_func_s96);
    p_c20463                                   = new GEN6_AT_OPTIONS(p_c20463_master_stg,                         p_hood_analog_slave_func_s96);
    p_auth_no_tag_needed                       = new GEN6_AT_OPTIONS(p_auth_no_tag_needed_master_stg,             p_hood_analog_slave_func_s96);
    p_c3752984                                 = new GEN6_AT_OPTIONS(p_c3752984_master_stg,                       p_c2799852_func_s96);
    p_c3752985                                 = new GEN6_AT_OPTIONS(p_c3752985_master_stg,                       p_c2799852_func_s96);
    p_c3752986                                 = new GEN6_AT_OPTIONS(p_c3752986_master_stg,                       p_c2799852_func_s96);
    p_c3752987                                 = new GEN6_AT_OPTIONS(p_c3752987_master_stg,                       p_c2799852_func_s96);
    p_c3136858                                 = new GEN6_AT_OPTIONS(p_c3136858_master_stg,                       p_c2799852_func_s96);
    p_c3688077                                 = new GEN6_AT_OPTIONS(p_c3688077_master_stg,                       p_cap_sensor_func_s96);
    p_no_rearm                                 = new GEN6_AT_OPTIONS(p_no_rearm_master_stg,                       p_cap_sensor_func_s96);
    p_c3697245                                 = new GEN6_AT_OPTIONS(p_c3697245_master_stg,                       p_start_1_1_func_s96);
    p_c3688075                                 = new GEN6_AT_OPTIONS(p_c3688075_master_stg,                       p_start_1_1_func_s96);
    p_c3688076                                 = new GEN6_AT_OPTIONS(p_c3688076_master_stg,                       p_cap_sensor_func_s96);
    p_no_auth                                  = new GEN6_AT_OPTIONS(p_no_auth_master_stg,                        p_c2799852_func_s96);
    p_c3136863                                 = new GEN6_AT_OPTIONS(p_c3136863_master_stg,                       p_c2799852_func_s96);
    p_c3136864                                 = new GEN6_AT_OPTIONS(p_c3136864_master_stg,                       p_c2799852_func_s96);
    p_c170806                                  = new GEN6_AT_OPTIONS(p_c170806_master_stg,                        p_cap_sensor_func_s96);
    p_c187473                                  = new GEN6_AT_OPTIONS(p_c187473_master_stg,                        p_cap_sensor_func_s96);
    p_c187475                                  = new GEN6_AT_OPTIONS(p_c187475_master_stg,                        p_cap_sensor_func_s96);
    p_c187457                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_cap_sensor_func_s96);
    p_c187458                                  = new GEN6_AT_OPTIONS(p_c187458_master_stg,                        p_cap_sensor_func_s96);
    p_c187459                                  = new GEN6_AT_OPTIONS(p_c187459_master_stg,                        p_cap_sensor_func_s96);
    p_c187462                                  = new GEN6_AT_OPTIONS(p_c187462_master_stg,                        p_cap_sensor_func_s96);
    p_c187463                                  = new GEN6_AT_OPTIONS(p_c187463_master_stg,                        p_cap_sensor_func_s96);
    p_c187464                                  = new GEN6_AT_OPTIONS(p_c187464_master_stg,                        p_cap_sensor_func_s96);
    p_c187471                                  = new GEN6_AT_OPTIONS(p_c187471_master_stg,                        p_cap_sensor_func_s96);
    p_c187478                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_c187478_func_s96);
    p_c4045282                                 = new GEN6_AT_OPTIONS(p_c4045282_master_stg,                       p_cap_sensor_func_s96);
    p_c4045283                                 = new GEN6_AT_OPTIONS(p_c4045283_master_stg,                       p_cap_sensor_func_s96);
    p_c4045286                                 = new GEN6_AT_OPTIONS(p_c4045286_master_stg,                       p_cap_sensor_func_s96);
    p_c4045290                                 = new GEN6_AT_OPTIONS(p_c4045290_master_stg,                       p_cap_sensor_func_s96);
    p_c4045291                                 = new GEN6_AT_OPTIONS(p_c4045291_master_stg,                       p_cap_sensor_func_s96);
    p_c4045294                                 = new GEN6_AT_OPTIONS(p_c4045294_master_stg,                       p_cap_sensor_func_s96);
    p_c2898585                                 = new GEN6_AT_OPTIONS(p_c2898585_master_stg,                       p_cap_can_slave_func_s96);
    p_c170805                                  = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_start_1_1_func_s96);
    p_c4559714                                 = new GEN6_AT_OPTIONS(p_c4559714_master_stg,                       p_c4559714_func_s96);
    p_can_ovl_one_dis                          = new GEN6_AT_OPTIONS(p_can_ovl_one_dis_master_stg,                p_analog_can_slave_func_s96);
    p_c4695722                                 = new GEN6_AT_OPTIONS(p_c4695722_master_stg,                       p_analog_can_slave_func_s96);
    p_c4686621                                 = new GEN6_AT_OPTIONS(p_c4686621_master_stg,                       p_analog_can_slave_func_s96);
    p_c4695725                                 = new GEN6_AT_OPTIONS(p_c4695725_master_stg,                       p_analog_can_slave_func_s96);
    p_c4695726                                 = new GEN6_AT_OPTIONS(p_c4695726_master_stg,                       p_analog_can_slave_func_s96);
    p_c4801978                                 = new GEN6_AT_OPTIONS(p_c4801978_master_stg,                       p_analog_can_slave_func_s96);
    p_c4801979                                 = new GEN6_AT_OPTIONS(p_c4801979_master_stg,                       p_analog_can_slave_func_s96);
    p_c4801981                                 = new GEN6_AT_OPTIONS(p_c4801981_master_stg,                       p_analog_can_slave_func_s96);
    p_c4828410                                 = new GEN6_AT_OPTIONS(p_c4828410_master_stg,                       p_analog_can_slave_func_s96);
    p_c4828414                                 = new GEN6_AT_OPTIONS(p_c4828414_master_stg,                       p_analog_can_slave_func_s96);
    p_c4559732                                 = new GEN6_AT_OPTIONS(p_c4559732_master_stg,                       p_analog_can_slave_func_s96);
    p_c4559733                                 = new GEN6_AT_OPTIONS(p_c4559733_master_stg,                       p_analog_can_slave_func_s96);
    p_c4559734                                 = new GEN6_AT_OPTIONS(p_c4559734_master_stg,                       p_analog_can_slave_func_s96);
    p_c4559735                                 = new GEN6_AT_OPTIONS(p_c4559735_master_stg,                       p_analog_can_slave_func_s96);
    p_c3357809                                 = new GEN6_AT_OPTIONS(p_c3357809_master_stg,                       p_c2799852_func_s96);
    p_c3357810                                 = new GEN6_AT_OPTIONS(p_c3357810_master_stg,                       p_c2799852_func_s96);
    p_c4360828                                 = new GEN6_AT_OPTIONS(p_c4360828_master_stg,                       p_c1827097_func_s96);
    p_c4360832                                 = new GEN6_AT_OPTIONS(p_c4360832_master_stg,                       p_c1827097_func_s96);
    p_c4360836                                 = new GEN6_AT_OPTIONS(p_c4360836_master_stg,                       p_c1827097_func_s96);
    p_c4360840                                 = new GEN6_AT_OPTIONS(p_c4360840_master_stg,                       p_c1827097_func_s96);
    p_c9257883                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c1827097_func_s96);
    p_c9257885                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c4559714_func_s96);
    p_c9257887                                 = new GEN6_AT_OPTIONS(p_c9257887_master_stg,                       p_c4559714_func_s96);
    p_c9257888                                 = new GEN6_AT_OPTIONS(p_c9257888_master_stg,                       p_c4559714_func_s96);
    p_c9257889                                 = new GEN6_AT_OPTIONS(p_c9257889_master_stg,                       p_c4559714_func_s96);
    p_c9257890                                 = new GEN6_AT_OPTIONS(p_c9257890_master_stg,                       p_c4559714_func_s96);
    p_c9377438                                 = new GEN6_AT_OPTIONS(p_c9377438_master_stg,                       p_c1827097_func_s96);
    p_c3407086                                 = new GEN6_AT_OPTIONS(p_c3407086_master_stg,                       p_c1827097_func_s96);
    p_c3407087                                 = new GEN6_AT_OPTIONS(p_c3407087_master_stg,                       p_c1827097_func_s96);
    p_c9501311                                 = new GEN6_AT_OPTIONS(p_c9501311_master_stg,                       p_c2198656_func_s96);
    p_c9501313                                 = new GEN6_AT_OPTIONS(p_c9501313_master_stg,                       p_c2198656_func_s96);
    p_c9491969                                 = new GEN6_AT_OPTIONS(p_c9491969_master_stg,                       p_c2198656_func_s96);
    p_c9491974                                 = new GEN6_AT_OPTIONS(p_c9491974_master_stg,                       p_c2198656_func_s96);
    p_c9491977                                 = new GEN6_AT_OPTIONS(p_c9491977_master_stg,                       p_c2198656_func_s96);
    p_c9491979                                 = new GEN6_AT_OPTIONS(p_c9491979_master_stg,                       p_c2198656_func_s96);
    p_c9491980                                 = new GEN6_AT_OPTIONS(p_c9491980_master_stg,                       p_c2198656_func_s96);
    p_c9491981                                 = new GEN6_AT_OPTIONS(p_c9491981_master_stg,                       p_c2198656_func_s96);
    p_c9491982                                 = new GEN6_AT_OPTIONS(p_c9491982_master_stg,                       p_c2198656_func_s96);
    p_c9501309                                 = new GEN6_AT_OPTIONS(p_c9501309_master_stg,                       p_c2198656_func_s96);
    p_c9501310                                 = new GEN6_AT_OPTIONS(p_c9501310_master_stg,                       p_c2198656_func_s96);
    p_c9501320                                 = new GEN6_AT_OPTIONS(p_c9501320_master_stg,                       p_c2198656_func_s96);
    p_c9501322                                 = new GEN6_AT_OPTIONS(p_c9501322_master_stg,                       p_c2198656_func_s96);
    p_c9508185                                 = new GEN6_AT_OPTIONS(p_c9508185_master_stg,                       p_c2198656_func_s96);
    p_c9508187                                 = new GEN6_AT_OPTIONS(p_c9508187_master_stg,                       p_c2198656_func_s96);
    p_c9645313                                 = new GEN6_AT_OPTIONS(p_c9645313_master_stg,                       p_c2198656_func_s96);
    p_c9645315                                 = new GEN6_AT_OPTIONS(p_c9645315_master_stg,                       p_c2198656_func_s96);
    p_c9645320                                 = new GEN6_AT_OPTIONS(p_c9645320_master_stg,                       p_c2198656_func_s96);
    p_c9645322                                 = new GEN6_AT_OPTIONS(p_c9645322_master_stg,                       p_c2198656_func_s96);
    p_c9658745                                 = new GEN6_AT_OPTIONS(p_c9658745_master_stg,                       p_c2198656_func_s96);
    p_c9658747                                 = new GEN6_AT_OPTIONS(p_c9658747_master_stg,                       p_c2198656_func_s96);
    p_c9658752                                 = new GEN6_AT_OPTIONS(p_c9658752_master_stg,                       p_c2198656_func_s96);
    p_c9658754                                 = new GEN6_AT_OPTIONS(p_c9658754_master_stg,                       p_c2198656_func_s96);
    p_c9745928                                 = new GEN6_AT_OPTIONS(p_c9745928_master_stg,                       p_c2198656_func_s96);
    p_c9745929                                 = new GEN6_AT_OPTIONS(p_c9745929_master_stg,                       p_c2198656_func_s96);
    p_c9745930                                 = new GEN6_AT_OPTIONS(p_c9745930_master_stg,                       p_c2198656_func_s96);
    p_c9745931                                 = new GEN6_AT_OPTIONS(p_c9745931_master_stg,                       p_c2198656_func_s96);
    p_c4930044                                 = new GEN6_AT_OPTIONS(p_c4930044_master_stg,                       p_c2198656_func_s96);
    p_c4930051                                 = new GEN6_AT_OPTIONS(p_c4930051_master_stg,                       p_c2198656_func_s96);
    p_c9801189                                 = new GEN6_AT_OPTIONS(p_c9801189_master_stg,                       p_start_1_1_func_s96);
    p_c9801190                                 = new GEN6_AT_OPTIONS(p_c9801190_master_stg,                       p_start_1_1_func_s96);
    p_c9913925                                 = new GEN6_AT_OPTIONS(p_c9913925_master_stg,                       p_c2198656_func_s96);
    p_c9913926                                 = new GEN6_AT_OPTIONS(p_c9913926_master_stg,                       p_c2198656_func_s96);
    p_c4363738                                 = new GEN6_AT_OPTIONS(p_c4363738_master_stg,                       p_c2198656_func_s96);
    p_c4363739                                 = new GEN6_AT_OPTIONS(p_c4363739_master_stg,                       p_c2198656_func_s96);
    p_c2874561                                 = new GEN6_AT_OPTIONS(p_c2874561_master_stg,                       p_c2198656_func_s96);
    p_c2907769                                 = new GEN6_AT_OPTIONS(p_c2907769_master_stg,                       p_c2198656_func_s96);
    p_c170801                                  = new GEN6_AT_OPTIONS(p_c170801_master_stg,                        p_c2198656_func_s96);
    p_c10369958                                = new GEN6_AT_OPTIONS(p_c10369958_master_stg,                      p_c10369958_func_s96);
    p_c10369962                                = new GEN6_AT_OPTIONS(p_c10369962_master_stg,                      p_c10369958_func_s96);
    p_c10369966                                = new GEN6_AT_OPTIONS(p_c10369966_master_stg,                      p_c10369958_func_s96);
    p_c2874875                                 = new GEN6_AT_OPTIONS(p_c2874875_master_stg,                       p_c10369958_func_s96);
    p_c10288872                                = new GEN6_AT_OPTIONS(p_c10288872_master_stg,
                                                                     p_cap_sensor_func_s96,
                                                                     p_c10288872_func_r6eco);
    p_c10419622                                = new GEN6_AT_OPTIONS(p_c10419622_master_stg,                      p_c10369958_func_s96);
    p_c10419629                                = new GEN6_AT_OPTIONS(p_c10419629_master_stg,                      p_c10369958_func_s96);
    p_c10419630                                = new GEN6_AT_OPTIONS(p_c10419630_master_stg,                      p_c10369958_func_s96);
    p_c10485319                                = new GEN6_AT_OPTIONS(p_c10485319_master_stg,                      p_c10369958_func_s96);
    p_c10485321                                = new GEN6_AT_OPTIONS(p_c10485321_master_stg,                      p_c10369958_func_s96);
    p_c10645338                                = new GEN6_AT_OPTIONS(p_c187457_master_stg,
                                                                     p_cap_sensor_func_s96,
                                                                     p_c10288872_func_r6eco);
    p_c10634826                                = new GEN6_AT_OPTIONS(p_c10634826_master_stg,                      p_c10369958_func_s96);
    p_c10861710                                = new GEN6_AT_OPTIONS(p_c10861710_master_stg,                      p_c10369958_func_s96);
    p_c10861711                                = new GEN6_AT_OPTIONS(p_c10861711_master_stg,                      p_c10369958_func_s96);
    p_c10861712                                = new GEN6_AT_OPTIONS(p_c10861712_master_stg,                      p_c10369958_func_s96);
    p_c10861713                                = new GEN6_AT_OPTIONS(p_c10861713_master_stg,                      p_c10369958_func_s96);
    p_c10854614                                = new GEN6_AT_OPTIONS(p_c10854614_master_stg,                      p_c10854614_func_s96);
    p_c10854615                                = new GEN6_AT_OPTIONS(p_c10854615_master_stg,                      p_c10854614_func_s96);
    p_c10854594                                = new GEN6_AT_OPTIONS(p_c10854594_master_stg,                      p_c10854614_func_s96);
    p_c10854596                                = new GEN6_AT_OPTIONS(p_c10854596_master_stg,                      p_c10854614_func_s96);
    p_c10854607                                = new GEN6_AT_OPTIONS(p_c10854607_master_stg,                      p_c10854614_func_s96);
    p_c10854603                                = new GEN6_AT_OPTIONS(p_c10854603_master_stg,                      p_c10854614_func_s96);
    p_c10832739                                = new GEN6_AT_OPTIONS(p_c10832739_master_stg,                      p_analog_can_slave_func_s96);
    p_c10964449                                = new GEN6_AT_OPTIONS(p_c10964449_master_stg,                      p_c10964449_func_s96);
    p_c10964450                                = new GEN6_AT_OPTIONS(p_c10964450_master_stg,                      p_start_1_1_func_s96);
    p_c10634817                                = new GEN6_AT_OPTIONS(p_c10634817_master_stg,                      p_analog_can_slave_func_s96);
    p_c10415982                                = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_video_reg_func_s96);
    p_c11110395                                = new GEN6_AT_OPTIONS(p_c11110395_master_stg,                      p_analog_can_slave_func_s96);
    p_c11846848                                = new GEN6_AT_OPTIONS(p_c11846848_master_stg,                      p_c2198656_func_s96);
    p_c11946743                                = new GEN6_AT_OPTIONS(p_c11946743_master_stg,                      p_c2198656_func_s96);
}

void AutoTestsModesP2::initX96v2Settings()
{
    initX96v2Wires();
    initX96v2MasterStg();

    p_c168671                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168672                                  = new GEN6_AT_OPTIONS(p_c168672_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168685                                  = new GEN6_AT_OPTIONS(p_c168685_master_stg,                        p_cap_can_slave_func_x96v2);
    p_c168686                                  = new GEN6_AT_OPTIONS(p_c168686_master_stg,                        p_cap_analog_slave_func_x96v2);
    p_c168687                                  = new GEN6_AT_OPTIONS(p_c168687_master_stg,                        p_cap_analog_slave_func_x96v2);
    p_c168688                                  = new GEN6_AT_OPTIONS(p_c168688_master_stg,                        p_cap_analog_slave_func_x96v2);
    p_c168695                                  = new GEN6_AT_OPTIONS(p_c168695_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168696                                  = new GEN6_AT_OPTIONS(p_c168696_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168703                                  = new GEN6_AT_OPTIONS(p_c168703_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168707                                  = new GEN6_AT_OPTIONS(p_c168707_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168714                                  = new GEN6_AT_OPTIONS(p_c168714_master_stg,                        p_cap_sensor_func_x96v2);
    p_c168723                                  = new GEN6_AT_OPTIONS(p_c168723_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170781                                  = new GEN6_AT_OPTIONS(p_c170781_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170782                                  = new GEN6_AT_OPTIONS(p_c170782_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170792                                  = new GEN6_AT_OPTIONS(p_c170792_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170799                                  = new GEN6_AT_OPTIONS(p_c170799_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170800                                  = new GEN6_AT_OPTIONS(p_c170800_master_stg,                        p_cap_sensor_func_x96v2);
    p_c170808                                  = new GEN6_AT_OPTIONS(p_c168671_master_stg,                        p_ppp_func_x96v2);
    p_c170821                                  = new GEN6_AT_OPTIONS(p_c170821_master_stg,                        p_cap_sensor_func_x96v2);
    p_c171184                                  = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_rearm_breake_func_x96v2);

    p_c169641                                  = new GEN6_AT_OPTIONS(p_c169641_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169642                                  = new GEN6_AT_OPTIONS(p_c169642_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169643                                  = new GEN6_AT_OPTIONS(p_c169643_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169644                                  = new GEN6_AT_OPTIONS(p_c169644_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169645                                  = new GEN6_AT_OPTIONS(p_c169645_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169648                                  = new GEN6_AT_OPTIONS(p_c169648_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169656                                  = new GEN6_AT_OPTIONS(p_c169656_master_stg,                        p_cap_sensor_func_x96v2);
    p_c1578122                                 = new GEN6_AT_OPTIONS(p_c1578122_master_stg,                       p_cap_sensor_func_x96v2);
    
    p_c169657                                  = new GEN6_AT_OPTIONS(p_c169657_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169659                                  = new GEN6_AT_OPTIONS(p_c169659_master_stg,                        p_cap_sensor_func_x96v2);
    p_c1578123                                 = new GEN6_AT_OPTIONS(p_c1578123_master_stg,                       p_cap_sensor_func_x96v2);
    p_c169639                                  = new GEN6_AT_OPTIONS(p_c169639_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169640                                  = new GEN6_AT_OPTIONS(p_c169640_master_stg,                        p_cap_sensor_func_x96v2);
    p_c1616162                                 = new GEN6_AT_OPTIONS(p_c1616162_master_stg,                       p_start_1_1_func_x96v2);
    p_c1616163                                 = new GEN6_AT_OPTIONS(p_c1616163_master_stg,                       p_start_1_1_func_x96v2);
    p_c1616164                                 = new GEN6_AT_OPTIONS(p_c1616164_master_stg,                       p_start_1_1_func_x96v2);
    p_c1624514                                 = new GEN6_AT_OPTIONS(p_c1624514_master_stg,                       p_start_1_1_func_x96v2);
    p_c1624516                                 = new GEN6_AT_OPTIONS(p_c1624516_master_stg,                       p_start_1_1_func_x96v2);
    p_c1624517                                 = new GEN6_AT_OPTIONS(p_c1624517_master_stg,                       p_start_1_1_func_x96v2);
    p_c1624518                                 = new GEN6_AT_OPTIONS(p_c1624518_master_stg,                       p_start_1_1_func_x96v2);

    p_c1827097                                 = new GEN6_AT_OPTIONS(p_c171184_master_stg,                        p_c1827097_func_x96v2);

    p_c172480                                  = new GEN6_AT_OPTIONS(p_c172480_master_stg,                        p_cap_can_slave_func_x96v2);
    p_c172498                                  = new GEN6_AT_OPTIONS(p_c172498_master_stg,                        p_cap_can_slave_func_x96v2);
    p_c172473                                  = new GEN6_AT_OPTIONS(p_c172473_master_stg,                        p_cap_can_slave_func_x96v2);

    p_c2043655                                 = new GEN6_AT_OPTIONS(p_c2043655_master_stg,                       p_ppp_func_x96v2);
    p_c2043657                                 = new GEN6_AT_OPTIONS(p_c2043657_master_stg,                       p_ppp_func_x96v2);
    p_c2043659                                 = new GEN6_AT_OPTIONS(p_c2043659_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c2043661                                 = new GEN6_AT_OPTIONS(p_c2043661_master_stg,                       p_analog_can_slave_func_x96v2);

    p_c1981106                                 = new GEN6_AT_OPTIONS(p_c1981106_master_stg,                       p_ppp_func_x96v2);
    p_c1981107                                 = new GEN6_AT_OPTIONS(p_c1981107_master_stg,                       p_ppp_func_x96v2);
    p_c1981112                                 = new GEN6_AT_OPTIONS(p_c1981112_master_stg,                       p_ppp_func_x96v2);
    p_c1981115                                 = new GEN6_AT_OPTIONS(p_c1981115_master_stg,                       p_ppp_func_x96v2);
    p_c1981121                                 = new GEN6_AT_OPTIONS(p_c1981121_master_stg,                       p_ppp_func_x96v2);
    p_c1981125                                 = new GEN6_AT_OPTIONS(p_c1981125_master_stg,                       p_ppp_func_x96v2);
    p_c1981136                                 = new GEN6_AT_OPTIONS(p_c1981136_master_stg,                       p_ppp_func_x96v2);

    p_c2405376                                 = new GEN6_AT_OPTIONS(p_c2405376_master_stg,                       p_cap_sensor_func_x96v2);

    
    p_c2405378                                 = new GEN6_AT_OPTIONS(p_c2405378_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2405379                                 = new GEN6_AT_OPTIONS(p_c2405379_master_stg,                       p_cap_sensor_func_x96v2);
    
    p_c2424871                                 = new GEN6_AT_OPTIONS(p_c2424871_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424871_2                               = new GEN6_AT_OPTIONS(p_c2424871_2_master_stg,                     p_cap_sensor_func_x96v2);
    p_c2424873                                 = new GEN6_AT_OPTIONS(p_c2424873_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424875                                 = new GEN6_AT_OPTIONS(p_c2424875_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424876                                 = new GEN6_AT_OPTIONS(p_c2424876_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2438277                                 = new GEN6_AT_OPTIONS(p_c2438277_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424877                                 = new GEN6_AT_OPTIONS(p_c2424877_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424878                                 = new GEN6_AT_OPTIONS(p_c2424878_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424879                                 = new GEN6_AT_OPTIONS(p_c2424879_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424880                                 = new GEN6_AT_OPTIONS(p_c2424880_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424881                                 = new GEN6_AT_OPTIONS(p_c2424881_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424882                                 = new GEN6_AT_OPTIONS(p_c2424882_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424883                                 = new GEN6_AT_OPTIONS(p_c2424883_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424884                                 = new GEN6_AT_OPTIONS(p_c2424884_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424885                                 = new GEN6_AT_OPTIONS(p_c2424885_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424886                                 = new GEN6_AT_OPTIONS(p_c2424886_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424887                                 = new GEN6_AT_OPTIONS(p_c2424887_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424888                                 = new GEN6_AT_OPTIONS(p_c2424888_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2424889                                 = new GEN6_AT_OPTIONS(p_c2424889_master_stg,                       p_cap_sensor_func_x96v2);

    p_c2728677                                 = new GEN6_AT_OPTIONS(p_c2728677_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2728678                                 = new GEN6_AT_OPTIONS(p_c2728678_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2728679                                 = new GEN6_AT_OPTIONS(p_c2728679_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2728682                                 = new GEN6_AT_OPTIONS(p_c2728682_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2728683                                 = new GEN6_AT_OPTIONS(p_c2728683_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2728684                                 = new GEN6_AT_OPTIONS(p_c2728684_master_stg,                       p_cap_sensor_func_x96v2);

    p_c172464                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_can_slave_func_x96v2);
    p_c1662256                                 = new GEN6_AT_OPTIONS(p_c1662256_master_stg,                       p_hood_analog_slave_func_x96v2);
    p_c1662261                                 = new GEN6_AT_OPTIONS(p_c1662261_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c169588                                  = new GEN6_AT_OPTIONS(p_c169588_master_stg,                        p_cap_sensor_func_x96v2);
    p_c2198656                                 = new GEN6_AT_OPTIONS(p_c2198656_master_stg,                       p_c2198656_func_x96v2);
    p_c2198680                                 = new GEN6_AT_OPTIONS(p_c2198680_master_stg,                       p_c2198656_func_x96v2);
    p_c2198684                                 = new GEN6_AT_OPTIONS(p_c2198684_master_stg,                       p_c2198656_func_x96v2);
    p_c2198685                                 = new GEN6_AT_OPTIONS(p_c2198685_master_stg,                       p_c2198656_func_x96v2);
    p_c169591                                  = new GEN6_AT_OPTIONS(p_c169591_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169592                                  = new GEN6_AT_OPTIONS(p_c169592_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169593                                  = new GEN6_AT_OPTIONS(p_c169593_master_stg,                        p_cap_sensor_func_x96v2);
    p_c169594                                  = new GEN6_AT_OPTIONS(p_c172464_master_stg,                        p_cap_sensor_func_x96v2);
    p_c2889927                                 = new GEN6_AT_OPTIONS(p_c2889927_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c2889927_no_hf                           = new GEN6_AT_OPTIONS(p_c2889927_no_hf_master_stg,                 p_cap_can_slave_func_x96v2);
    p_c3052203                                 = new GEN6_AT_OPTIONS(p_c3052203_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c3052206                                 = new GEN6_AT_OPTIONS(p_c3052206_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c2799849                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_no_siren_func_x96v2);
    p_c2799850                                 = new GEN6_AT_OPTIONS(p_c2799850_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c2799851                                 = new GEN6_AT_OPTIONS(p_c2799849_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c3202904                                 = new GEN6_AT_OPTIONS(p_c3202904_master_stg,                       p_hood_analog_slave_func_x96v2);
    p_c2799852                                 = new GEN6_AT_OPTIONS(p_c2799852_master_stg,                       p_c2799852_func_x96v2);
    p_c2799853                                 = new GEN6_AT_OPTIONS(p_c2799853_master_stg,                       p_c2799852_func_x96v2);
    p_c2799854                                 = new GEN6_AT_OPTIONS(p_c2799854_master_stg,                       p_c2799854_func_x96v2);
    p_c20461                                   = new GEN6_AT_OPTIONS(p_c20461_master_stg,                         p_hood_analog_slave_func_x96v2);
    p_c20462                                   = new GEN6_AT_OPTIONS(p_c20462_master_stg,                         p_hood_analog_slave_func_x96v2);
    p_c20463                                   = new GEN6_AT_OPTIONS(p_c20463_master_stg,                         p_hood_analog_slave_func_x96v2);
    p_auth_no_tag_needed                       = new GEN6_AT_OPTIONS(p_auth_no_tag_needed_master_stg,             p_hood_analog_slave_func_x96v2);
    p_c3752984                                 = new GEN6_AT_OPTIONS(p_c3752984_master_stg,                       p_c2799852_func_x96v2);
    p_c3752985                                 = new GEN6_AT_OPTIONS(p_c3752985_master_stg,                       p_c2799852_func_x96v2);
    p_c3752986                                 = new GEN6_AT_OPTIONS(p_c3752986_master_stg,                       p_c2799852_func_x96v2);
    p_c3752987                                 = new GEN6_AT_OPTIONS(p_c3752987_master_stg,                       p_c2799852_func_x96v2);
    p_c3136858                                 = new GEN6_AT_OPTIONS(p_c3136858_master_stg,                       p_c2799852_func_x96v2);
    p_c3688077                                 = new GEN6_AT_OPTIONS(p_c3688077_master_stg,                       p_cap_sensor_func_x96v2);
    p_no_rearm                                 = new GEN6_AT_OPTIONS(p_no_rearm_master_stg,                       p_cap_sensor_func_x96v2);
    p_c3697245                                 = new GEN6_AT_OPTIONS(p_c3697245_master_stg,                       p_start_1_1_func_x96v2);
    p_c3688075                                 = new GEN6_AT_OPTIONS(p_c3688075_master_stg,                       p_start_1_1_func_x96v2);
    p_c3688076                                 = new GEN6_AT_OPTIONS(p_c3688076_master_stg,                       p_c2799852_func_x96v2);
    p_no_auth                                  = new GEN6_AT_OPTIONS(p_no_auth_master_stg,                        p_c2799852_func_x96v2);
    p_c3136863                                 = new GEN6_AT_OPTIONS(p_c3136863_master_stg,                       p_c2799852_func_x96v2);
    p_c3136864                                 = new GEN6_AT_OPTIONS(p_c3136864_master_stg,                       p_c2799852_func_x96v2);
    p_c170806                                  = new GEN6_AT_OPTIONS(p_c170806_master_stg,                        p_ppp_func_x96v2);
    p_c187473                                  = new GEN6_AT_OPTIONS(p_c187473_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187475                                  = new GEN6_AT_OPTIONS(p_c187475_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187457                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187458                                  = new GEN6_AT_OPTIONS(p_c187458_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187459                                  = new GEN6_AT_OPTIONS(p_c187459_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187462                                  = new GEN6_AT_OPTIONS(p_c187462_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187463                                  = new GEN6_AT_OPTIONS(p_c187463_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187464                                  = new GEN6_AT_OPTIONS(p_c187464_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187471                                  = new GEN6_AT_OPTIONS(p_c187471_master_stg,                        p_cap_sensor_func_x96v2);
    p_c187478                                  = new GEN6_AT_OPTIONS(p_c187457_master_stg,                        p_c187478_func_x96v2);
    p_c4045282                                 = new GEN6_AT_OPTIONS(p_c4045282_master_stg,                       p_cap_sensor_func_x96v2);
    p_c4045283                                 = new GEN6_AT_OPTIONS(p_c4045283_master_stg,                       p_cap_sensor_func_x96v2);
    p_c4045286                                 = new GEN6_AT_OPTIONS(p_c4045286_master_stg,                       p_cap_sensor_func_x96v2);
    p_c4045290                                 = new GEN6_AT_OPTIONS(p_c4045290_master_stg,                       p_cap_sensor_func_x96v2);
    p_c4045291                                 = new GEN6_AT_OPTIONS(p_c4045291_master_stg,                       p_cap_sensor_func_x96v2);
    p_c4045294                                 = new GEN6_AT_OPTIONS(p_c4045294_master_stg,                       p_cap_sensor_func_x96v2);
    p_c2898585                                 = new GEN6_AT_OPTIONS(p_c2898585_master_stg,                       p_cap_can_slave_func_x96v2);
    p_c170805                                  = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_start_1_1_func_x96v2);
    p_c4559714                                 = new GEN6_AT_OPTIONS(p_c4559714_master_stg,                       p_c4559714_func_x96v2);
    p_can_ovl_one_dis                          = new GEN6_AT_OPTIONS(p_can_ovl_one_dis_master_stg,                p_analog_can_slave_func_x96v2);
    p_c4695722                                 = new GEN6_AT_OPTIONS(p_c4695722_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4686621                                 = new GEN6_AT_OPTIONS(p_c4686621_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4695725                                 = new GEN6_AT_OPTIONS(p_c4695725_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4695726                                 = new GEN6_AT_OPTIONS(p_c4695726_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4801978                                 = new GEN6_AT_OPTIONS(p_c4801978_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4801979                                 = new GEN6_AT_OPTIONS(p_c4801979_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4801981                                 = new GEN6_AT_OPTIONS(p_c4801981_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4828410                                 = new GEN6_AT_OPTIONS(p_c4828410_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4828414                                 = new GEN6_AT_OPTIONS(p_c4828414_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4559732                                 = new GEN6_AT_OPTIONS(p_c4559732_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4559733                                 = new GEN6_AT_OPTIONS(p_c4559733_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4559734                                 = new GEN6_AT_OPTIONS(p_c4559734_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c4559735                                 = new GEN6_AT_OPTIONS(p_c4559735_master_stg,                       p_analog_can_slave_func_x96v2);
    p_c3357809                                 = new GEN6_AT_OPTIONS(p_c3357809_master_stg,                       p_c2198656_func_x96v2);
    p_c3357810                                 = new GEN6_AT_OPTIONS(p_c3357810_master_stg,                       p_c2198656_func_x96v2);
    p_c4360828                                 = new GEN6_AT_OPTIONS(p_c4360828_master_stg,                       p_c4360828_func_x96v2);
    p_c4360832                                 = new GEN6_AT_OPTIONS(p_c4360832_master_stg,                       p_c4360828_func_x96v2);
    p_c4360836                                 = new GEN6_AT_OPTIONS(p_c4360836_master_stg,                       p_c4360828_func_x96v2);
    p_c4360840                                 = new GEN6_AT_OPTIONS(p_c4360840_master_stg,                       p_c4360828_func_x96v2);
    p_c9257883                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c1827097_func_x96v2);
    p_c9257885                                 = new GEN6_AT_OPTIONS(p_c9257883_master_stg,                       p_c4559714_func_x96v2);
    p_c9257887                                 = new GEN6_AT_OPTIONS(p_c9257887_master_stg,                       p_c4559714_func_x96v2);
    p_c9257888                                 = new GEN6_AT_OPTIONS(p_c9257888_master_stg,                       p_c4559714_func_x96v2);
    p_c9257889                                 = new GEN6_AT_OPTIONS(p_c9257889_master_stg,                       p_c4559714_func_x96v2);
    p_c9257890                                 = new GEN6_AT_OPTIONS(p_c9257890_master_stg,                       p_c4559714_func_x96v2);
    p_c9377438                                 = new GEN6_AT_OPTIONS(p_c9377438_master_stg,                       p_c4360828_func_x96v2);
    p_c3407086                                 = new GEN6_AT_OPTIONS(p_c3407086_master_stg,                       p_c1827097_func_x96v2);
    p_c3407087                                 = new GEN6_AT_OPTIONS(p_c3407087_master_stg,                       p_c1827097_func_x96v2);
    p_c9501311                                 = new GEN6_AT_OPTIONS(p_c9501311_master_stg,                       p_c2198656_func_x96v2);
    p_c9501313                                 = new GEN6_AT_OPTIONS(p_c9501313_master_stg,                       p_c2198656_func_x96v2);
    p_c9491969                                 = new GEN6_AT_OPTIONS(p_c9491969_master_stg,                       p_c2198656_func_x96v2);
    p_c9491974                                 = new GEN6_AT_OPTIONS(p_c9491974_master_stg,                       p_c2198656_func_x96v2);
    p_c9491977                                 = new GEN6_AT_OPTIONS(p_c9491977_master_stg,                       p_c2198656_func_x96v2);
    p_c9491979                                 = new GEN6_AT_OPTIONS(p_c9491979_master_stg,                       p_c2198656_func_x96v2);
    p_c9491980                                 = new GEN6_AT_OPTIONS(p_c9491980_master_stg,                       p_c2198656_func_x96v2);
    p_c9491981                                 = new GEN6_AT_OPTIONS(p_c9491981_master_stg,                       p_c2198656_func_x96v2);
    p_c9491982                                 = new GEN6_AT_OPTIONS(p_c9491982_master_stg,                       p_c2198656_func_x96v2);
    p_c9501309                                 = new GEN6_AT_OPTIONS(p_c9501309_master_stg,                       p_c2198656_func_x96v2);
    p_c9501310                                 = new GEN6_AT_OPTIONS(p_c9501310_master_stg,                       p_c2198656_func_x96v2);
    p_c9501320                                 = new GEN6_AT_OPTIONS(p_c9501320_master_stg,                       p_c2198656_func_x96v2);
    p_c9501322                                 = new GEN6_AT_OPTIONS(p_c9501322_master_stg,                       p_c2198656_func_x96v2);
    p_c9508185                                 = new GEN6_AT_OPTIONS(p_c9508185_master_stg,                       p_c2198656_func_x96v2);
    p_c9508187                                 = new GEN6_AT_OPTIONS(p_c9508187_master_stg,                       p_c2198656_func_x96v2);
    p_c9645313                                 = new GEN6_AT_OPTIONS(p_c9645313_master_stg,                       p_c2198656_func_x96v2);
    p_c9645315                                 = new GEN6_AT_OPTIONS(p_c9645315_master_stg,                       p_c2198656_func_x96v2);
    p_c9645320                                 = new GEN6_AT_OPTIONS(p_c9645320_master_stg,                       p_c2198656_func_x96v2);
    p_c9645322                                 = new GEN6_AT_OPTIONS(p_c9645322_master_stg,                       p_c2198656_func_x96v2);
    p_c9658745                                 = new GEN6_AT_OPTIONS(p_c9658745_master_stg,                       p_c2198656_func_x96v2);
    p_c9658747                                 = new GEN6_AT_OPTIONS(p_c9658747_master_stg,                       p_c2198656_func_x96v2);
    p_c9658752                                 = new GEN6_AT_OPTIONS(p_c9658752_master_stg,                       p_c2198656_func_x96v2);
    p_c9658754                                 = new GEN6_AT_OPTIONS(p_c9658754_master_stg,                       p_c2198656_func_x96v2);
    p_c9745928                                 = new GEN6_AT_OPTIONS(p_c9745928_master_stg,                       p_c2198656_func_x96v2);
    p_c9745929                                 = new GEN6_AT_OPTIONS(p_c9745929_master_stg,                       p_c2198656_func_x96v2);
    p_c9745930                                 = new GEN6_AT_OPTIONS(p_c9745930_master_stg,                       p_c2198656_func_x96v2);
    p_c9745931                                 = new GEN6_AT_OPTIONS(p_c9745931_master_stg,                       p_c2198656_func_x96v2);
    p_c4930044                                 = new GEN6_AT_OPTIONS(p_c4930044_master_stg,                       p_c2198656_func_x96v2);
    p_c4930051                                 = new GEN6_AT_OPTIONS(p_c4930051_master_stg,                       p_c2198656_func_x96v2);
    p_c9801189                                 = new GEN6_AT_OPTIONS(p_c9801189_master_stg,                       p_start_1_1_func_x96v2);
    p_c9801190                                 = new GEN6_AT_OPTIONS(p_c9801190_master_stg,                       p_start_1_1_func_x96v2);
    p_c9913925                                 = new GEN6_AT_OPTIONS(p_c9913925_master_stg,                       p_c2198656_func_x96v2);
    p_c9913926                                 = new GEN6_AT_OPTIONS(p_c9913926_master_stg,                       p_c2198656_func_x96v2);
    p_c4363738                                 = new GEN6_AT_OPTIONS(p_c4363738_master_stg,                       p_c2198656_func_x96v2);
    p_c4363739                                 = new GEN6_AT_OPTIONS(p_c4363739_master_stg,                       p_c2198656_func_x96v2);
    p_c2874561                                 = new GEN6_AT_OPTIONS(p_c2874561_master_stg,                       p_c2198656_func_x96v2);
    p_c2907769                                 = new GEN6_AT_OPTIONS(p_c2907769_master_stg,                       p_c2198656_func_x96v2);
    p_c170801                                  = new GEN6_AT_OPTIONS(p_c170801_master_stg,                        p_c2198656_func_x96v2);
    p_c10369958                                = new GEN6_AT_OPTIONS(p_c10369958_master_stg,                      p_c10369958_func_x96v2);
    p_c10369962                                = new GEN6_AT_OPTIONS(p_c10369962_master_stg,                      p_c10369958_func_x96v2);
    p_c10369966                                = new GEN6_AT_OPTIONS(p_c10369966_master_stg,                      p_c10369958_func_x96v2);
    p_c2874875                                 = new GEN6_AT_OPTIONS(p_c2874875_master_stg,                       p_c10369958_func_x96v2);
    p_c10288872                                = new GEN6_AT_OPTIONS(p_c10288872_master_stg,
                                                                     p_cap_sensor_func_x96v2,
                                                                     p_c10288872_func_r6eco);
    p_c10419622                                = new GEN6_AT_OPTIONS(p_c10419622_master_stg,                      p_c10419622_func_x96v2);
    p_c10419629                                = new GEN6_AT_OPTIONS(p_c10419629_master_stg,                      p_c10419622_func_x96v2);
    p_c10419630                                = new GEN6_AT_OPTIONS(p_c10419630_master_stg,                      p_c10419622_func_x96v2);
    p_c10485319                                = new GEN6_AT_OPTIONS(p_c10485319_master_stg,                      p_c10369958_func_x96v2);
    p_c10485321                                = new GEN6_AT_OPTIONS(p_c10485321_master_stg,                      p_c10369958_func_x96v2);
    p_c10645338                                = new GEN6_AT_OPTIONS(p_c187457_master_stg,
                                                                     p_cap_sensor_func_x96v2,
                                                                     p_c10288872_func_r6eco);
    p_c10634826                                = new GEN6_AT_OPTIONS(p_c10634826_master_stg,                      p_c10419622_func_x96v2);
    p_c10861710                                = new GEN6_AT_OPTIONS(p_c10861710_master_stg,                      p_c2198656_func_x96v2);
    p_c10861711                                = new GEN6_AT_OPTIONS(p_c10861711_master_stg,                      p_c2198656_func_x96v2);
    p_c10861712                                = new GEN6_AT_OPTIONS(p_c10861712_master_stg,                      p_c2198656_func_x96v2);
    p_c10861713                                = new GEN6_AT_OPTIONS(p_c10861713_master_stg,                      p_c2198656_func_x96v2);
    p_c10854614                                = new GEN6_AT_OPTIONS(p_c10854614_master_stg,                      p_c10854614_func_x96v2);
    p_c10854615                                = new GEN6_AT_OPTIONS(p_c10854615_master_stg,                      p_c10854614_func_x96v2);
    p_c10854594                                = new GEN6_AT_OPTIONS(p_c10854594_master_stg,                      p_c10854614_func_x96v2);
    p_c10854596                                = new GEN6_AT_OPTIONS(p_c10854596_master_stg,                      p_c10854614_func_x96v2);
    p_c10854607                                = new GEN6_AT_OPTIONS(p_c10854607_master_stg,                      p_c10854614_func_x96v2);
    p_c10854603                                = new GEN6_AT_OPTIONS(p_c10854603_master_stg,                      p_c10854614_func_x96v2);
    p_c10832739                                = new GEN6_AT_OPTIONS(p_c10832739_master_stg,                      p_analog_can_slave_func_x96v2);
    p_c10964449                                = new GEN6_AT_OPTIONS(p_c10964449_master_stg,                      p_c10964449_func_x96v2);
    p_c10964450                                = new GEN6_AT_OPTIONS(p_c10964450_master_stg,                      p_start_1_1_func_x96v2);
    p_c10634817                                = new GEN6_AT_OPTIONS(p_c10634817_master_stg,                      p_analog_can_slave_func_x96v2);
    p_c10415982                                = new GEN6_AT_OPTIONS(p_c170805_master_stg,                        p_video_reg_func_x96v2);
    p_c11110395                                = new GEN6_AT_OPTIONS(p_c11110395_master_stg,                      p_analog_can_slave_func_x96v2);
    p_c11846848                                = new GEN6_AT_OPTIONS(p_c11846848_master_stg,                      p_c2198656_func_x96v2);
    p_c11946743                                = new GEN6_AT_OPTIONS(p_c11946743_master_stg,                      p_c2198656_func_x96v2);
}

void AutoTestsModesP2::addCanBusActions(CanBusActions *canbus_actions)
{
    p_can1_act = canbus_actions;
}

bool AutoTestsModesP2::checkDtmfOwnerAccess(phones_t           phone,
                                            const char        *cmd,
                                            gsm_password_en_t  gsm_password_en,
                                            m2_owner_access_t  m2_owner_access,
                                            const char        *gsm_pass,
                                            dtmf_sending_t     dtmf_sending,
                                            gsm_waiting_cmd_t  gsm_waiting_cmd,
                                            float              time_s)
{
    Timer timer;

    float begin_time = 0.0f,
          time_left  = begin_time;
    bool  result     = true;

    setShieldPhone(phone);

    timer.start();
    begin_time = timer.read();

    p_gen6->getSim900()->resetCall(false);
    p_gen6->getSim900()->call(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1]);
    wait(TIME_DELAY::DTMF_INTERVAL_TIME_S);

    if (dtmf_sending == DTMF_SENDING_DIS)
    {
        time_left = timer.read() - begin_time;

        printf("INFO Ожидание окончания времени ожидания команд: %.2f\n", time_s - time_left);
        wait(time_s - time_left);
    }
    else
    {
        if (   (   (phone == M2)
                && (   (   !(m2_owner_access == GSM_M2_OWNER_ACCESS_EN) 
                        && !(gsm_password_en != GSM_PASS_EN))
                    || (   (gsm_password_en == GSM_PASS_EN)
                        && (m2_owner_access == GSM_M2_OWNER_ACCESS_EN))))
            || (phone == M3)
            || (phone == M4)
            || (   (phone == M1)
                && (gsm_password_en == GSM_PASS_EN)))
        {
            if (gsm_waiting_cmd == WAITING_PASS_DIS)
            {
                p_gen6->getSim900()->resetCall();
            }
            else if (p_gen6->getSim900()->sendDtmfTone(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                       gsm_pass,
                                                       strlen(gsm_pass)))
            {
                printf("INFO GSM пароль %s отправлен успешно\n", gsm_pass);
            }
            else
            {
                result = false;

                printf("INFO Ошибка при отправке GSM пароля\n");
                wait(TIME_DELAY::DTMF_INTERVAL_TIME_S);
                if (p_gen6->getSim900()->sendDtmfTone(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                      gsm_pass, strlen(gsm_pass)))
                {
                    result = true;
                }

            }

            wait(TIME_DELAY::DTMF_INTERVAL_TIME_S);
        }

        if (gsm_waiting_cmd == WAITING_CMD_DIS)
        {
            p_gen6->getSim900()->resetCall();
        }
        else
        {
            if ((dtmf_sending & DTMF_CMD_SENDING_EN) == DTMF_CMD_SENDING_EN)
            {
                if (p_gen6->getSim900()->sendDtmfTone(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1], cmd, strlen(cmd)))
                {
                    printf("INFO DTMF команда %s отправлена успешно\n", cmd);
                }
                else
                {
                    printf("INFO Ошибка при отправке DTMF\n");
                    wait(TIME_DELAY::DTMF_INTERVAL_TIME_S);
                    p_gen6->getSim900()->sendDtmfTone(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1], cmd, strlen(cmd));
                    result = false;
                }
            }
        }
    }

    p_gen6->getSim900()->resetCall();
    timer.stop();

    return result;
}

bool AutoTestsModesP2::setSecureZoneClosed(bool           secure_mode,
                                           command_type_t execution_method,
                                           float          check_time_s)
{
    std::string              log_message_pass;
    std::string              log_message_fail;
    slp_diag_data_statuses_t arm_state;


    if (secure_mode)
    {
        arm_state        = DIAG_GUARD_STATE_ARM;
        log_message_pass = "охрана включена";
        log_message_fail = "охрана не включена";
    }
    else
    {
        arm_state        = DIAG_GUARD_STATE_DISARM;
        log_message_pass = "охрана выключена";
        log_message_fail = "охрана не выключена";
    }

    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("INFO Дверь не закрыта\n");
        return false;
    }

    printf("INFO Дверь закрыта\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("INFO Багажник не закрыт\n");
        return false;
    }

    printf("INFO Багажник закрыт\n");

    if (!p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("INFO Капот не закрыт\n");
        return false;
    }

    printf("INFO Капот закрыт\n");


    if (!p_gen6->setAndCheckSecure(secure_mode,
                                   execution_method,
                                   arm_state,
                                   check_time_s))
    {
        printf("INFO Неправильное состояние охраны - %s\n", log_message_fail.c_str());
        return false;        
    }

    printf("INFO Состояние охраны соответствует ожидаемому - %s\n", log_message_pass.c_str());

    return true;
}

uint8_t AutoTestsModesP2::setAndCheckMergeZone(zone_name_t      zone_name,
                                               doors_statuses_t zone_new_state)
{
    uint8_t zone_state = 0;

    switch (zone_name)
    {
        case DOOR_IN:            
            p_gen6->setDoor(zone_new_state, PIN);
            break;

        case TRUNK_IN:   
            p_gen6->setTrunk(zone_new_state, PIN);
            break;

        case HOOD_IN:   
            p_gen6->setHood(zone_new_state, PIN);
            break;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_DOORS))
    {
        zone_state |= DIAG_PERIM_BIT_DOORS;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_TRUNK))
    {
        zone_state |= DIAG_PERIM_BIT_TRUNK;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_HOOD))
    {
        zone_state |= DIAG_PERIM_BIT_HOOD;
    }
    
    if ((zone_state & DIAG_PERIM_BIT_DOORS) == DIAG_PERIM_BIT_DOORS)
    {
        printf("INFO Дверь открыта\n");        
    }
    else
    {
        printf("INFO Дверь закрыта\n");         
    }

    if ((zone_state & DIAG_PERIM_BIT_TRUNK) == DIAG_PERIM_BIT_TRUNK)
    {
        printf("INFO Багажник открыт\n");        
    }
    else
    {
        printf("INFO Багажник закрыт\n");         
    }

    if ((zone_state & DIAG_PERIM_BIT_HOOD) == DIAG_PERIM_BIT_HOOD)
    {
        printf("INFO Капот открыт\n");        
    }
    else
    {
        printf("INFO Капот закрыт\n");         
    }

    return zone_state;
}

bool AutoTestsModesP2::setAndCheckInitCanStateForRemoteRun()
{
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Зажигание не включено\n");
        return false;
    }

    p_gen6->setHandBreak(ON, CAN_USE);
    p_gen6->setParking(ON, CAN_USE);

    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Зажигание не выключено\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::setAhjTestsStartConditions(ign_statuses_t enable_ign,
                                                  command_type_t set_ign_execution_method,
                                                  uint8_t        can_speed)
{
    p_gen6->setSecure(ON, KEYRING);  // Постановка + снятие чтобы избежать отключения защитных функций на 1 цикл охраны после кода экстр. снятия
    p_gen6->setSecure(OFF, KEYRING);

    p_gen6->setHandBreak(OFF, PIN);

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);
    }

    p_gen6->setDoor(CLOSE, PIN);
    p_gen6->setHood(CLOSE, PIN);
    p_gen6->setTrunk(CLOSE, PIN);
    p_can1_act->sendSpeed(can_speed);
    p_gen6->setIgn(set_ign_execution_method, enable_ign);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
}

bool AutoTestsModesP2::checkAhjTestsStepLast()
{
    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_OFF, TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Антиограбление по брелку не выключено \n");
        return false;
    }
    else
    {
        printf("PASS Антиограбление по брелку выключено \n");
    }

    if (!p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Блокировка выключена\n");
    }
    else
    {
        printf("FAIL Блокировка не выключена\n");
        return false;
    }

    p_gen6->checkAlarm(OFF);

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Охрана выключена\n");
    }
    else
    {
        printf("FAIL Охрана не выключена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckBleSettingsModeOn(bool check_btn_lights, ign_statuses_t ign_status_after_check)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return false;
    }

    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль в \"Снято с охраны\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в \"Снято с охраны\"\n");
        return false;
    }

    /*!
        Шаг 1. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом
    */
    for (uint8_t i = 0; i < COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Вход в режим настройки по BLE
        Сервисный светодиод начал постоянно моргать
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return false;
    }

    if (check_btn_lights)
    {
        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT,
                                           TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Шаг 2. 9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE\n");
        }
        else
        {
            printf("FAIL Шаг 2. Нет 9-кратного подтверждения сервисным светодиодом\n");
            return false;
        }    

        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                           TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Шаг 2. 2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки\n");
        }
        else
        {
            printf("FAIL Шаг 2. Нет 2-кратного подтверждения сервисным светодиодом\n");
            return false;
        }
    }
    else
    {
        wait(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_BLE_UPDATER,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Вход в режим настройки по BLE\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не выполнен вход в режим настройки по BLE\n");
        return false;
    }

    if (check_btn_lights)
    {
        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_ALWAYS_BLINK_LED_LIGHTS_COUNT,
                                           TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Шаг 2. Сервисный светодиод начал постоянно моргать\n");
        }
        else
        {
            printf("FAIL Шаг 2. Сервисный светодиод не начал постоянно моргать\n");
            return false;
        }
    }
    else
    {
        wait(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);
    }

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
    */
    if (ign_status_after_check == IGN_OFF)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 3. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не выключено\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckArmAndDisarm()
{
    bool result = true;


    /*!
        Начальные условия
    */
    /*!
        Охрана включена
        Метка включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        result = false;
    }

    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    /*!
        Выключить охрану приложением
    */
    /*!
        Охрана выключена
    */
    if (result)
    {
        if (p_gen6->setAndCheckSecure(OFF,
                                      MOBILE,
                                      DIAG_GUARD_STATE_DISARM))
        {
            printf("PASS Шаг 1. Охрана выключена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана не выключена\n");
            result = false;
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_auth_no_tag_needed) == 0)
    {
        printf("FAIL Ошибка при загрузке настроек через StarLine Мастер\n");
    }

    return result;
}

bool AutoTestsModesP2::setAndResetServiceModeBySpeed(int8_t speed_kmph)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Сервис
        ||Дверь:                             | закрыта
        ||ПН:                                | не выполнена
        ||Метка:                             | включена
        ||Брелок:                            | включен (при авторизации по брелку, иначе не имеет значения)
        ||Скорость:                          | 0
        ||Ручник:                            | выключен
        ||Зажигание:                         | включено
        ||Двигатель:                         | заведен
    */
    p_gen6->setSpeed(0);

    if (p_gen6->setAndCheckDoor(OFF, PIN))
    {
        printf("PASS Начальные условия. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не закрыта\n");
        return false;
    }

    // Поставить в сервис меткой/брелком и оставить метку/брелок включенными
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setServiceModeTag(ON);
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }
    else if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
        p_gen6->setLcdKeyringVcc(ON);
        wait(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }
    else
    {
        printf("FAIL Нет метки и брелка для включения сервиса и авторизации\n");
        return false;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_SERVICE))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
    }

    p_gen6->setRpm(RPM_ON, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Начальные условия. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Двигатель не заведен\n");
        return false;
    }

    /*!
        Шаг 1. Повысить скорость до 35 км/ч
    */
    /*!
        Скорость повысилась с 0 до 35 км/ч
        Сервис активен
    */
    p_gen6->setSpeed(speed_kmph);

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Сервис отключен
        Переход в снято (Пройдена авторизация по метке)
    */
    wait(TIME_DELAY::FIVE_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Сервисный режим выключен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не выключен\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Переход в снято (Пройдена авторизация по метке)\n");
    }
    else
    {
        printf("FAIL Шаг 2. Система не в \"Снято с охраны\"\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setSensorAndCheckRearm(slp_diag_data_sensors_statuses_t sensor_type)
{
    Timer rearm_timer; // Таймер перепостановки, запускается при снятии с охраны


    if (m_rearm_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до перепостановки, сек\" не задана\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Дверь:            | закрыта
        ||Багажник:         | закрыт
    */
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Багажник не закрыт\n");
        return false;
    }

    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Дверь закрыта\n");
    }
    else
    {
        printf("PASS Начальные условия. Дверь не закрыта\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return false;
    }

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Охрана отключена
    */
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setSecure(OFF,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }
    else if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        // Не используется setSecure() т.к. там есть задержка после нажатия кнопки метки
        p_gen6->setTagVcc();
        wait(TIME_DELAY::DELAY_AFTER_TAG_VCC_EN_S);
        p_gen6->pushTagBtn(TAG_SHORT);
    }

    rearm_timer.start();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Охрана отключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не отключена\n");
        return false;
    }

    /*!
        Шаг 2. Вызвать срабатывание датчика
    */
    /*!
        Сработал датчик
        Через время, указанное в настройке 'Время до перепостановки', после отключения охраны - охрана включена (перепостановка сработала)
    */
    p_gen6->setSensor(sensor_type);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                m_rearm_delay_s - rearm_timer.read() - TIME_DELAY::STD_ERROR_TIME_S))
    {
        printf("PASS Шаг 2. Перепостановка не произошла раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 2. Перепостановка произошла раньше времени\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Перепостановка сработала\n");
    }
    else
    {
        printf("FAIL Шаг 2. Перепостановка не сработала\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setArmAndDisarmAndCheckImmo(command_type_t execution_method,
                                                   tag_statuses_t tag_status)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:        | выключено
        ||Обороты:          | выключены
        ||Автомобиль:       | в охране
        ||Метка:            | выключена/включена
    */
    if (tag_status)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }
    else
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  execution_method,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return false;
    }

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход из Охраны в Запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не выполнен переход в Запрет поездки\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setArmAndDisarmAndCheckImmoAndSetIgn(command_type_t execution_method,
                                                            tag_statuses_t tag_status)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:        | выключено
        ||Обороты:          | выключены
        ||Автомобиль:       | в охране
        ||Метка:            | выключена/включена
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(execution_method,
                                     tag_status))
    {
        printf("FAIL Шаг 1\n");
        return false;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Запрет поездки остался активным/выключился
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return false;
    }

    switch (tag_status)
    {
        case TAG_ON:

            if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                       ON,
                                       TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
            {
                printf("PASS Шаг 2. Переход из запрета поездки в снято\n");
            }
            else
            {
                printf("FAIL Шаг 2. Переход из запрета поездки в снято не произведен\n");
                return false;
            }

            break;

        case TAG_OFF:

            if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                        OFF,
                                        TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
            {
                printf("PASS Шаг 2. Запрет поездки остался активным\n");
            }
            else
            {
                printf("FAIL Шаг 2. Запрет поездки не остался активным\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестное состояние метки: %d\n", tag_status);
            return false;
    }

    return true;
}

bool AutoTestsModesP2::setRemoteRunAndStopAndDisarm(Timer &eng_stop_timer, float delay_after_doors_imit_s)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Дверь:            | закрыта
        ||ПН:               | выполнена
    */

    // Включаем метку чтобы без задержки включать/выключать охрану меткой
    // (метод setSecure по метке делает это долго, т.к. присутствуют включения/отключения метки и ожидания статусов по SLP)
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    p_gen6->setProgramNeutral(KEYRING,
                              m_program_neutral_type,
                              m_sup_ign_var,
                              m_engine_start_system,
                              m_gearbox_type,
                              IGN_OFF,
                              TIME_DELAY::MAX_DELAY_AFTER_PROGRAM_NEUTRAL_S);

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->pushTagBtn(TAG_SHORT);
    }
    else
    {
        p_gen6->setSecure(ON,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return false;
    }

    p_gen6->checkProgramNeutral(ON);

    /*!
        Шаг 1. Произвести ДЗ двигателя (командой с брелока)
    */
    /*!
        Начался ДЗ:
        Подан потенциал на выход обходчика
        Подан потенциал на имитацию педали тормоза
        Подан потенциал на кнопку старт-стоп
    */

    /*!
        Шаг 2. Включить двигатель (зажигание+обороты) в момент активной кнопки старт-стоп
    */
    /*!
        Выполниен ДЗ
        Двигатель работает
        Охрана включена
    */
    p_gen6->runEngine(KEYRING, m_engine_start_system);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 2. Двигатель работает\n");
    }
    else
    {
        printf("FAIL Шаг 2. Двигатель не работает\n");
        return false;
    }

    /*!
        Шаг 3. Произвести дистанционное глушение двигателя (командой с брелока)
    */
    /*!
        Выполнены попытки глушения двигателя кнопкой старт-стоп (3 импульса старт-стоп)
    */
    p_gen6->setRemoteStop(KEYRING);
    p_gen6->checkEngineStop(m_engine_start_system,
                            STOP_AFTER_THIRD_IMPULSE_RECV,
                            TIME_DELAY::STOP_ENG_ERROR_TIME_S);

    /*!
        Шаг 4. В течение 3х импульсов заглушить двигатель (выключить зажигание)
    */
    /*!
        Двигатель заглушен
        Через время, указанное в 'Задержка перед началом имитации и игнорированием открытия дверей после остановки двигателя', после глушения двигателя на выход Имитации открытия двери подан потенциал
    */
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 4. Двигатель заглушен\n");
        eng_stop_timer.start();
    }
    else
    {
        printf("FAIL Шаг 4. Двигатель не заглушен\n");
        return false;
    }

    p_gen6->setPolarity(ID_OUT_DOORS_IMIT); // Установить измеритель длины импульса на имитацию дверей

    if (!p_gen6->waitImitDoors(m_doors_imit_delay_s - TIME_DELAY::DOORS_IMIT_ERROR_TIME_S, p_gen6->getPolarity(ID_OUT_DOORS_IMIT)))
    {
        printf("PASS Шаг 4. Потенциал на выход Имитации открытия двери не подан раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 4. Потенциал на выход Имитации открытия двери подан раньше времени\n");
        return false;
    }

    if (p_gen6->waitImitDoors(TIME_DELAY::DOORS_IMIT_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S, p_gen6->getPolarity(ID_OUT_DOORS_IMIT)))
    {
        printf("PASS Шаг 4. На выход Имитации открытия двери подан потенциал\n");
    }
    else
    {
        printf("FAIL Шаг 4. На выход Имитации открытия двери не подан потенциал\n");
        return false;
    }

    /*!
        Шаг 5. Через delay_after_doors_imit_s сек после начала имитации открытия двери - выключить охрану
    */
    /*!
        Охрана отключена
    */
    wait(delay_after_doors_imit_s);

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->pushTagBtn(TAG_SHORT);
    }
    else
    {
        p_gen6->setSecure(OFF,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 5. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана не выключена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setServiceAndSpeedAndSensor(tag_statuses_t tag_status,
                                                   int8_t         speed_kmph,
                                                   float          delay_before_sensor_s)
{
    slp_diag_data_statuses_t guard_status; // Состояние охраны после выхода из сервиса
    string                   guard_msg;    // Состояние охраны в текстовом виде


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Нет модуля для работы с меткой\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:        | включено
        ||Обороты:          | выключены
        ||Скорость:         | 0 км/ч
        ||Автомобиль в:     | Сервисный режим
        ||Метка:            | включена/выключена
    */
    p_gen6->setSpeed(0);
    p_gen6->setServiceModeTag(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Система в состоянии \"Сервисный режим\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в состоянии \"Сервисный режим\"\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return false;
    }

    if (tag_status)
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

        // При выходе с сервиса с вкл. меткой система будет в 'Снято с охраны'
        guard_msg    = "\"Снято с охраны\"";
        guard_status = DIAG_GUARD_STATE_DISARM;
    }
    else
    {
        p_gen6->resetTagVcc();
        wait(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

        // При выходе с сервиса с выкл. меткой система будет в 'Ожидание авторизации'
        guard_msg    = "\"Ожидание авторизации\"";
        guard_status = DIAG_GUARD_STATE_WAITING_AUTH;
    }

    /*!
        Включить скорость speed_kmph
    */
    /*!
        Скорость: speed_kmph
    */
    p_gen6->setSpeed(speed_kmph);

    /*!
        Через delay_before_sensor_s сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Снято/Ожидание авторизации (в зависимости от состояния метки)
    */
    wait(delay_before_sensor_s);
    p_gen6->setMoveSensor();

    if (p_gen6->waitGuardState(guard_status,
                               ON,
                               TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Система в состоянии %s\n", guard_msg.c_str());
    }
    else
    {
        printf("FAIL Шаг 2. Система не в состоянии %s\n", guard_msg.c_str());
        return false;
    }

    /*!
        Включить метку (если выключалась для перехода в Ожидание авторизации после сервиса)
    */
    /*!
        Метка обнаружена
        Переход из Ожидания авторизации в Снято (прошла авторизация по метке)
    */
    if (!tag_status)
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Система в состоянии \"Снято с охраны\"\n");
        }
        else
        {
            printf("FAIL Шаг 3. Система не в состоянии \"Снято с охраны\"\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setR6VccAndSecureAndIgnOff(secure_cmd_t secure_status)
{
    const string             status_on  = "включена";  // Сообщение если требуется включить охрану
    const string             status_off = "выключена"; // Сообщение если требуется отключить охрану
    string                   status;                   // Сообщение состояния охраны в зависимости от параметра arm_status
    slp_diag_data_statuses_t diag_status;              // Проверяемое состояние системы в зависимости от параметра arm_status


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с R6\n");
        return false;
    }

    if (secure_status == SECURE_CMD_ON)
    {
        status      = status_on;
        diag_status = DIAG_GUARD_STATE_ARM;
    }
    else
    {
        status      = status_off;
        diag_status = DIAG_GUARD_STATE_DISARM;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Снято с охраны
        ||Зажигание:        | выключено
        ||R6:               | включен
    */
    p_gen6->resetR6Ign();

    // Включить R6 и ожидать его инициализации
    if (!p_gen6->getR6Vcc())
    {
        p_gen6->setR6Vcc();
        p_gen6->wait_s(TIME_DELAY::R6_INIT_WAIT_TIME_S);
    }

    p_gen6->wait_s(TIME_DELAY::R6_SETTINGS_EN_WAIT_TIME_S);

    p_gen6->setEngine(OFF,
                      PIN,
                      RPM_OFF);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(secure_status,
                                  KEYRING,
                                  diag_status))
    {
        printf("PASS Начальные условия. Охрана %s\n", status.c_str());
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не %s\n", status.c_str());
        return false;
    }

    p_gen6->wait_s(TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S); // Ждем срабатывания сигналов от начальных условий,
                                                          // чтобы не помешало дальнейшим шагам теста

    return true;
}

bool AutoTestsModesP2::resetAndSetGen6VccAndCheckR6Block(float delay_s)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с R6\n");
        return false;
    }

    /*!
        Шаг 1. Выключить питание ЦБ (имитация потери связи с ЦБ)
    */
    /*!
        Питание ЦБ выключено
        Связь R6 с ЦБ потеряна
    */
    p_gen6->off();

    /*!
        Шаг 2. Через delay_s секунд включить питание ЦБ
    */
    /*!
        Связь с ЦБ восстановлена
        Блокировка R6 не включилась
    */
    if (!waitR6Block(ON, delay_s + TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
        return false;
    }

    p_gen6->on();

    if (!waitR6Block(ON, TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setIgnAndEngineAndCheckR6Block(ign_statuses_t   ign_status,
                                                      eng_statuses_t   eng_status,
                                                      block_statuses_t block_status)
{
    float base_check_time_s = TIME_DELAY::STD_RPM_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S; // Время проверки состояния блокировки вкл/выкл
    float long_check_time_s = base_check_time_s + TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S;             // Время проверки состояния блокировки не вкл/не выкл


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с R6\n");
        return false;
    }

    // Включить/выключить зажигание
    p_gen6->setIgn(PIN,
                   ign_status,
                   TIME_DELAY::NULL_DELAY_S);

    // Включить/выключить обороты
    p_gen6->setEngine(eng_status,
                      PIN,
                      RPM_ON,
                      TIME_DELAY::NULL_DELAY_S);

    // Проверить состояние блокировки (НЗ)
    switch (block_status)
    {
        case BLOCK_ON:

            if (waitR6Block(ON, base_check_time_s))
            {
                printf("PASS Блокировка R6 включена\n");
            }
            else
            {
                printf("FAIL Блокировка R6 не включена\n");
                return false;
            }

            break;

        case BLOCK_OFF:

            if (waitR6Block(OFF, base_check_time_s))
            {
                printf("PASS Блокировка R6 выключена\n");
            }
            else
            {
                printf("FAIL Блокировка R6 не выключена\n");
                return false;
            }

            break;

        case BLOCK_NOT_ON:

            if (!waitR6Block(ON, long_check_time_s))
            {
                printf("PASS Блокировка R6 не включилась\n");
            }
            else
            {
                printf("FAIL Блокировка R6 включилась\n");
                return false;
            }

            break;

        case BLOCK_NOT_OFF:

            if (!waitR6Block(OFF, long_check_time_s))
            {
                printf("PASS Блокировка R6 не выключилась\n");
            }
            else
            {
                printf("FAIL Блокировка R6 выключилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неопределенный тип проверки блокировки R6 (НЗ)\n");
            return false;
    }

    return true;
}

bool AutoTestsModesP2::setSecureAndCheckR6Block(secure_cmd_t     secure_status,
                                                block_statuses_t block_status)
{
    float check_time_s = TIME_DELAY::MAX_REMOTE_STATUS_EN_TIME_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S; // Время проверки блокировки


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с R6\n");
        return false;
    }

    // Изменить состояние охраны
    p_gen6->setSecure(secure_status,
                      KEYRING,
                      TIME_DELAY::NULL_DELAY_S);

    // Проверить состояние блокировки (НР)
    switch (block_status)
    {
        case BLOCK_OFF:
            
            if (waitR6Block(OFF, check_time_s))
            {
                printf("PASS Шаг 1. Блокировка R6 выключена\n");
            }
            else
            {
                printf("FAIL Шаг 1. Блокировка R6 не выключена\n");
                return false;
            }
            
            break;
            
        case BLOCK_ON:
            
            if (waitR6Block(ON, check_time_s))
            {
                printf("PASS Шаг 1. Блокировка R6 включена\n");
            }
            else
            {
                printf("FAIL Шаг 1. Блокировка R6 не включена\n");
                return false;
            }
            
            break;
            
        case BLOCK_NOT_OFF:
            
            if (!waitR6Block(OFF, check_time_s))
            {
                printf("PASS Шаг 1. Блокировка R6 не выключилась\n");
            }
            else
            {
                printf("FAIL Шаг 1. Блокировка R6 выключилась\n");
                return false;
            }
            
            break;

        default:
            printf("FAIL Неопределенный тип проверки блокировки R6 (НР)\n");
            return false;
    }

    return true;
}

bool AutoTestsModesP2::setSecureAndTrunkAndCheckAlarm(tag_statuses_t    tag_status,
                                                      remote_statuses_t remote_status,
                                                      alert_statuses_t  alert_status)
{
    Timer timer;                                                                    // Таймер для подсчета времени чтения по SLP и сопутствующих задержек
    float trunk_check_time_s = TIME_DELAY::NULL_DELAY_S;                            // Время, потраченное на открытие багажника
    bool  is_ble             = (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE;  // Проверить наличие BLE модуля
    bool  is_r868            = (p_gen6->getModules() & R868_MODULE) == R868_MODULE; // Проверить наличие R868 модуля


    if (   m_is_tag_rem_for_trunk_needed == SLM_SETTINGS_STATE::INT_SLM_SETTING_NOT_FOUND
        || m_trunk_tag_rem_wait_time_s   == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки режима \"Охрана с открытым багажником\" были заданы\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Багажник:         | закрыт
        ||Метка:            | включена/выключена (в зависимости от параметров)
        ||Брелок:           | включен/выключен   (в зависимости от параметров)
    */
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Багажник не закрыт\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return false;
    }

    // Включить/выключить метку
    if (tag_status == TAG_ON)
    {
        // Включение только при наличии BLE модуля
        if (is_ble)
        {
            if (p_gen6->setAndCheckTag(ON))
            {
                printf("PASS Начальные условия. Метка включена\n");
            }
            else
            {
                printf("FAIL Начальные условия. Метка не включена\n");
                return false;
            }
        }
        else
        {
            printf("FAIL Нет модуля для работы с метками\n");
            return false;
        }
    }
    else
    {
        if (is_ble)
        {
            p_gen6->setAndCheckTag(OFF);
        }
        // Если нет BLE модуля, то мы просто не будем пытаться выключать метку, она уже 'выключена'
        // Поэтому выводить FAIL не нужно
    }

    // Включить/выключить брелок
    if (remote_status == REMOTE_ON)
    {
        // Включение только при наличии R868 модуля
        if (is_r868)
        {
            p_gen6->setLcdKeyringVcc(ON);
            wait(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
        }
        else
        {
            printf("FAIL Нет модуля для работы с брелками\n");
            return false;
        }
    }
    else
    {
        if (is_r868)
        {
            p_gen6->setLcdKeyringVcc(OFF);
            wait(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
        }
        // Если нет R868 модуля, то мы просто не будем пытаться выключать брелок, он уже 'выключен'
        // Поэтому выводить FAIL не нужно
    }

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Тревога включена или отключена (в зависимости от параметров)
    */
    timer.start();

    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return false;
    }

    trunk_check_time_s = timer.read();

    // Проверка тревоги
    if (alert_status == ALERT_ON) // Тревога включилась
    {
        if (m_is_tag_rem_for_trunk_needed) 
        {
            // Если задана настройка "Разрешить в охране открытие багажника при наличии метки или брелока",
            // то сначала мы проверяем что тревога не сработала раньше времени (т.к. это время поиска метки/брелока)
            if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                          SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                          DIAG_GUARD_STATE_ALERT_MAIN,
                                          ON,
                                          (m_trunk_tag_rem_wait_time_s - trunk_check_time_s) - TIME_DELAY::ALARM_EN_ERROR_TIME_S)) // Вычитаем время, потраченное на открытие багажника и ошибку наступления тревоги
            {
                printf("PASS Шаг 1. Тревога не включилась раньше времени\n");
            }
            else
            {
                printf("FAIL Шаг 1. Тревога включилась раньше времени\n");
                return false;
            }
        }

        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                     SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                     DIAG_GUARD_STATE_ALERT_MAIN,
                                     ON,
                                     TIME_DELAY::ALARM_EN_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("PASS Шаг 1. Тревога включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Тревога не включена\n");
            return false;
        }
    }
    else // Тревога не включилась
    {
        // Не позднее 10 секунд включилась охрана с открытым багажником
        // 10 секунд - время взятое с запасом (не зависит от настроек Мастера):
        // Если открывать багажник с вкл. меткой/брелком, то они могут определиться не сразу
        // Но на их нахождение система выделяет 3-5 секунд времени (в Мастере не задается, подробнее: 6-й комментарий TA-95)
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MAX_ARM_TRUNK_EN_DELAY_S + TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Шаг 1. Включена охрана с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 1. Не включена охрана с открытым багажником\n");
            return false;
        }

        if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                     SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                     DIAG_GUARD_STATE_ALERT_MAIN))
        {
            printf("PASS Шаг 1. Тревога не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 1. Тревога включилась\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setTagAndRemoteAndCheckAlarm(tag_statuses_t    tag_status,
                                                    remote_statuses_t remote_status,
                                                    alert_statuses_t  alert_status)
{
    /*!
        Шаг 2. Включить брелок/метку (в зависимости от параметров)
    */
    /*!
        Брелок/метка обнаружена
        Тревога выключилась/не выключилась (в зависимости от параметров)
    */

    // Включить метку (только при наличии BLE модуля)
    if (tag_status == TAG_ON)
    {
        if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
        {
            p_gen6->setTagVcc();
            wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        }
        else
        {
            printf("FAIL Нет модуля для работы с метками\n");
            return false;
        }
    }

    // Включить брелок (только при наличии R868 модуля)
    if (remote_status == REMOTE_ON)
    {
        if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
        {
            p_gen6->setLcdKeyringVcc(ON);
            wait(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
        }
        else
        {
            printf("FAIL Нет модуля для работы с брелками\n");
            return false;
        }
    }

    // Проверка тревоги
    if (alert_status == ALERT_ON) // Тревога не выключилась
    {
        if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                      SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                      DIAG_GUARD_STATE_ALERT_MAIN,
                                      OFF,
                                      m_trunk_tag_rem_wait_time_s + TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Шаг 2. Тревога не выключилась\n");
        }
        else
        {
            // Может быть пауза между полуциклами тревоги, ждем возобновления
            // Если тревога не возобновилась - FAIL
            if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                        ON,
                                        TIME_DELAY::ALARM_DIS_PAUSE_TIME_S,
                                        TIME_DELAY::MIN_WAITING_REGION_STATE_S))
            {
                printf("FAIL Шаг 2. Тревога выключилась\n");
                return false;
            }
        }
    }
    else // Тревога выключилась
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   m_trunk_tag_rem_wait_time_s + TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Шаг 2. Включена охрана с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 2. Не включена охрана с открытым багажником\n");
            return false;
        }

        if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                     SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                     DIAG_GUARD_STATE_ALERT_MAIN))
        {
            printf("PASS Шаг 2. Тревога выключилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога не выключилась\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setCarMercedesClaAndSecure()
{
    // Установить скорость CAN и ACK-лки
    if (!setCanBusSpeed(CAN_125K))
    {
        printf("FAIL При смене настроек скорости CAN\n");
        return false;
    }

    // Закрыть все зоны и встать в охрану
    if (setSecureZoneClosed(ON, KEYRING))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setStdAlertOffAndCarBatmobile()
{
    bool result = true;


    // Выключить штатную тревогу
    // Если был послан пакет включения, но не было пакета выключения
    // То каждая постановка в охрану будет охраной с нарушенным периметром
    p_gen6->setStdAlertMercedesCla(OFF);
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    // Выключить тревогу/охрану ЦБ перед сменой настроек
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->setSecure(OFF, KEYRING);

    // Настроить скорость CAN и ACK-лки
    if (!setCanBusSpeed(CAN_500K))
    {
        printf("FAIL При смене скорости CAN\n");
        result = false;
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При сбросе настроек CAN\n");
        result = false;
    }

    return result;
}

bool AutoTestsModesP2::setAndCheckStdAlarm(alarm_check_type_t alarm_check_type)
{
    /*!
        Шаг 1. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */
    p_gen6->setStdAlertMercedesCla(ON);

    // Проверить тревогу
    switch (alarm_check_type)
    {
        // Проверить начало тревоги (вкл. сирены и света), не дожидаясь конца
        case ALARM_CHECK_TYPE_START:

            if (checkForAlarm(ON,
                              CHECK_NOSMSCALL,
                              ALLSTEPS))
            {
                printf("PASS Шаг 1. Тревога включилась\n");
            }
            else
            {
                printf("FAIL Шаг 1. Тревога не включилась\n");
                return false;
            }

            break;

        // Проверить 0,5 цикла тревоги
        case ALARM_CHECK_TYPE_HALF:

            if (checkForAlarmFull())
            {
                printf("PASS Шаг 1. 0,5 цикла тревоги пройдено\n");
            }
            else
            {
                printf("FAIL Шаг 1. 0,5 цикла тревоги не пройдено\n");
                return false;
            }

            break;

        // Проверить и дождаться окончание полного цикла тревоги
        case ALARM_CHECK_TYPE_FULL:

            if (checkForReloadAlarm())
            {
                printf("PASS Шаг 1. Цикл тревоги пройден\n");
            }
            else
            {
                printf("FAIL Шаг 1. Цикл тревоги не пройден\n");
                return false;
            }

            break;

        default:
            printf("FAIL Тип проверки тревоги неизвестен: %d\n", alarm_check_type);
            return false;
    }

    /*!
        Шаг 2. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */
    p_gen6->setStdAlertMercedesCla(OFF);

    if (alarm_check_type == ALARM_CHECK_TYPE_FULL)
    {
        // Конец цикла был, тревога уже должна быть выключена
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    TIME_DELAY::ALARM_DIS_CHECK_TIME_S))
        {
            printf("PASS Шаг 2. Тревога не возобновилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога возобновилась после выключения штаткой\n");
            return false;
        }
    }
    else
    {
        // Если мы не ждали конца цикла, то тревога должна выключиться через/в течение 30 секунд после выкл. штатной тревоги
        if (waitForAlarmOff(TIME_DELAY::ALARM_DIS_TIME_S + TIME_DELAY::ALARM_DIS_ERROR_TIME_S))
        {
            printf("PASS Шаг 2. Тревога выключилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога не выключилась\n");
            return false;
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckStdAlarmFull(alarm_check_type_t alarm_check_type)
{
    Timer block_timer; // Таймер начала блокировки


    /*!
        Шаг 1. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */

    /*!
        Шаг 2. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */

    /*!
        Шаг 3. Повторить 7 раз шаги 1,2
    */
    /*!
        Результаты те же, что и в шагах 1,2
    */
    for (uint8_t i = 0; i < 8; i++)
    {
        // Печатаем повторы только 1-7, первый запуск не должен быть помечен как повтор
        if (i > 0)
        {
            printf("INFO %d-й повтор шагов 1, 2\n", i);
        }

        if (!setAndCheckStdAlarm(alarm_check_type))
        {
            printf("FAIL Шаг 1-3\n");
            return false;
        }
    } // for

    /*!
        Шаг 4. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включена блокировка
    */
    p_gen6->setStdAlertMercedesCla(ON);

    if (p_gen6->waitBlock(TIME_DELAY::MAX_STD_BLOCK_WAIT_TIME_S))
    {
        block_timer.start();

        printf("PASS Шаг 4. Включена блокировка\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return false;
    }

    if (!p_gen6->waitLightAndAlarm(TIME_DELAY::ALARM_DIS_CHECK_TIME_S))
    {
        printf("PASS Шаг 4. Световые и звуковые сигналы отсутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 4. Присутствуют световые и звуковые сигналы\n");
        return false;
    }

    /*!
        Шаг 5. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения блокировка выключается
    */
    p_gen6->setStdAlertMercedesCla(OFF);

    if (p_gen6->waitBlock(TIME_DELAY::ALARM_DIS_TIME_S - block_timer.read(),
                          TIME_DELAY::ALARM_DIS_ERROR_TIME_S,
                          OFF))
    {
        printf("PASS Шаг 5. Блокировка выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Блокировка не выключилась\n");
        return false;
    }

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Охрана отключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Шаг 6. Охрана отключена\n");
    }
    else
    {
        printf("FAIL Шаг 6. Охрана не отключена\n");
        return false;
    }

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Охрана включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 7. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 7. Охрана не включена\n");
        return false;
    }

    /*!
        Шаг 8. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */
    p_gen6->setStdAlertMercedesCla(ON);

    if (checkForAlarm(ON,
                      CHECK_NOSMSCALL,
                      ALLSTEPS))
    {
        printf("PASS Шаг 8. Тревога включилась\n");
    }
    else
    {
        printf("FAIL Шаг 8. Тревога не включилась\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckAhj(command_type_t execution_method)
{
    // Проверка наличия соответствующих модулей перед включением
    switch (execution_method)
    {
        case SMS:
        case DTMF:

            if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
            {
                printf("FAIL Отсутствует GSM модуль\n");
                return false;
            }

            break;

        case TAG:

            if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
            {
                printf("FAIL Отсутствует BLE модуль\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный источник команды\n");
            return false;
    }

    // Включение режима
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Охрана выключена\n");
    }
    else
    {
        printf("FAIL Охрана не выключена\n");
        return false;
    }

    p_gen6->onAntiHijacking(execution_method);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK,
                                 ON,
                                 m_ahj_wait_time_s))
    {
        printf("PASS Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Антиограбление не включено\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckArmTrunk()
{
    // Проверка наличия соответствующих модулей перед включением
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с брелками\n");
        return false;
    }

    // Включение режима
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Охрана включена\n");
    }
    else
    {
        printf("FAIL Охрана не включена\n");
        return false;
    }

    p_gen6->unlockTrunk(KEYRING);

    if (p_gen6->setAndCheckTrunk(OPEN,
                                 PIN,
                                 NORMAL,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Багажник открыт\n");
    }
    else
    {
        printf("FAIL Багажник не открыт\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                               ON,
                               TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Охрана с открытым багажником включена\n");
    }
    else
    {
        printf("FAIL Охрана с открытым багажником не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckWaitingAuth()
{
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Охрана включена\n");
    }
    else
    {
        printf("FAIL Охрана не включена\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Ожидание авторизации включено\n");
    }
    else
    {
        printf("FAIL Ожидание авторизации не включено\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckImmo()
{
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Охрана включена\n");
    }
    else
    {
        printf("FAIL Охрана не включена\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Запрет поездки включен\n");
    }
    else
    {
        printf("FAIL Запрет поездки не включен\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckAlertHigh()
{
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Охрана включена\n");
    }
    else
    {
        printf("FAIL Охрана не включена\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Зажигание включено\n");
    }
    else
    {
        printf("FAIL Зажигание не включено\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::ALARM_EN_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Тревога (основная) включена\n");
    }
    else
    {
        printf("FAIL Тревога (основная) не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckAlertLow()
{
    // Проверка наличия соответствующих настроек перед активацией предупредительной тревоги
    if (m_sensors_mask_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не задана настройка \"Время игнорирования датчиков после взятия системы под охрану\"\n");
        return false;
    }

    // Включение тревоги
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Охрана включена\n");
    }
    else
    {
        printf("FAIL Охрана не включена\n");
        return false;
    }

    wait(m_sensors_mask_time_s + TIME_DELAY::SENSOR_MASK_ERR_TIME_S); // Ожидание окончания маскирования датчиков
    p_gen6->setShockSensorLow();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_NOTICE,
                               ON,
                               TIME_DELAY::ALARM_EN_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Тревога (предупредительная) включена\n");
    }
    else
    {
        printf("FAIL Тревога (предупредительная) не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setSecureOnAndTagVccAndRemoteVcc(bool status)
{
    const float tag_visible_time_s      = TIME_DELAY::MAX_TAG_VISIBLE_TIME_S;                          // Время появления метки
    const float tag_invisible_time_s    = TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S;                        // Время исчезновения метки

    const float remote_visible_time_s   = TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;                       // Время появления брелка
    const float remote_invisible_time_s = TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S;                     // Время исчезновения брелка

    const float delay_s                 = status ? max(tag_visible_time_s, remote_visible_time_s)      // Задержка после управления питанием
                                                 : max(tag_invisible_time_s, remote_invisible_time_s);


    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        status ? p_gen6->setTagVcc()
               : p_gen6->resetTagVcc();
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(status);
    }

    // Ожидание появления необходимого статуса в системе (пропажа/появление)
    p_gen6->wait_s(delay_s);

    return true;
}

bool AutoTestsModesP2::openTrunkAndCheckAlarm(alert_statuses_t alert_status)
{
    float auth_trunk_err_time_s; // Ошибка времени поиска метки и брелока при открытом багажнике


    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не задана настройка \"Время поиска метки и брелока при открытом багажнике\"\n");
        return false;
    }

    auth_trunk_err_time_s = TimeoutCalculator::calcToutError(m_trunk_tag_rem_wait_time_s, PERCENT::FIVE_PERCENT);

    switch (alert_status)
    {
        // Тревога включилась
        case ALERT_ON:

            p_gen6->setTrunk(OPEN, PIN); // Без проверки открытия, т.к. проверяются тайминги сработки тревоги

            if (!p_gen6->waitLightAndAlarm(m_trunk_tag_rem_wait_time_s - auth_trunk_err_time_s))
            {
                printf("PASS Тревога не включилась во время поиска устройств авторизации\n");
            }
            else
            {
                printf("FAIL Тревога включилась во время поиска устройств авторизации\n");
                return false;
            }

            if (p_gen6->waitLightAndAlarm(auth_trunk_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
            {
                printf("PASS Тревога включена\n");
            }
            else
            {
                printf("FAIL Тревога не включена\n");
                return false;
            }

            break;

        // Тревога не включилась
        case ALERT_OFF:

            if (p_gen6->setAndCheckTrunk(OPEN, PIN))
            {
                printf("PASS Багажник открыт\n");
            }
            else
            {
                printf("FAIL Багажник не открыт\n");
                return false;
            }

            if (!p_gen6->waitLightAndAlarm(m_trunk_tag_rem_wait_time_s + auth_trunk_err_time_s))
            {
                printf("PASS Тревога не включилась\n");
            }
            else
            {
                printf("FAIL Тревога включилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки тревоги\n");
            return false;
    }

    return true;
}

bool AutoTestsModesP2::resetTagOrRemoteAndCheckAlarm(auth_profile_t auth_profile, float delay_before_reset_s)
{
    float invisible_time_s;      // Время потери устройства
    float auth_trunk_err_time_s; // Ошибка времени поиска метки и брелока при открытом багажнике


    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не задана настройка \"Время поиска метки и брелока при открытом багажнике\"\n");
        return false;
    }

    auth_trunk_err_time_s = TimeoutCalculator::calcToutError(m_trunk_tag_rem_wait_time_s, PERCENT::FIVE_PERCENT);

    p_gen6->wait_s(delay_before_reset_s);

    switch (auth_profile)
    {
        case AUTH_SMART_TAG:

            if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
            {
                p_gen6->resetTagVcc();
                invisible_time_s = TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S;
            }
            else
            {
                printf("FAIL Отсутствует модуль для работы с меткой\n");
                return false;
            }

            break;

        case AUTH_REMOTE:

            if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
            {
                p_gen6->setLcdKeyringVcc(OFF);
                invisible_time_s = TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S;
            }
            else
            {
                printf("FAIL Отсутствует модуль для работы с брелком\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизветное устройство авторизации: %d\n", auth_profile);
            return false;
    }

    if (!p_gen6->waitLightAndAlarm(invisible_time_s + m_trunk_tag_rem_wait_time_s + auth_trunk_err_time_s))
    {
        printf("PASS Тревога не включилась (отсутствуют световые и звуковые сигналы)\n");
    }
    else
    {
        printf("FAIL Тревога включилась (получены световые и звуковые сигналы)\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Тревога не включилась (отсутствует статус в регионе)\n");
    }
    else
    {
        printf("FAIL Тревога включилась (присутствует статус в регионе)\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setStateAndCheckGearboxBlock(guard_state_t state, act_types_t act_type)
{
    // Состояния, в которых переключение из паркинга не приводит к блоку АКПП (не используется, присутствует для информации)
    /*
    const int8_t no_block_states[] =
                 {
                     GUARD_STATE_AHJ_CMD,
                     GUARD_STATE_AHJ_TAG,
                     GUARD_STATE_DISARM
                 };
    */

    // Состояния, в которых переключение из паркинга приводит к блоку АКПП
    const int8_t block_states[] =
                 {
                     GUARD_STATE_ARM,
                     GUARD_STATE_ARM_TRUNK,
                     GUARD_STATE_AUTH,
                     GUARD_STATE_IMMO,
                     GUARD_STATE_ALERT_LOW,
                     GUARD_STATE_ALERT_HIGH,
                 };

    bool        block_status     = false;       // Должна ли быть блокировка при переключении паркинга если система в состоянии state
    std::string block_status_str = "выключена"; // Состояние блокировки в текcтовом виде


    for (uint8_t i = 0; i < sizeof(block_states); ++i)
    {
         if (block_states[i] == state)
         {
             block_status     = true;
             block_status_str = "включена";
             break;
         }
    }

    /*!
        Начальные условия
    */
    /*!
        Автомобиль в состоянии state
    */
    switch (state)
    {
        // Включить АО по команде
        case GUARD_STATE_AHJ_CMD:

            if (!setAndCheckAhj(SMS))
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Включить АО по метке
        case GUARD_STATE_AHJ_TAG:

            if (!setAndCheckAhj(TAG))
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Снять с охраны
        case GUARD_STATE_DISARM:

            if (p_gen6->setAndCheckSecure(OFF,
                                          KEYRING,
                                          DIAG_GUARD_STATE_DISARM))
            {
                printf("PASS Начальные условия. Охрана выключена\n");
            }
            else
            {
                printf("FAIL Начальные условия. Охрана не выключена\n");
                return false;
            }

            break;

        // Поставить в охрану
        case GUARD_STATE_ARM:

            if (p_gen6->setAndCheckSecure(ON,
                                          KEYRING,
                                          DIAG_GUARD_STATE_ARM))
            {
                printf("PASS Начальные условия. Охрана включена\n");
            }
            else
            {
                printf("FAIL Начальные условия. Охрана не включена\n");
                return false;
            }

            break;

        // Перейти в охрану с открытым багажником
        case GUARD_STATE_ARM_TRUNK:

            if (!setAndCheckArmTrunk())
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Перейти в ожидание авторизации
        case GUARD_STATE_AUTH:

            if (!setAndCheckWaitingAuth())
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Перейти в запрет поездки
        case GUARD_STATE_IMMO:

            if (!setAndCheckImmo())
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Спровоцировать тревогу (основная)
        case GUARD_STATE_ALERT_HIGH:

            if (!setAndCheckAlertHigh())
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        // Спровоцировать тревогу (предупредительная)
        case GUARD_STATE_ALERT_LOW:

            if (!setAndCheckAlertLow())
            {
                printf("FAIL Начальные условия\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный режим: %d\n", state);
            return false;
    } // switch (state)

    /*!
        Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D")
    */
    /*!
        Включилась/не включилась блокировка АКПП
    */

    // Зажигание требуется для контроля паркинга
    // Исключения:
    // Переключение паркинга в охране
    // Переключение паркинга в охране с открытым багажником
    // Переключение паркинга в предупредительной тревоге
    if (   state != GUARD_STATE_ARM
        && state != GUARD_STATE_ARM_TRUNK
        && state != GUARD_STATE_ALERT_LOW)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Зажигание включено\n");
        }
        else
        {
            printf("FAIL Зажигание не включено\n");
            return false;
        }
    }

    // Сразу после управления нужно проверять пакеты, а метод Gen6Basic::setParking содержит задержки;
    // но, без минимальной задержки после отправки - пакеты не успевают отправится, прежде, чем перейти к ожиданию
    p_gen6->getCanBusActions()->sendParkingOff(TIME_DELAY::MIN_ERROR_TIME_S);

    if (p_gen6->waitGearboxAutoBlock() == block_status)
    {
        printf("PASS Блокировка АКПП %s\n", block_status_str.c_str());
    }
    else
    {
        printf("FAIL Блокировка АКПП не %s\n", block_status_str.c_str());
        return false;
    }

    /*!
        Выключить тревогу брелоком (кнопка 2)
    */
    /*!
        Тревога выключена
    */

    // Требуется только при последующем выключении охраны. Перенесено в switch case на следующий шаг

    /*!
        Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") / Выключить охрану / Авторизация по метке (зависит от кейса)
    */
    /*!
        Блокировка АКПП отключилась
    */
    switch (act_type)
    {
        // Авторизация по метке
        // Т.к. не все устройства поддерживают метку, то авторизация происходит по штатным кнопкам
        case ACT_TYPE_AUTH:
            p_gen6->sendValidatorCode();
            break;

        // Cнять с охраны
        case ACT_TYPE_DISARM:

            // Если была тревога - сбрасываем
            if (   state == GUARD_STATE_ALERT_HIGH
                || state == GUARD_STATE_ALERT_LOW)

            {
                wait(TIME_DELAY::MAX_WIRE_EN_DELAY_S); // Чтобы не выключать тревогу сразу после ее включения, иначе брелок не среагирует
                p_gen6->setSecure(OFF,
                                  KEYRING,
                                  TIME_DELAY::MAX_WIRE_EN_DELAY_S);

                if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                           OFF,
                                           TIME_DELAY::WAITING_REGION_STATE_S))
                {
                    printf("PASS Тревога выключена\n");
                }
                else
                {
                    printf("FAIL Тревога не выключена\n");
                    return false;
                }
            }

            if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
            {
                p_gen6->setSecure(OFF,
                                  KEYRING,
                                  TIME_DELAY::NULL_DELAY_S);
            }
            else
            {
                // метод Gen6Basic::setSecure не поддерживает снятие с охраны меткой без задержки после выполнения
                p_gen6->setTagVcc();
                wait(TIME_DELAY::DELAY_AFTER_TAG_VCC_EN_S);
                p_gen6->pushTagBtn(TAG_SHORT);
            }

            break;

        // Включить паркинг
        case ACT_TYPE_PARKING_ON:
            p_gen6->getCanBusActions()->sendParkingOn(TIME_DELAY::MIN_ERROR_TIME_S); // Сразу после управления нужно проверять пакеты, а метод Gen6Basic::setParking содержит задержки
            break;

        // Действие не требуется
        case ACT_TYPE_NO_ACT:
            return true; // Все что идет дальше - предназначено для проверки реакции на действия. Если действий нет - выходим из теста

        default:
            printf("FAIL Неизвестное действие: %d\n", act_type);
            return false;
    }

    if (p_gen6->waitGearboxAutoUnblock())
    {
        printf("PASS Блокировка АКПП отключилась\n");
    }
    else
    {
        printf("FAIL Блокировка АКПП не отключилась\n");
        return false;
    }

    if (!p_gen6->waitGearboxAutoBlock())
    {
        printf("PASS Блокировка АКПП выключена\n");
    }
    else
    {
        printf("FAIL Блокировка АКПП включилась\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setArmAndCheckGearboxNoBlock(parking_type_t parking_type)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | охрана
        ||Паркинг:          | включен
    */

    // В начальных условиях паркинг включается только если он аналоговый
    if (parking_type == PARKING_TYPE_ANALOG)
    {
        p_gen6->setIgn(PIN, ON);

        if (p_gen6->setAndCheckParking(ON, PIN))
        {
            printf("PASS Начальные условия. Паркинг включен\n");
        }
        else
        {
            printf("FAIL Начальные условия. Паркинг не включен\n");
        }

        p_gen6->setIgn(PIN,
                       OFF,
                       TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S); // Чтобы не включать охрану моментально после выкл. зажигания
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return false;
    }

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
               ИЛИ Выключить паркинг (аналог)
    */
    /*!
        Блокировка АКПП не включилась
        Сообщение в CAN ID=1A2 D0=01 отсутствует (ЦБ их не отсылает)
    */
    switch (parking_type)
    {
        case PARKING_TYPE_CAN:

            // Сразу после управления нужно проверять пакеты, а метод Gen6Basic::setParking содержит задержки;
            // но, без минимальной задержки после отправки - пакеты не успевают отправится, прежде, чем перейти к ожиданию
            p_gen6->getCanBusActions()->sendParkingOff(TIME_DELAY::MIN_ERROR_TIME_S);
            break;
        
        case PARKING_TYPE_ANALOG:
            p_gen6->setParking(OFF,
                               PIN,
                               TIME_DELAY::NULL_DELAY_S);
            break;
        
        default:
            printf("FAIL Неизвестный способ управления паркингом: %d\n", parking_type);
            return false;
            
    }

    if (!p_gen6->waitGearboxAutoBlock())
    {
        printf("PASS Шаг 2. Блокировка АКПП не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка АКПП включилась\n");
        return false;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_GEARBOX_P))
    {
        printf("PASS Шаг 2. Паркинг выключен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Паркинг не выключен\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::authByTagOrRemote(float delay_s)
{
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();
    }
    else if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);
    }
    else
    {
        return false;
    }

    p_gen6->wait_s(delay_s);

    return true;
}

bool AutoTestsModesP2::setZoneAndCheckAuth(zone_type_t zone_type, auth_step_t auth_step)
{
    // Тесты подразумевают авторизацию только по метке
    // Но на системах без метки будет использоваться брелок

    Timer auth_timer;                                                                       // Таймер ожидания авторизации, запускается вместе с началом ожидания авторизации
    bool  is_ble  = (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE;                     // Проверить наличие BLE модуля
    bool  is_r868 = (p_gen6->getModules() & R868_MODULE) == R868_MODULE;                    // Проверить наличие R868 модуля

    const float max_device_visible_time_s = is_ble ? TIME_DELAY::MAX_TAG_VISIBLE_TIME_S     // Максимальное время появления устройства авторизации после его включения
                                                   : TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;

    const float auth_step_one_err_time_s  =   TIME_DELAY::MAX_WIRE_EN_DELAY_S               // MAX_WIRE_EN_DELAY_S нужен т.к. при нарушении зоны мы не ждем время срабатывания провода
                                            + TIME_DELAY::STD_ERROR_TIME_S;


    if (   !is_ble
        && !is_r868)
    {
        printf("FAIL Нет модуля для беспроводной авторизации\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Дверь:            | закрыта
        ||Багажник:         | закрыт
        ||Метка:            | включена
        ||Брелок:           | включен
    */
    if (p_gen6->setAndCheckSpecialDoor(CLOSE,
                                       PIN,
                                       PASSENGER_DOOR))
    {
        printf("PASS Начальные условия. Дверь пассажира закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь пассажира не закрыта\n");
        return false;
    }

    if (p_gen6->setAndCheckSpecialDoor(CLOSE,
                                       PIN,
                                       DRIVER_DOOR))
    {
        printf("PASS Начальные условия. Дверь водителя закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь водителя не закрыта\n");
        return false;
    }

    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не закрыта\n");
        return false;
    }

    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Багажник не закрыт\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    // Состояние устройства авторизации на начальных условиях (вкл/выкл)
    if (auth_step == AUTH_STEP_START)
    {
        authByTagOrRemote(max_device_visible_time_s);
    }
    else
    {
        if (is_ble) // При наличии метки - выключаем, т.к. авторизация по ней
        {
            p_gen6->resetTagVcc();
            wait(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
        }
        else if (is_r868) // Если нет метки, но есть брелок - выключаем его, т.к. на системах без метки авторизация по брелку
        {
            p_gen6->setLcdKeyringVcc(OFF);
            wait(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
        }
    }

    /*!
        Открыть дверь/багажник (зависит от теста)
    */
    /*!
        Тревога не включилась
        Ожидание авторизации
    */

    // Каждая зона активируется без проверки т.к. нужно сразу проверять тревогу
    switch (zone_type)
    {
        case ZONE_DOOR:
            p_gen6->setDoor(OPEN,
                            PIN,
                            TIME_DELAY::NULL_DELAY_S);
            break;

        case ZONE_TRUNK:
            p_gen6->setTrunk(OPEN,
                             PIN,
                             TIME_DELAY::NULL_DELAY_S);
            break;

        case ZONE_DOOR_DRIVER:
            p_gen6->setDriverDoor(OPEN,
                                  PIN,
                                  TIME_DELAY::NULL_DELAY_S);
            break;

        case ZONE_DOOR_PASSENGER:
            p_gen6->setPassengerDoor(OPEN,
                                     PIN,
                                     TIME_DELAY::NULL_DELAY_S);
            break;

        default:
            printf("FAIL Неизвестная зона для активации: %d\n", zone_type);
            return false;
    }

    auth_timer.start();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога включилась\n");
        return false;
    }

    // Ожидание авторизации будет если мы не прошли ее в начальных условиях
    if (auth_step != AUTH_STEP_START)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_WAITING_AUTH,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Переход из охраны в ожидание авторизации\n");
        }
        else
        {
            printf("FAIL Шаг 1. Система не в \"Ожидание авторизации\"\n");
            return false;
        }
    }

    // Дождаться начала шага 2 ожидания авторизации
    if (   auth_step == AUTH_STEP_TWO
        || auth_step == AUTH_STEP_THREE)
    {
        auth_timer.stop();

        if (!p_gen6->waitBuzzerExt(ON, m_auth_step_one_time_s - auth_timer.read() - auth_step_one_err_time_s))
        {
            printf("PASS Предупреждение внутренним звукоизвещателем не включено раньше времени\n");
        }
        else
        {
            printf("FAIL Предупреждение внутренним звукоизвещателем включено раньше времени\n");
            return false;
        }

        if (p_gen6->waitBuzzerExt(ON, auth_step_one_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("PASS Предупреждение внутренним звукоизвещателем включено\n");
        }
        else
        {
            printf("FAIL Предупреждение внутренним звукоизвещателем не включено\n");
            return false;
        }
    }

    // Дождаться начала шага 3 ожидания авторизации
    if (auth_step == AUTH_STEP_THREE)
    {
        if (!p_gen6->waitLightAndAlarm(m_auth_step_two_time_s - TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Предупреждение световыми и звуковыми сигналами не получено раньше времени\n");
        }
        else
        {
            printf("FAIL Предупреждение световыми и звуковыми сигналами получено раньше времени\n");
            return false;
        }

        if (p_gen6->waitLightAndAlarm(TIME_DELAY::STD_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("PASS Предупреждение световыми и звуковыми сигналами получено\n");
        }
        else
        {
            printf("FAIL Предупреждение световыми и звуковыми сигналами не получено\n");
            return false;
        }
    }

    /*!
        Включить метку
    */
    /*!
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация)
    */
    authByTagOrRemote(TIME_DELAY::NULL_DELAY_S); // Без задержки после включения устройства для авторизации т.к. нужно сразу проверять тревогу

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                max_device_visible_time_s + TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Переход в тревогу отсутствует\n");
    }
    else
    {
        printf("FAIL Произошел переход в тревогу\n");
        return false;
    }

    switch (auth_step)
    {
        case AUTH_STEP_TWO:

            if (!p_gen6->waitBuzzerExt(ON, TIME_DELAY::AUTH_DIS_CHECK_TIME_S))
            {
                printf("PASS Отсутствует предупреждение внутренним звукоизвещателем\n");
            }
            else
            {
                printf("FAIL Присутствует предупреждение внутренним звукоизвещателем\n");
                return false;
            }

            break;

        case AUTH_STEP_THREE:

            if (!p_gen6->waitLightAndAlarm(TIME_DELAY::AUTH_DIS_CHECK_TIME_S))
            {
                printf("PASS Отсутствует предупреждение сиреной и световыми сигналами\n");
            }
            else
            {
                printf("FAIL Присутствует предупреждение сиреной и световыми сигналами\n");
                return false;
            }

            break;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Переход из авторизации в снято\n");
    }
    else
    {
        printf("FAIL Система не в \"Снято с охраны\"\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::waitStdAndR6Block(block_statuses_t block_status, float timeout_s)
{
    Timer timer;
    bool  is_std_block; // Сработал ли выход блокировки основного блока
    bool  is_r6_block;  // Сработал ли выход блокировки R6


    printf("INFO Проверка срабатывания выходов блокировок основного блока и R6\n");

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с R6\n");
        return false;
    }

    timer.start();

    // Цикл проверки блокировки. При срабатывании выхода блокировки - будет возврат из функции с true или false
    while (timer.read() < timeout_s)
    {
        is_std_block = p_gen6->getBlock(PIN);
        is_r6_block  = p_gen6->getBlock(THROUGH_R6);

        switch (block_status)
        {
            // Оба выхода блокировки должны включиться
            case BLOCK_ON:

                if (   is_std_block
                    && is_r6_block)
                {
                    printf("PASS Выход блокировки включен\n");
                    return true;
                }

                break;

            // Оба выхода блокировки должны выключиться
            case BLOCK_OFF:

                if (   !is_std_block
                    && !is_r6_block)
                {
                    printf("PASS Выход блокировки выключен\n");
                    return true;
                }

                break;

            // Ни один выход блокировки не должен включиться
            case BLOCK_NOT_ON:

                if (   is_std_block
                    || is_r6_block)
                {
                    printf("FAIL Выход блокировки включился\n");
                    return false;
                }

                break;

            // Ни один выход блокировки не должен выключиться
            case BLOCK_NOT_OFF:

                if (   !is_std_block
                    || !is_r6_block)
                {
                    printf("FAIL Выход блокировки выключился\n");
                    return false;
                }

                break;

            default:
                printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
                return false;
        } // switch
    } // while

    timer.stop();

    // Если цикл кончился - значит выход блокировки не сработал
    switch (block_status)
    {
        // Выход блокировки должен был включиться, но этого не произошло
        case BLOCK_ON:
            printf("FAIL Выход блокировки не включен\n");
            return false;

        // Выход блокировки должен был выключиться, но этого не произошло
        case BLOCK_OFF:
            printf("FAIL Выход блокировки не выключен\n");
            return false;

        // Выход блокировки не включился
        case BLOCK_NOT_ON:
            printf("PASS Выход блокировки не включился\n");
            return true;

        // Выход блокировки не выключился
        case BLOCK_NOT_OFF:
            printf("PASS Выход блокировки не выключился\n");
            return true;

        default:
            printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
            return false;

    }
}

command_type_t AutoTestsModesP2::getExecutionMethodDisarmNoTag()
{
    command_type_t execution_method = ERROR_TYPE; // Метод исполнения


    // Для тестов всегда нужна метка. Чтобы не включать ее при снятии/постановке - нужен еще один метод исполнения
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
        {
            execution_method = KEYRING;
        }
        else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
        {
            execution_method = SMS;
        }
    }

    return execution_method;
}

bool AutoTestsModesP2::setDisarmAndDoorAndIgn(tag_statuses_t    tag_status,
                                              remote_statuses_t remote_status)
{
    float tag_wait_time_s    = TIME_DELAY::NULL_DELAY_S; // Время включения/выключения метки
    float remote_wait_time_s = TIME_DELAY::NULL_DELAY_S; // Время включения/выключения брелока


    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf("FAIL Отсутствуют модули для работы с меткой и брелоком\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Охрана:           | выключена
        ||Зажигание:        | включено
        ||Дверь:            | открыта
        ||Паркинг:          | выключен
        ||Метка:            | включена/выключена
        ||Брелок:           | включен/выключен
    */
    p_gen6->setSecure(ON, KEYRING); // Сначала включить охрану, т.к. перед тестом могло быть экстренное снятие с охраны кодом
                                    // что вызывает отключение всех защитных функций на 1 цикл охраны

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return false;
    }

    if (p_gen6->setAndCheckParking(OFF, PIN))
    {
        printf("PASS Начальные условия. Паркинг выключен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Паркинг не выключен\n");
        return false;
    }

    if (tag_status == TAG_ON)
    {
        p_gen6->setTagVcc();
        tag_wait_time_s = TIME_DELAY::MAX_TAG_VISIBLE_TIME_S;
    }
    else
    {
        p_gen6->resetTagVcc();
        tag_wait_time_s = TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S;
    }

    if (remote_status == REMOTE_ON)
    {
        p_gen6->setLcdKeyringVcc(ON);
        remote_wait_time_s = TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;
    }
    else
    {
        p_gen6->setLcdKeyringVcc(OFF);
        remote_wait_time_s = TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S;
    }

    // Ожидание нахождения/потери метки/брелока
    p_gen6->wait_s(max(tag_wait_time_s,
                       remote_wait_time_s));

    if (p_gen6->setAndCheckDoor(ON, PIN))
    {
        printf("PASS Начальные условия. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не открыта\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::resetTagOrRemoteAndCheckAhj(ahj_type_t   ahj_type,
                                                   ahj_status_t ahj_status)
{
    if (   m_ahj_steps_one_and_two_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_ahj_step_three_time_s        == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_ahj_step_four_time_s         == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройки АО не заданы (не все)\n");
        return false;
    }

    /*!
        Выключить метку/брелок
    */
    /*!
        Метка/брелок потеряна
    */
    switch (ahj_type)
    {
        case AHJ_TYPE_TAG_OFF:
            p_gen6->resetTagVcc();
            p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
            break;

        case AHJ_TYPE_REMOTE_OFF:
            p_gen6->setLcdKeyringVcc(OFF);
            p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
            break;

        default:
            printf("FAIL Неизвестный тип активации АО: %d\n", ahj_type);
            return false;

    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        АО включено/не включилось
    */
    if (ahj_status != AHJ_STATUS_OFF)
    {
        /*
            Сработал ДД
            Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
            Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
            Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
            Включилось АО
            Включилась тревога
        */

        // NO_CHECK_BLOCK т.к. блокировка включится только при скорости ниже 30 км/ч. Если CAN не настроен - информации о скорости нет
        if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
        {
            return false;
        }

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                   ON,
                                   TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Включилась тревога\n");
        }
        else
        {
            printf("FAIL Тревога не включилась\n");
            return false;
        }
    }
    else
    {
        /*
            Сработал ДД
            Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
            Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
            Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
        */
        p_gen6->setMoveSensor();

        if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                       + m_ahj_step_three_time_s
                                       + TIME_DELAY::STD_WIRE_EN_DELAY_S))
        {
            printf("PASS Предупредительные сигналы не получены\n");
        }
        else
        {
            printf("FAIL Предупредительные сигналы получены\n");
            return false;
        }

        p_gen6->checkAlarm(OFF, m_ahj_step_four_time_s + TIME_DELAY::STD_ALARM_SIGNAL_TIME_S);

        // Для AHJ_STATUS_TAG и AHJ_STATUS_REMOTE одинаковая проверка. В регионе нет отдельного статуса для АО по брелоку
        if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG))
        {
            printf("PASS Антиограбление не включено\n");
        }
        else
        {
            printf("FAIL Антиограбление включено\n");
            return false;
        }
    } // if ahj_status

    return true;
}

bool AutoTestsModesP2::setSecureAndRemoteAndResetTagAndIgn()
{
    float tag_wait_time_s    = TIME_DELAY::NULL_DELAY_S; // Время ожидания выключения метки
    float remote_wait_time_s = TIME_DELAY::NULL_DELAY_S; // Время ожидания включения брелока


    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | охрана
        ||Зажигание:        | выключено
        ||Метка:            | выключена
        ||Брелок:           | включен
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return false;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();

        tag_wait_time_s = TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);

        remote_wait_time_s = TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;
    }

    p_gen6->wait_s(max(tag_wait_time_s,      // Ожидание метки/брелока
                       remote_wait_time_s));

    return true;
}

bool AutoTestsModesP2::checkBuzzerAuth(float timeout_s,
                                       float pulse_width_s,
                                       float pulse_pause_s)
{
    Timer timer;

    const float  pulse_err_s              = TimeoutCalculator::calcToutError(pulse_width_s); // Погрешность длительности импульса
    const float  pause_err_s              = TimeoutCalculator::calcToutError(pulse_pause_s); // Погрешность паузы между импульсами

    const int8_t min_expected_pulse_count = timeout_s / (  pulse_width_s                     // Минимальное ожидаемое количество импульсов
                                                         + pulse_err_s
                                                         + pulse_pause_s
                                                         + pause_err_s);

    bool   buzz_ext_status;                                                                  // Логические состояние бузера
    bool   buzz_ext_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);                       // Полярность бузера

    bool   is_potential      = false;                                                        // Получен ли потенциал
    bool   is_pulse          = false;                                                        // Получен ли импульс
    int8_t pulse_count       = 0;                                                            // Количество полученных импульсов

    float  buzz_potential_time_s;                                                            // Время получения потенциала
    float  buzz_pulse_time_s;                                                                // Время получения импульса

    float  buzz_pulse_width_s;                                                               // Длительность импульса
    float  buzz_pulse_pause_s;                                                               // Пауза между импульсами


    printf("INFO Проверка работы бузера в режиме \"Ожидание авторизации\". Время проверки: %.2f, минимальное ожидаемое количество импульсов: %d\n",
           timeout_s,
           min_expected_pulse_count);
    timer.start();

    while (timer.read() < timeout_s)
    {
        buzz_ext_status = p_gen6->getBuzzerExt() == buzz_ext_polarity;

        // Получен потенциал
        // Если перед потенциалом был получен импульс - проверить паузу между импульсами
        if (   !is_potential
            &&  buzz_ext_status)
        {
            is_potential          = true;
            buzz_potential_time_s = timer.read();

            // Проверка паузы между импульсами
            if (is_pulse)
            {
                is_pulse           = false;
                buzz_pulse_pause_s = buzz_potential_time_s - buzz_pulse_time_s;

                if (buzz_pulse_pause_s - pulse_pause_s > pause_err_s)
                {
                    printf("FAIL Неверная пауза между сигналами. Получено: %.6f, ожидалось: %.6f с погрешностью: %.6f\n",
                           buzz_pulse_pause_s,
                           pulse_pause_s,
                           pause_err_s);

                    return false;
                }
            }
        } // if !is_potential

        // Получен импульс
        // После получения импульса проверить его длительность
        if (    is_potential
            && !buzz_ext_status)
        {
            is_potential       = false;
            is_pulse           = true;
            buzz_pulse_time_s  = timer.read();

            printf("INFO Получен %d-й сигнал бузера\n", ++pulse_count);

            // Посчитать и проверить длительность импульса
            buzz_pulse_width_s = buzz_pulse_time_s - buzz_potential_time_s;

            if (   pulse_count                        > 1            // Проверка валидна только если это уже не первый импульс, т.к. метод мог быть вызван на середине импульса
                && buzz_pulse_width_s - pulse_width_s > pulse_err_s)
            {
                printf("FAIL Неверная длительность сигнала. Получено: %.6f, ожидалось: %.6f с погрешностью: %.6f\n",
                       buzz_pulse_width_s,
                       pulse_width_s,
                       pulse_err_s);

                return false;
            }
        } // if is_potential
    } // while

    timer.stop();

    if (pulse_count < min_expected_pulse_count)
    {
        printf("FAIL Получено недостаточно сигналов бузера. Получено: %d, ожидалось: %d\n",
               pulse_count,
               min_expected_pulse_count);

        return false;
    }

    printf("PASS Ожидаемое количество сигналов бузера получено\n");

    return true;
}

bool AutoTestsModesP2::checkBuzzerAuthStepOne(float timeout_s)
{
    Timer timer;
    bool  polarity                       = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);                // Полярность бузера

    const int8_t group_pulse_count       = COUNT_STRUCT::BUZZER_AUTH_STEP_ONE_GROUP_PULSE_COUNT;  // Количество импульсов в группе
    const float  pulse_width_s           = TIME_DELAY::BUZZER_AUTH_PULSE_WIDTH_S;                 // Длительность каждого импульса в группе
    const float  pulse_pause_s           = TIME_DELAY::BUZZER_AUTH_STEP_ONE_PULSE_PAUSE_S;        // Пауза между импульсами в группе

    const float  check_time_s            = (pulse_width_s + pulse_pause_s) * group_pulse_count;   // Время проверки группы импульсов
    const float  check_time_with_err_s   = TimeoutCalculator::calcTimeWithError(check_time_s);    // Время проверки группы импульсов c учетом погрешности

    const float  pulse_group_pause_s     = TIME_DELAY::BUZZER_AUTH_STEP_ONE_GROUP_PULSE_PAUSE_S;  // Пауза между группами импульсов
    const float  pulse_group_err_pause_s = TimeoutCalculator::calcToutError(pulse_group_pause_s); // Погрешность паузы между группами импульсов

    float buzz_check_end_time_s          = TIME_DELAY::NULL_DELAY_S;                              // Время окончания проверки импульсов в группе


    printf("INFO Проверка бузера для алгоритма \"Ожидание авторизации, шаг 1\", время проверки: %.2f\n", timeout_s);
    timer.start();

    while (timer.read() < timeout_s - check_time_with_err_s)
    {
        if (p_gen6->getBuzzerExt() == polarity)
        {
            // Проверка паузы между группами импульсов
            if (    buzz_check_end_time_s != TIME_DELAY::NULL_DELAY_S
                && (buzz_check_end_time_s - timer.read()) - pulse_group_pause_s > pulse_group_err_pause_s)
            {
                printf("FAIL Пауза между сигналами бузера не выдержана\n");
                return false;
            }

            // Проверка группы импульсов
            if (!checkBuzzerAuth(check_time_with_err_s,
                                 pulse_width_s,
                                 pulse_pause_s))
            {
                printf("FAIL При проверке сигналов бузера\n");
                return false;
            }

            buzz_check_end_time_s = timer.read();
        }
    }

    timer.stop();
    p_gen6->wait_s(timeout_s - timer.read());          // Чтобы метод не кончился раньше, чем указано параметром
    printf("PASS Проверка сигналов бузера успешна\n");

    return true;
}

bool AutoTestsModesP2::checkBuzzerAuthStepTwo(float timeout_s)
{
    printf("INFO Проверка бузера для алгоритма \"Ожидание авторизации, шаг 2\", время проверки: %.2f\n", timeout_s);

    return checkBuzzerAuth(timeout_s,
                           TIME_DELAY::BUZZER_AUTH_PULSE_WIDTH_S,
                           TIME_DELAY::BUZZER_AUTH_STEP_TWO_PULSE_PAUSE_S);
}

bool AutoTestsModesP2::setAndCheckAuthWithBuzzer()
{
    if (   m_auth_step_one_vld_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_auth_step_two_time_s     == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_auth_step_three_time_s   == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки режима \"Ожидание авторизации\" заданы\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | охрана
        ||Зажигание:        | выключено
        ||Метка:            | выключена
        ||Брелок:           | включен
    */
    if (!setSecureAndRemoteAndResetTagAndIgn())
    {
        printf("FAIL Начальные условия\n");
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход из снято в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из снято в ожидание авторизации не произошел\n");
        return false;;
    }

    p_gen6->wait_s(TIME_DELAY::REMOTE_ACT_DELAY_S); // Пропустить сигналы сирены/света при постановке

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)

        Через 15 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации):
        выключились трехкратные периодические импульсы и включились периодические импульсы (100 мс импульс и 1000 мс пауза)
        ИЛИ
        проверка пропущена, если настройка Ожидание авторизации, шаг 2 имеет значение 0 секунд

        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем):
        выключились периодические импульсы звукоизвещателя и включились предупреждения сиреной и световыми сигналами
        ИЛИ
        выключились периодические импульсы звукоизвещателя и сразу включилась тревога, если настройка Ожидание авторизации, шаг 3 имеет значение 0 секунд

        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    p_gen6->setDoor(OPEN,
                    PIN,
                    TIME_DELAY::NULL_DELAY_S);

    // Проверка алгоритма Ожидание авторизации, шаг 1
    if (!checkBuzzerAuthStepOne(m_auth_step_one_vld_time_s))
    {
        printf("FAIL Шаг 2. Проверка бузера для алгоритма \"Ожидание авторизации, шаг 1\" неуспешна\n");
        return false;
    }

    // Проверка алгоритма Ожидание авторизации, шаг 2
    if (m_auth_step_two_time_s > TIME_DELAY::NULL_DELAY_S)
    {
        if (!checkBuzzerAuthStepTwo(m_auth_step_two_time_s))
        {
            printf("FAIL Шаг 2. Проверка бузера для алгоритма \"Ожидание авторизации, шаг 2\" неуспешна\n");
            return false;
        }
    }

    // Проверка алгоритма Ожидание авторизации, шаг 3
    if (p_gen6->waitBuzzerExt(OFF, TimeoutCalculator::calcToutError(m_auth_step_one_vld_time_s + m_auth_step_two_time_s)))
    {
        printf("PASS Шаг 2. Бузер выключился\n");
    }
    else
    {
        printf("FAIL Шаг 2. Бузер не выключился\n");
        return false;
    }

    if (m_auth_step_three_time_s > TIME_DELAY::NULL_DELAY_S)
    {
        if (p_gen6->waitLightAndAlarm(TIME_DELAY::MAX_WIRE_EN_DELAY_S))
        {
            printf("PASS Шаг 2. Включились предупреждения сиреной и световыми сигналами\n");
        }
        else
        {
            printf("FAIL Шаг 2. Предупреждения сиреной и световыми сигналами не включились\n");
            return false;
        }

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    m_auth_step_three_time_s - TimeoutCalculator::calcToutError(m_auth_step_three_time_s)))
        {
            printf("PASS Шаг 2. Тревога не включилась раньше времени\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога включилась раньше времени\n");
            return false;
        }
    }

    // Алгоритм Ожидание авторизации завершен, включение тревоги
    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включилась\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setArmAndRemoteAndResetTag(secure_zone_t secure_zone)
{
    const float tag_wait_time_s    = TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S; // Время ожидания метки
    float       remote_wait_time_s = TIME_DELAY::NULL_DELAY_S;             // Время ожидания брелока (может меняться в зависимости от наличия модуля)


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("FAIL Отсутствует модуль для работы с меткой\n");
        return false;
    }

    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана/Охрана с нарушенным периметром
        ||Метка:            | выключена
        ||Брелок:           | включен
        ||Дверь:            | закрыта/открыта
    */
    if (secure_zone == PERIM_DOOR_OPEN)
    {
        if (p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("PASS Начальные условия. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Начальные условия. Дверь не открыта\n");
            return false;
        }
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);
        remote_wait_time_s = TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;
    }

    p_gen6->resetTagVcc();

    printf("INFO Ожидание включения (нахождения) брелока и выключения (потери) метки\n");
    p_gen6->wait_s(max(remote_wait_time_s,
                       tag_wait_time_s));

    return true;
}

bool AutoTestsModesP2::setAndCheckDisarmNoDelayNoTag()
{
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setSecureNoDelay(OFF, KEYRING);
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        p_gen6->setSecureNoDelay(OFF, SMS);
    }
    else
    {
        printf("FAIL Отсутствует устройство для снятия с охраны помимо метки\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_SMS_STATUS_TIME_S))
    {
        printf("PASS Охрана отключена\n");
    }
    else
    {
        printf("FAIL Охрана не отключена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setSpeedAndBrakeAndArmZoneClosed(int8_t speed, brake_pedal_status_t brake_pedal_status)
{
    const std::string brake_pedal_str = brake_pedal_status == BRAKE_PEDAL_ON ? "нажата"
                                                                             : "отпущена";


    p_gen6->setSpeed(speed);

    if (p_gen6->setAndCheckBreak(brake_pedal_status, PIN))
    {
        printf("PASS Педаль тормоза %s\n", brake_pedal_str.c_str());
    }
    else
    {
        printf("FAIL Педаль тормоза не %s\n", brake_pedal_str.c_str());
        return false;
    }

    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL При закрытии всех зон или постановка в охрану\n");
        return false;
    }

    printf("INFO Ожидание демаскирования датчиков после постановки в охрану\n");

    if (m_sensors_mask_time_s != SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        p_gen6->wait_s(m_sensors_mask_time_s);
    }
    else
    {
        p_gen6->wait_s(TIME_DELAY::UNMASK_ZONE_TIME_S);
    }

    return true;
}

bool AutoTestsModesP2::setZoneAndCheckBlockTime(zone_type_t          zone_type,
                                                block_statuses_t     block_status,
                                                alarm_check_status_t alarm_check_status)
{
    bool block_status_result; // Полученный статус блокировки


    if (   m_eng_block_local0_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки блокировки двигателя были заданы\n");
        return false;
    }

    /*!
        Шаг 1. Вызвать тревогу
    */
    /*!
        Включена тревога

        Блокировка (block_status):
        Блокировка включилась:
            Через время "задержка блокировки" включилась блокировка (на выход блокировки подан потенциал)
            Через время "длительность блокировки" блокировка отключилась (с выхода блокировки снят потенциал)

        Блокировка не включилась:
            В течение времени "задержка блокировки"+"длительность блокировки"+ запас блокировка не включилась и на выход блокировки потенциал не подавался
    */

    // Без проверки по SLP, т.к. сразу проверяется выход блокировки
    switch (zone_type)
    {
        case ZONE_NONE:
            break;

        case ZONE_IGN:
            p_gen6->setIgn(PIN, ON);
            break;

        case ZONE_DOOR:
            p_gen6->setDoor(OPEN, PIN);
            break;

        case ZONE_BRAKE_PEDAL:
            p_gen6->setBreak(ON, PIN);
            break;

        case ZONE_SENSOR_MOVE:
            p_gen6->setMoveSensor();
            break;

        default:
            printf("FAIL Данная зона не поддерживается: %d\n", zone_type);
            return false;
    }

    switch (block_status)
    {
        case BLOCK_ON:

            // Включение блокировки с задержкой перед включением (настройка: 'Задержка блокировки')
            if (m_eng_block_local0_delay_s > TIME_DELAY::NULL_DELAY_S)
            {
                block_status_result = p_gen6->waitBlock(m_eng_block_local0_delay_s, TimeoutCalculator::calcToutError(m_eng_block_local0_delay_s));
            }
            // Включение бловировки без задержки
            else
            {
                block_status_result = p_gen6->waitBlock(TIME_DELAY::STD_WIRE_EN_DELAY_S);
            }

            if (block_status_result)
            {
                printf("PASS Включилась блокировка\n");
            }
            else
            {
                printf("FAIL Не включилась блокировка или статус блокировки получен за пределами времени ожидания\n");
                return false;
            }

            // Проверка выключения блокировки (настройка: 'Длительность блокировки')
            if (p_gen6->waitBlock(m_eng_block_local0_block_s,
                                  TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                                  OFF))
            {
                printf("PASS Блокировка отключилась\n");
            }
            else
            {
                printf("FAIL Блокировка не отключилась или статус блокировки получен за пределами времени ожидания\n");
                return false;
            }

            break;

        case BLOCK_OFF:
        case BLOCK_NOT_ON:

            if (!p_gen6->waitBlock(m_eng_block_local0_delay_s + m_eng_block_local0_block_s + TIME_DELAY::ALARM_BLOCK_TIME_S))
            {
                printf("PASS Блокировка не включилась\n");
            }
            else
            {
                printf("FAIL Блокировка включилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
            return false;
    }

    if (alarm_check_status == CHECK_ALARM)
    {
        if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                    DIAG_GUARD_STATE_ALERT_MAIN))
        {
            printf("PASS Тревога включена\n");
        }
        else
        {
            printf("FAIL Тревога не включена\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setAlertAndZoneAndCheckBlock(zone_type_t zone_type)
{
    Timer block_timer; // Таймер, начитает отсчет с момента включения блокировки


    if (   m_eng_block_local0_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки блокировки двигателя были заданы\n");
        return false;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через время "задержка блокировки" включилась блокировка (на выход блокировки подан потенциал)
    */
    p_gen6->setMoveSensor();

    if (p_gen6->waitBlock(m_eng_block_local0_delay_s, TimeoutCalculator::calcToutError(m_eng_block_local0_delay_s)))
    {
        printf("PASS Шаг 1. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не включена\n");
        return false;
    }

    block_timer.start();

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return false;
    }

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД/открыть дверь (zone_type)
    */
    /*!
        Сработал ДД
        Через время "длительность блокировки" после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    p_gen6->wait_s(TIME_DELAY::ALARM_ACT_DELAY_S);

    switch (zone_type)
    {
        case ZONE_DOOR:

            if (p_gen6->setAndCheckDoor(OPEN, PIN))
            {
                printf("PASS Шаг 2. Дверь открыта\n");
            }
            else
            {
                printf("FAIL Шаг 2. Дверь не открыта\n");
                return false;
            }

            break;

        case ZONE_SENSOR_MOVE:
            p_gen6->setMoveSensor();
            break;

        default:
            printf("FAIL Данная зона не поддерживается: %d\n", zone_type);
            return false;
    }

    if (p_gen6->waitBlock(m_eng_block_local0_block_s - block_timer.read(),
                          TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                          OFF))
    {
        printf("PASS Шаг 2. Блокировка выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка не выключена или статус получен за пределами времени ожидания\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAhjAndCheckBlock(brake_pedal_status_t brake_pedal_status,
                                           ahj_block_type_t     ahj_block_type)
{
    int8_t step = 0; // Текущий шаг теста (для логирования)


    /*!
        Начальные условия
    */
    /*!
        ||Автомобиль в:     | снято
        ||Зажигание:        | включено
        ||Дверь:            | закрыта
        ||Блокировка:       | отключена
        ||Педаль тормоза:   | не нажата
        ||Метка (брелок):   | включена
        ||Паркинг:          | отключен
        ||Ручник:           | отключен
    */
    p_gen6->setSecure(ON, KEYRING); // Встать в охрану перед снятием, т.к. могло быть снятие кодом (после чего защитные функции отключаются на 1 цикл охраны)

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return false;
    }

    if (p_gen6->setAndCheckBreak(OFF, PIN))
    {
        printf("PASS Начальные условия. Педаль тормоза не нажата\n");
    }
    else
    {
        printf("FAIL Начальные условия. Педаль тормоза нажата\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return false;
    }

    if (p_gen6->setAndCheckParking(OFF, PIN))
    {
        printf("PASS Начальные условия. Паркинг выключен\n");
    }
    else
    {
        printf("PASS Начальные условия. Паркинг не выключен\n");
        return false;
    }

    if (p_gen6->setAndCheckHandBreak(OFF, PIN))
    {
        printf("PASS Начальные условия. Ручник выключен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Ручник не выключен\n");
        return false;
    }

    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не закрыта\n");
        return false;
    }

    // Если не будет метки - то АО будем включать по брелоку
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }
    else
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    if (!waitBlock(ON))
    {
        printf("PASS Начальные условия. Блокировка отключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Блокировка не отключена\n");
        return false;
    }

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */
    if (brake_pedal_status == BRAKE_PEDAL_ON)
    {
        ++step;

        if (p_gen6->setAndCheckBreak(ON, PIN))
        {
            printf("PASS Шаг %d. Педаль тормоза нажата\n", step);
        }
        else
        {
            printf("FAIL Шаг %d. Педаль тормоза не нажата\n", step);
            return false;
        }
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    ++step;

    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг %d. Дверь открыта\n", step);
    }
    else
    {
        printf("FAIL Шаг %d. Дверь не открыта\n", step);
        return false;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    ++step;

    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг %d. Дверь закрыта\n", step);
    }
    else
    {
        printf("FAIL Шаг %d. Дверь не закрыта\n", step);
        return false;
    }

    /*!
        Шаг 4. Выключить метку (брелок)
    */
    /*!
        Метка (брелок) потеряна
    */
    ++step;

    // Если не будет метки - то АО включаем по брелоку
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }
    else
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено

        Блокировка (параметр ahj_block_type):
        Блокировка не включилась сразу:
            Блокировка не включилась (на выход блокировки потенциал не подан)

        Блокировка включилась сразу:
            Включилась блокировка (на выход блокировки подан потенциал)

        Блокировка включилась через 180 секунд:
            Блокировка не включилась (на выход блокировки потенциал не подан)
            Через 180 сек. (внутренний таймаут) включилась блокировка (на выход блокировки подан потенциал)

        Блокировка не включилась через 180 секунд:
            Блокировка не включилась (на выход блокировки потенциал не подан)
            Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    ++step;

    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM)) // Без проверки блокировки в методе, т.к. проверяем сами
    {
        printf("FAIL Шаг %d\n", step);
        return false;
    }

    switch (ahj_block_type)
    {
        // Блокировка не включилась сразу
        case AHJ_BLOCK_TYPE_INSTANT_OFF:

            if (!waitBlock(ON))
            {
                printf("PASS Шаг %d. Блокировка не включилась\n", step);
            }
            else
            {
                printf("FAIL Шаг %d. Блокировка включилась\n", step);
                return false;
            }

            break;

        // Блокировка включилась сразу после Шага 4 АО
        case AHJ_BLOCK_TYPE_INSTANT_ON:

            if (waitBlock(ON))
            {
                printf("PASS Шаг %d. Блокировка включилась\n", step);
            }
            else
            {
                printf("FAIL Шаг %d. Блокировка не включилась\n", step);
                return false;
            }

            break;

        // Блокировка не включилась в течение и через 180 секунд (внутренний тайминг) после Шага 4 АО
        case AHJ_BLOCK_TYPE_DELAYED_OFF:

            if (!waitBlock(ON, TIME_DELAY::MAX_AHJ_BLOCK_DELAY_S + TIME_DELAY::ALARM_BLOCK_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Проверяем 180 секунд с запасом
            {
                printf("PASS Шаг %d. Блокировка не включилась\n", step);
            }
            else
            {
                printf("FAIL Шаг %d. Блокировка включилась\n", step);
                return false;
            }

            break;

        // Блокировка включилась через 180 секунд (внутренний тайминг) после Шага 4 АО
        case AHJ_BLOCK_TYPE_DELAYED_ON:

            if (waitBlock(ON,
                          TIME_DELAY::MAX_AHJ_BLOCK_DELAY_S,
                          TimeoutCalculator::calcToutError(TIME_DELAY::MAX_AHJ_BLOCK_DELAY_S) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность, т.к. перед ожиданием есть проверка АО по SLP
            {
                printf("PASS Шаг %d. Блокировка включилась\n", step);
            }
            else
            {
                printf("FAIL Шаг %d. Блокировка не включилась\n", step);
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки блокировки АО: %d\n", ahj_block_type);
            return false;
    }

    return true;
}

bool AutoTestsModesP2::resetBrakeAndRestartIgnAndCheckBlock(block_statuses_t block_status)
{
    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */
    if (p_gen6->setAndCheckBreak(OFF, PIN))
    {
        printf("PASS Шаг 6. Педаль тормоза отключена\n");
    }
    else
    {
        printf("FAIL Шаг 6. Педаль тормоза не отключена\n");
        return false;
    }

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Не позднее чем через 30 сек (внутренний таймаут продолжительности одного полуцикла тревоги) выключена тревога
        Блокировка отключена или не отключена (block_status)
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 7. Зажигание отключено\n");
    }
    else
    {
        printf("FAIL Шаг 7. Зажигание не отключено\n");
        return false;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               OFF,
                               TIME_DELAY::ALARM_DIS_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 7. Тревога выключена\n");
    }
    else
    {
        printf("FAIL Шаг 7. Тревога не выключена\n");
        return false;
    }

    switch (block_status)
    {
        case BLOCK_OFF:
        case BLOCK_NOT_ON:

            if (waitBlock(OFF))
            {
                printf("PASS Шаг 7. Блокировка отключена\n");
            }
            else
            {
                printf("FAIL Шаг 7. Блокировка не отключена\n");
                return false;
            }

            break;

        case BLOCK_NOT_OFF:

            if (!waitBlock(OFF))
            {
                printf("PASS Шаг 7. Блокировка не отключилась\n");
            }
            else
            {
                printf("FAIL Шаг 7. Блокировка отключилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
            break;
    }

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась или не отключилась (block_status)
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 8. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 8. Зажигание не включено\n");
        return false;
    }

    switch (block_status)
    {
        case BLOCK_OFF:
        case BLOCK_NOT_ON:

            if (!waitBlock(ON))
            {
                printf("PASS Шаг 8. Блокировка не включилась\n");
            }
            else
            {
                printf("FAIL Шаг 8. Блокировка включилась\n");
                return false;
            }

            break;

        case BLOCK_NOT_OFF:

            if (!waitBlock(OFF))
            {
                printf("PASS Шаг 8. Блокировка не отключилась\n");
            }
            else
            {
                printf("FAIL Шаг 8. Блокировка отключилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
            break;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 8. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 8. Тревога не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setSensorAndCheckBlockTwice(block_statuses_t block_status)
{
    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Блокировка включилась по ДД (включен сразу после Шага 4 АО)\n");
        return false;
    }

    /*!
        Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение

        Блокировка (block_status):
        Блокировка включилась:
            Через время "задержка блокировки" включилась блокировка (на выход блокировки подан потенциал)
            Через время "длительность блокировки" блокировка отключилась (с выхода блокировки снят потенциал)

        Блокировка не включилась:
            Блокировка не включилась (на выход блокировки не подан потенциал)
    */
    p_gen6->wait_s(TIME_DELAY::MAX_AHJ_BLOCK_DELAY_S);

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, block_status))
    {
        printf("FAIL При проверке статуса блокировки (вторая сработка ДД после АО, после паузы 180 сек.)\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setSensorAndBrakeAndSensorAndCheckBlock(block_statuses_t block_status)
{
    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
        return false;
    }

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_BRAKE_PEDAL, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 6\n");
        return false;
    }

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение

        Блокировка (block_status):
        Блокировка включилась:
            Через время "задержка блокировки" включилась блокировка (на выход блокировки подан потенциал)
            Через время "длительность блокировки" блокировка отключилась (с выхода блокировки снят потенциал)

        Блокировка не включилась:
            Блокировка не включилась (на выход блокировки не подан потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, block_status))
    {
        printf("FAIL Шаг 7\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::resetBrakeAndSetSensorAndCheckBlockOn()
{
    /*!
        Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */
    if (p_gen6->setAndCheckBreak(OFF, PIN))
    {
        printf("PASS Педаль тормоза отключена\n");
    }
    else
    {
        printf("FAIL Педаль тормоза не отключена\n");
        return false;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через время "длительность блокировки" блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL При проверке блокировки\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setBrakeAndCheckBlock(block_statuses_t block_status)
{
    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата

        Блокировка (block_status):
            Блокировка включилась
            ИЛИ
            Блокировка не включилась
    */
    if (p_gen6->setAndCheckBreak(ON, PIN))
    {
        printf("PASS Шаг 5. Педаль тормоза нажата\n");
    }
    else
    {
        printf("FAIL Шаг 5. Педаль тормоза не нажата\n");
        return false;
    }

    switch (block_status)
    {
        case BLOCK_ON:

            if (waitBlock(ON))
            {
                printf("PASS Шаг 5. Блокировка включилась\n");
            }
            else
            {
                printf("FAIL Шаг 5. Блокировка не включилась\n");
                return false;
            }

            break;

        case BLOCK_OFF:
        case BLOCK_NOT_ON:

            if (!waitBlock(ON))
            {
                printf("PASS Шаг 5. Блокировка не включилась\n");
            }
            else
            {
                printf("FAIL Шаг 5. Блокировка включилась\n");
                return false;
            }

            break;

        default:
            printf("FAIL Неизвестный тип проверки блокировки: %d\n", block_status);
            return false;
    }

    return true;
}

bool AutoTestsModesP2::setImmoAndSensorAndCheckBlock(block_statuses_t block_status,
                                                     car_speed_type_t car_speed_type,
                                                     int8_t           car_speed)
{
    command_type_t execution_method = ERROR_TYPE; // Метод снятия с охраны помимо метки
    int8_t         step             = 0;          // Текущий шаг теста (для логирования)


    // Нужен хотя бы один способ снятия с охраны помимо метки
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }
    else
    {
        printf("FAIL Нет ни одного устройства снятия с охраны помимо метки\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | охрана
        ||Зажигание:        | отключено
        ||Дверь:            | закрыта
        ||Скорость:         | 0
        ||Блокировка:       | отключена
        ||Выход блокировки: | отключен
        ||Метка:            | отключена
        ||Паркинг (ручник): | отключен
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return false;
    }

    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не закрыта\n");
        return false;
    }

    if (p_gen6->setAndCheckParking(OFF, PIN))
    {
        printf("PASS Начальные условия. Паркинг выключен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Паркинг не выключен\n");
        return false;
    }

    if (p_gen6->setAndCheckHandBreak(OFF, PIN))
    {
        printf("PASS Начальные условия. Ручник выключен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Ручник не выключен\n");
        return false;
    }

    if (car_speed_type == CAR_SPEED_ON)
    {
        p_gen6->setSpeed(0);
    }

    // Авторизация в ЗП по метке только на устройствах с меткой. На остальных устройствах авторизация по штатным кнопкам
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    if (!p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S))
    {
        printf("PASS Начальные условия. Блокировка отключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Блокировка не отключена\n");
        return false;
    }

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */
    ++step;

    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг %d. Переход из охраны в запрет поездки\n", step);
    }
    else
    {
        printf("FAIL Шаг %d. Переход из охраны в запрет поездки не произошел\n", step);
        return false;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */
    ++step;

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг %d. Зажигание включено\n", step);
    }
    else
    {
        printf("FAIL Шаг %d. Зажигание не включено\n", step);
        return false;
    }

    /*!
        Шаг 3. Включить скорость 20 (car_speed)
    */
    /*!
        Скорость увеличилась до 20 (car_speed)
    */
    if (car_speed_type == CAR_SPEED_ON)
    {
        ++step;

        p_gen6->setSpeed(car_speed);
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение

        Блокировка (block_status):
        Блокировка включилась:
            Через время "задержка блокировки" включилась блокировка (на выход блокировки подан потенциал)
            Через время "длительность блокировки" блокировка отключилась (с выхода блокировки снят потенциал)

        Блокировка не включилась:
            Блокировка не включилась (на выход блокировки не подан потенциал)
    */
    ++step;

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE,
                                  block_status,
                                  NO_CHECK_ALARM)) // Тревога не включается в ЗП по ДД
    {
        printf("FAIL Шаг %d\n", step);
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setDisarmAndSetRemoteAndTagAndIgn()
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return false;
    }

    p_gen6->setTagVcc();

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);
    }

    printf("INFO Ожидание появления метки/брелока\n");
    p_gen6->wait_s(max((float)TIME_DELAY::MAX_TAG_VISIBLE_TIME_S,
                       (float)TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S));

    return true;
}

bool AutoTestsModesP2::setAndResetServiceBySensorNoIgn(int8_t speed_kmph, float delay_s)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Сервисный режим:  | включен
        ||Настроен:         | ДД
        ||Скорость:         | 0 км/ч
        ||Зажигание:        | выключено
    */
    p_gen6->setSpeed(0);

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
        p_gen6->setLcdKeyringVcc(OFF);
    }
    else
    {
        p_gen6->setServiceModeTag(ON);
        p_gen6->resetTagVcc();
    }

    printf("INFO Ожидание потери метки/брелока\n");
    p_gen6->wait_s(max((float)TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S,
                       (float)TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S));

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return false;
    }

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return false;
    }

    // Пропустить СМС о входе в сервис
    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        p_gen6->outputSms();
    }

    /*!
        Шаг 1. Включить скорость speed_kmph км/ч (CAN / GPS)
    */
    /*!
        Скорость: speed_kmph
    */
    p_gen6->setSpeed(speed_kmph);

    /*!
        Шаг 2. Через delay_s сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
        СМС оповещение о выходе из сервиса отсутствует
    */
    p_gen6->wait_s(delay_s);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Сервисный режим не выключен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим выключен\n");
        return false;
    }

    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        if (p_gen6->outputSms(TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
        {
            printf("PASS Шаг 2. СМС оповещение о выходе из сервиса отсутствует\n");
        }
        else
        {
            printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не отсутствует\n");
            return false;
        }
    }
    
    return true;
}

bool AutoTestsModesP2::waitImmoAnalogAndCan(float timeout_s)
{
    Timer      timer;
    const bool polarity  = p_gen6->getPolarity(ID_OUT_IMMO); // Полярность обходчика
    bool       is_analog = false;                            // Получен ли потенциал обходчика (аналог)
    bool       is_can    = false;                            // Получены ли пакеты обходчика   (CAN)


    timer.start();

    while (timer.read() < timeout_s)
    {
        if (!is_analog)
        {
            is_analog = p_gen6->getInspector() == polarity;
        }

        if (!is_can)
        {
            is_can = p_gen6->waitInspectorCan(TIME_DELAY::STD_WIRE_EN_DELAY_S);
        }

        // Обходчик включен, можно больше не ждать
        if (   is_analog
            && is_can)
        {
            return true;
        }
    }

    if (!is_analog)
    {
        printf("INFO Потенциал обходчика не получен (аналог)\n");
    }

    if (!is_can)
    {
        printf("INFO Пакеты обходчика не получены (CAN)\n");
    }

    return false;
}

bool AutoTestsModesP2::resetCanCarNum()
{
    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При выключении индивидуальной прошивки CAN\n");

        return false;
    }

    return true;
}

bool AutoTestsModesP2::runEngAndSetZoneAndCheckState(zone_type_t              zone_type,
                                                     slp_diag_data_statuses_t diag_status)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf("INFO Отсутствуют необходимые модули для проведения теста\n");

            return false;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf("INFO Отсутствуют необходимые модули для проведения теста\n");

            return false;
        }
    }

    /*!
        Шаг 1. Выполнить ДЗ
    */
    /*!
        Через "Задержка включения обхода" включен обход
        Через "Задержка включения первого импульса кнопки Старт-Стоп" модулем запуска включена кнопка Старт-Стоп
    */

    // Если нет метки - значит авторизация по брелку, поэтому его нельзя использовать для ДЗ
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        && (p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        p_gen6->setRemoteRun(SMS);
    }
    else
    {
        p_gen6->setRemoteRun(KEYRING);
    }

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */
    if (p_gen6->checkEngine(m_engine_start_system, TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S) != NO_ENG_ERROR)
    {
        printf("INFO Шаг 2. Двигатель не запущен (ошибка при проверке силового модуля)\n");
        return false;
    }

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                  SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                  DIAG_FLAG_BIT_ENG_RUNNING,
                                  ON,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Шаг 2. Двигатель не запущен (ошибка при проверке статуса в регионе)\n");
        return false;
    }

    /*!
        Шаг 3. Открыть багажник/дверь (zone_type)
    */
    /*!
        Багажник/дверь открыта (zone_type)
        Переход в состояние авторизации произошел/не произошел (diag_status)
        Тревога включилась/не включилась (diag_status)
    */
    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_RUN_ENGINE_TIME_S); // Чтобы не сразу открывать дверь после запуска двигателя

    if (!setAndCheckZone(zone_type, OPEN))
    {
        printf("INFO Шаг 3\n");
        return false;
    }

    if (!p_gen6->waitGuardState(diag_status,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Шаг 3. Система не перешла в ожидаемый статус\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::checkBleSettingsTestsModeOff(bool check_btn_lights, float region_wait_time_s)
{
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_BLE_UPDATER,
                                 OFF,
                                 region_wait_time_s))
    {
        printf("PASS Выход из режима настройки по BLE\n");
    }
    else
    {
        printf("FAIL Не выполнен выход из режима настройки по BLE\n");
        return false;
    }

    if (check_btn_lights)
    {
        if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::MIN_BTN_LIGHTS_COUNT,
                                            TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Сервисный светодиод перестал постоянно моргать\n");
        }
        else
        {
            printf("FAIL Сервисный светодиод не перестал постоянно моргать\n");
            return false;
        }
    }
    else
    {
        wait(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);
    }

    return true;
}

int8_t AutoTestsModesP2::settings_check(options_t *option)
{
    int8_t result                          = AutoTests::settings_check(option);
    string setting_not_found               = option->SL_MASTER_SETTINGS->getDefaultSettingValue();
    string doors_imit_delay                = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::OUTS_CTRL_DOORS_IMIT_PAUSE_MS);
    string doors_imit_time                 = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::OUTS_CTRL_DOORS_IMIT_DURATION_MS);
    string trunk_tag_rem_wait_time         = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::GUARD_TIMINGS_TRUNK_TAG_REM_WAIT_S);
    string tag_rem_for_trunk_needed        = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::GUARD_AUTH_TAG_REM_FOR_TRUNK_NEEDED);
    string eng_block_local0_delay          = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::ENG_BLOCK_LOCAL0_DELAY_S);
    string hf_arm_after_zone_open_delay_s  = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_OPEN_DELAY_S);
    string hf_arm_after_zone_close_delay_s = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::HANDS_FREE_ARM_AFTER_CLOSE_DELAY_S);
    string immo_on_after_ign_off_delay_min = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::GUARD_TIMINGS_IGN_OFF_VALIDATOR_TOUT_MIN);
    string eng_btn_block_time_100ms        = option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::ENG_BTN_BLOCK_TIME_100MS);


    m_engine_block_type               = 0;
    m_gearbox_type                    = ENG_GEARBOX_MANUAL;
    m_is_tag_rem_for_trunk_needed     = SLM_SETTINGS_STATE::INT_SLM_SETTING_NOT_FOUND;
    m_doors_imit_delay_s              = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_doors_imit_time_s               = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_trunk_tag_rem_wait_time_s       = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_eng_block_local0_delay_s        = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_hf_arm_after_zone_open_delay_s  = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_hf_arm_after_zone_close_delay_s = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_immo_on_after_ign_off_delay_s   = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;
    m_eng_btn_block_time_s            = SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND;

    if (doors_imit_delay != setting_not_found)
    {
        m_doors_imit_delay_s = StringConverter<float>::fromString(doors_imit_delay) / TIME_DELAY::MS_TO_SEC_DIVIDER;
    }

    if (doors_imit_time != setting_not_found)
    {
        m_doors_imit_time_s = StringConverter<float>::fromString(doors_imit_time) / TIME_DELAY::MS_TO_SEC_DIVIDER;
    }

    if (trunk_tag_rem_wait_time != setting_not_found)
    {
        m_trunk_tag_rem_wait_time_s = StringConverter<float>::fromString(trunk_tag_rem_wait_time);
    }

    if (tag_rem_for_trunk_needed != setting_not_found)
    {
        m_is_tag_rem_for_trunk_needed = (int8_t)StringConverter<int32_t>::fromString(tag_rem_for_trunk_needed);
    }

    if (eng_block_local0_delay != setting_not_found)
    {
        m_eng_block_local0_delay_s = StringConverter<float>::fromString(eng_block_local0_delay);
    }

    if (hf_arm_after_zone_open_delay_s != setting_not_found)
    {
        m_hf_arm_after_zone_open_delay_s = StringConverter<float>::fromString(hf_arm_after_zone_open_delay_s);
    }

    if (hf_arm_after_zone_close_delay_s != setting_not_found)
    {
        m_hf_arm_after_zone_close_delay_s = StringConverter<float>::fromString(hf_arm_after_zone_close_delay_s);
    }

    if (immo_on_after_ign_off_delay_min != setting_not_found)
    {
        m_immo_on_after_ign_off_delay_s = StringConverter<float>::fromString(immo_on_after_ign_off_delay_min) * TIME_DELAY::MINUTES_TO_SEC_MULTIPLIER;
    }

    if (eng_btn_block_time_100ms != setting_not_found)
    {
        m_eng_btn_block_time_s = StringConverter<float>::fromString(eng_btn_block_time_100ms) / TIME_DELAY::MS100_TO_SEC_DIVIDER;
    }

    if (option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::ENG_START_NEUTRAL_DETECT_TYPE) == "1")
    {
        m_program_neutral_type = NEUTRAL_DETECT_TYPE_DOOR;
    }
    else
    {
        m_program_neutral_type = NEUTRAL_DETECT_TYPE_ARM;
    }

    if (option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::ENG_HEAT_START_TYPE) == "1")
    {
        m_ppo_type = 0;
    }
    else
    {
        m_ppo_type = 1;
    }

    m_ppo_on_before_autostart = StringConverter<int8_t>::fromString(option->SL_MASTER_SETTINGS->get(MASTER_SETTINGS::ENG_HEAT_REMOTE_START_PREHEAT_EN));

    return result;
}

bool AutoTestsModesP2::getAndSetAhjSettings(options_t *option)
{
    string ahj_step_one_value;
    string ahj_step_two_value;
    string ahj_step_three_value;
    string ahj_step_four_value;


    if (!getAhjSettings(option,
                        ahj_step_one_value,
                        ahj_step_two_value,
                        ahj_step_three_value,
                        ahj_step_four_value))
    {
        return false;
    }

    m_ahj_steps_one_and_two_time_s =   StringConverter<float>::fromString(ahj_step_one_value) * 2
                                     + StringConverter<float>::fromString(ahj_step_two_value);

    m_ahj_step_three_time_s = StringConverter<float>::fromString(ahj_step_three_value);
    m_ahj_step_four_time_s  = StringConverter<float>::fromString(ahj_step_four_value);

    m_ahj_wait_time_s =   m_ahj_steps_one_and_two_time_s
                        + m_ahj_step_three_time_s 
                        + m_ahj_step_four_time_s;

    resetLastSlmOption(); // Необходимо, т.к. при сбросе настроек (Gen6Basic::setState) выключается АО по метке
                          // И т.к. настройки могут совпасть с предыдущими, то загрузки настроек и включения АО не будет

    return true;
}

bool AutoTestsModesP2::setSecureAndSensorAndCheckAlert(slp_diag_data_sensors_statuses_t sensor_type)
{
    bool is_r868 = (p_gen6->getModules() & R868_MODULE) == R868_MODULE;
    bool is_ble  = (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE;


    if (m_sensors_mask_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Задержка взятия датчиков под охрану, сек\" не задана\n");
        return false;
    }

    if (   !is_r868
        && !is_ble)
    {
        printf("FAIL Отсутствуют одновременно 2 модуля: R868 и BLE\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Периметр:         | не нарушен
    */
    if (setSecureZoneClosed(ON,
                            KEYRING,
                            DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия\n");
    }
    else
    {
        printf("FAIL Начальные условия\n");
        return false;
    }

    wait(m_sensors_mask_time_s + TIME_DELAY::SENSOR_MASK_ERR_TIME_S); // Ожидание нужно т.к. датчики на некоторое время маскируются после постановки в охрану
                                                                      // Настройка: "Задержка взятия датчиков под охрану, сек"

    // Метка включается для того, чтобы сразу нажать на ней кнопку в тревоге (а не ждать включения, если использовать setSecure)
    // Метка нужна только если нет R868 модуля для прерывания тревоги брелоком
    if (   !is_r868
        &&  is_ble)
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Включилась тревога
    */
    p_gen6->setSensor(sensor_type);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::ALARM_EN_TIME_S + TIME_DELAY::ALARM_EN_ERROR_TIME_S))
    {
        printf("PASS Шаг 1. Включилась тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не включилась тревога\n");
        return false;
    }

    /*!
        Шаг 2. Прервать тревогу брелоком (нажать кнопку 2)
    */
    /*!
        Тревога прекратилась
        Запирание ЦЗ не произошло в течение 10 сек (импульс на выходе ЦЗ закрыть отсутствует)
    */
    if (is_r868) // Прервать тревогу брелоком
    {
        p_gen6->pushLcdKeyringBut2(KEYRING_SHORT);
    }
    else // Если нет брелка - прервать меткой
    {
        p_gen6->pushTagBtn(TAG_SHORT);
    }

    if (!p_gen6->waitCLockClose(TIME_DELAY::MAX_LOCK_PULSE_CHECK_TIME_S, p_gen6->getPolarity(ID_OUT_LOCK_A)))
    {
        printf("PASS Шаг 2. Запирание ЦЗ не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Запирание ЦЗ произошло (импульс на выходе ЦЗ закрыть)\n");
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога прекратилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не прекратилась\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::resetAuthAndImmo()
{
    p_gen6->resetAuthAndImmo(IGN_ON);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек\n");

        return false;
    }

    return true;
}

void AutoTestsModesP2::saveCurrFw()
{
    p_gen6->getFirmwareVersion(m_curr_fw_ver, FW_TYPE_CURRENT);
}

bool AutoTestsModesP2::loadPrevFw()
{
    printf("INFO Загрузка предыдущей версии прошивки основного блока\n");

    if (!p_gen6->loadFirmwareFromServer(FW_DOWNLOAD_TYPE_PREV))
    {
        printf("INFO Ошибка при загрузке предыдущей прошивки основного блока\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::loadCurrFw()
{
    printf("INFO Возвращение на текущую (тестируемую) версию прошивки\n");

    // Метод используется в шаге кейса, но пишем FAIL, т.к. метод используется еще и при сбросе настроек после кейса

    if (   m_curr_fw_ver    == NULL
        || m_curr_fw_ver[0] == 0)
    {
        printf("FAIL Тестируемая (текущая) версия прошивки не задана\n");
        return false;
    }

    p_gen6->setIgn(PIN, OFF);

    if (!p_gen6->loadFirmwareByVersion(m_curr_fw_ver))
    {
        printf("FAIL При загрузке тестируемой (текущей) прошивки основного блока\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setDisarmAndCheckRelayHoodUnlock(relay_type_t relay_type)
{
    printf("INFO Снятие с охраны и проверка отпирания замка капота через реле\n");
    p_gen6->setSecureNoDelay(OFF, KEYRING);

    switch (relay_type)
    {
        case RELAY_TYPE_R4:

            if (!p_gen6->waitR4LockAndUnlock(RELAY_NULL_PULSE,
                                             RELAY_ONE_PULSE))
            {
                printf("INFO Замок капота R4 не открылся\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6:

            if (!p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE,
                                             RELAY_ONE_PULSE))
            {
                printf("INFO Замок капота R6 не открылся\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6ECO:

            if (!(   p_gen6->getR6Eco()->waitHoodLockOpen(TIME_DELAY::MAX_HOOD_SIGNAL_WAIT_TIME_S,  p_gen6->getR6Eco()->getPolarity(ID_OUT_HOOD_LOCK_B))
                  && p_gen6->getR6Eco()->waitHoodLockOpen(TIME_DELAY::MAX_WIRE_EN_DELAY_S,         !p_gen6->getR6Eco()->getPolarity(ID_OUT_HOOD_LOCK_B))))
            {
                printf("INFO Замок капота R6 ECO не открылся\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип подкапотного реле: %d\n", relay_type);
            return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Охрана не отключена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setArmAndCheckRelayHoodLock(relay_type_t relay_type)
{
    printf("INFO Постановка в охрану и проверка запирания замка капота через реле\n");
    p_gen6->setSecureNoDelay(ON, KEYRING);

    switch (relay_type)
    {
        case RELAY_TYPE_R4:

            if (!p_gen6->waitR4LockAndUnlock(RELAY_ONE_PULSE,
                                             RELAY_NULL_PULSE))
            {
                printf("INFO Замок капота R4 не заперт\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6:

            if (!p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE,
                                             RELAY_NULL_PULSE))
            {
                printf("INFO Замок капота R6 не заперт\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6ECO:

            if (!(   p_gen6->getR6Eco()->waitHoodLockClose(TIME_DELAY::MAX_HOOD_SIGNAL_WAIT_TIME_S,  p_gen6->getR6Eco()->getPolarity(ID_OUT_HOOD_LOCK_A))
                  && p_gen6->getR6Eco()->waitHoodLockClose(TIME_DELAY::MAX_WIRE_EN_DELAY_S,         !p_gen6->getR6Eco()->getPolarity(ID_OUT_HOOD_LOCK_A))))
            {
                printf("INFO Замок капота R6 ECO не заперт\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип подкапотного реле: %d\n", relay_type);
            return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Охрана не включена\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAlertAndCheckRelayBlock(relay_type_t relay_type)
{
    printf("INFO Вызов тревоги и проверка блокировки через реле\n");

    if (!p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("INFO Зажигание не включено\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Тревога не включена\n");
        return false;
    }

    switch (relay_type)
    {
        case RELAY_TYPE_R4:

            p_gen6->setR4Ign();

            if (!p_gen6->waitR4Block(ON))
            {
                printf("INFO Блокировка на R4 не включена\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6:

            if (!waitR6Block(ON))
            {
                printf("INFO Блокировка на R6 не включена\n");
                return false;
            }

            break;

        case RELAY_TYPE_R6ECO:

            if (!waitR6EcoBlock(ON))
            {
                printf("INFO Блокировка на R6 ECO не включена\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип подкапотного реле: %d\n", relay_type);
            return false;
    }

    return true;
}

bool AutoTestsModesP2::setFwAndCheckRelay(fw_update_type_t fw_update_type,
                                          relay_type_t     relay_type)
{

    const char special_fw_ver[] = "2.18.0"; // Для некоторых кейсов нужна версия ПО младше 2.18.0 (будем скачивать предыдущие прошивки относительно этой версии)


    switch (fw_update_type)
    {
        // Тестируется работа реле после обновления с предыдущей прошивки на текущую
        case FW_UPDATE_FROM_PREV_TO_CURR:

            if (!p_gen6->loadFirmwareFromServer(FW_DOWNLOAD_TYPE_PREV))
            {
                printf("INFO Ошибка при загрузке предыдущей прошивки основного блока\n");
                return false;
            }

            break;

        // Тестируется работа реле после обновления с текущей прошивки на предыдущую
        case FW_UPDATE_FROM_CURR_TO_PREV:
            // При запуске теста мы уже на тестируемой (текущей) прошивке
            break;

        // Тестируется работа реле после обновления со специальной прошивки на текущую
        case FW_UPDATE_FROM_SPECIAL_TO_CURR:

            if (!p_gen6->loadFirmwareFromServer(FW_DOWNLOAD_TYPE_PREV,
                                                TIME_DELAY::MAX_WAITING_FW_TIME_S,
                                                special_fw_ver))
            {
                // Если не получилось скачать предыдущую версию ПО относительно особой - попробуем скачать самую старую
                if (!p_gen6->loadFirmwareFromServer(FW_DOWNLOAD_TYPE_OLDEST))
                {
                    printf("INFO Ошибка при загрузке особой прошивки основного блока\n");
                    return false;
                }
            }

            break;

        default:
            printf("INFO Неизвестный тип обновления ПО: %d\n", fw_update_type);
            return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                     | Охрана
        ||Зажигание:                        | выключено
        ||Брелок:                           | включен
        ||К ЦБ подключен и зарегистрирован: | R4
        ||Прошивка ЦБ:                      | зависит от параметра fw_update_type
        **Примечание:** *на ЦБ установлена прошивка согласно fw_update_type*
    */
    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Начальные условия. Зажигание не выключено\n");
        return false;
    }

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("INFO Начальные условия. Охрана не включена\n");
        return false;
    }

    p_gen6->wait_s(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Пропустить сигналы после постановки

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        Реле relay_type отпирает замок капота
    */

    // В кейсах на R6 ECO не проверяется отпирание замка (проверяются 2 канала: запирание и блокировка)
    if (relay_type == RELAY_TYPE_R6ECO)
    {
        if (!p_gen6->setAndCheckSecure(OFF,
                                       KEYRING,
                                       DIAG_GUARD_STATE_DISARM))
        {
            printf("INFO Шаг 1. Переход в снято не произошел\n");
            return false;
        }
    }
    else
    {
        if (!setDisarmAndCheckRelayHoodUnlock(relay_type))
        {
            printf("INFO Шаг 1. Ошибка при проверке замка капота\n");
            return false;
        }
    }

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую/предыдущую (fw_update_type)
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую/предыдущую (fw_update_type)
    */
    switch (fw_update_type)
    {
        // Обновление на текущую версию ПО
        case FW_UPDATE_FROM_PREV_TO_CURR:
        case FW_UPDATE_FROM_SPECIAL_TO_CURR:

            if (!loadCurrFw())
            {
                printf("INFO Шаг 2. Прошивка ЦБ не обновлена на текущую (тестируемую)\n");
                return false;
            }

            break;

        // Обновление на предыдущую версию ПО
        case FW_UPDATE_FROM_CURR_TO_PREV:

            if (!loadPrevFw())
            {
                printf("INFO Шаг 2. Прошивка ЦБ не обновлена на предыдущую\n");
                return false;
            }

            break;

        default:
            printf("INFO Шаг 2. Неизвестный тип обновления ПО: %d\n", fw_update_type);
            return false;
    }

    p_gen6->wait_s(TIME_DELAY::R6_CONN_WAIT_TIME_S); // Ожидание восстановления связи ЦБ и R6

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        Реле relay_type запирает замок капота
    */
    if (!setArmAndCheckRelayHoodLock(relay_type))
    {
        printf("INFO Шаг 3. Ошибка при проверке замка капота\n");
        return false;
    }

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        Реле relay_type включает блокировку
    */
    if (!setAlertAndCheckRelayBlock(relay_type))
    {
        printf("INFO Шаг 4. Ошибка при проверке блокировки\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckAltSrvBtnDisarm(slp_diag_data_statuses_t diag_guard_state,
                                                  alt_srv_btn_type_t       alt_srv_btn_type,
                                                  srv_btn_pin_type_t       pin_type,
                                                  emergency_dis_pin_num_t  emergency_dis_wrong_pin_num)
{
    /*!
        Если тип альт. сервисной кнопки зажигание или дверь (alt_srv_btn_type):
            Открыть дверь
        Если тип альт. сервисной кнопки штатные кнопки (alt_srv_btn_type):
            Включить зажигание
    */
    /*!
        Дверь открыта/зажигание включено
        Включена тревога/ожидание авторизации
    */
    switch (alt_srv_btn_type)
    {
        case ALT_SRV_BTN_TYPE_DOOR:
        case ALT_SRV_BTN_TYPE_IGN:

            if (!p_gen6->setAndCheckDoor(OPEN, PIN))
            {
                printf("INFO Дверь не открыта\n");
                return false;
            }

            break;

        case ALT_SRV_BTN_TYPE_STD_BTN:

            if (!p_gen6->setAndCheckIgn(ON, PIN))
            {
                printf("INFO Зажигание не включено\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип альтернативной сервисной кнопки: %d\n", alt_srv_btn_type);
            return false;
    }

    if (!p_gen6->waitGuardState(diag_guard_state,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Состояние системы не соответствует ожидаемому\n");
        return false;
    }

    /*!
        Если тип альт. сервисной кнопки зажигание или дверь (alt_srv_btn_type):
            В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери: 4 раза закрыть и открыть дверь
        Если тип альт. сервисной кнопки штатные кнопки (alt_srv_btn_type):
            Шаг пропущен
    */
    /*!
        Тип альт. сервисной кнопки: дверь или зажигание:
            Зафиксировано 4 закрывания и открывания двери
            Дверь осталась открытой
            Световые сигналы отключились
        Тип альт. сервисной кнопки: штатные кнопки:
            Через 5 сек (внутренний таймаут) световые сигналы отключились
            Вспышка (импульс) световыми сигналами
    */
    if (!p_gen6->setAndCheckAltSrvBtnModeEn(alt_srv_btn_type))
    {
        printf("INFO Режим альтернативной сервисной кнопки не включился\n");
        return false;
    }

    /*!
        По типу альт. сервисной кнопки (alt_srv_btn_type):
        Закрыть и открыть дверь A раз, где A - цифра отличная/не отличная от первой цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Включить и отключить зажигание A раз, где A - цифра отличная/не отличная от первой цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Нажать штатную кнопку "Да" в imitCan A раз, где A - цифра отличная/не отличная от первой цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        По типу альт. сервисной кнопки (alt_srv_btn_type):
        Закрыть и открыть дверь B раз, где B - цифра отличная/не отличная от второй цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Включить и отключить зажигание B раз, где B - вторая цифра отличная/не отличная от второй цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра отличная/не отличная от второй цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        По типу альт. сервисной кнопки (alt_srv_btn_type):
        Закрыть и открыть дверь X раз, где X - цифра отличная/не отличная от третьей цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Включить и отключить зажигание X раз, где X - третья цифра отличная/не отличная от третьей кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
        ИЛИ
        Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра отличная/не отличная от второй цифры кода экстренного снятия с охраны (emergency_dis_wrong_pin_num)
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        По типу альт. сервисной кнопки (alt_srv_btn_type):
        Закрыть и открыть дверь Y раз, где Y - цифра отличная/не отличная от четвертой цифры кода экстренного снятия с охраны
        ИЛИ
        Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
        ИЛИ
        Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра отличная/не отличная от третьей кода экстренного снятия с охраны
    */
    /*!
        Проверка (pin_type):
            Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
            Переход в снято
        ИЛИ
            Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
            Переход в снято не произошел
    */
    if (pin_type == SRV_BTN_PIN_TYPE_CORRECT)
    {
        if (!p_gen6->setAltSrvBtnDisarm(alt_srv_btn_type))
        {
            printf("INFO Проверка алгоритма ввода кода экстренного снятия через альт. сервисную кнопку неуспешна\n");
            return false;
        }

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                    ON,
                                    TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("INFO Переход в снято не произошел\n");
            return false;
        }
    }
    else
    {
        if (!p_gen6->setAltSrvBtnDisarm(alt_srv_btn_type, p_gen6->getWrongDevicePin(emergency_dis_wrong_pin_num)))
        {
            printf("INFO Проверка алгоритма ввода кода экстренного снятия через альт. сервисную кнопку неуспешна\n");
            return false;
        }

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("INFO Произошел переход в снято\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckAltSrvBtnArmFail(alt_srv_btn_type_t alt_srv_btn_type)
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | снято
        ||Дверь:            | закрыта
        ||Багажник:         | закрыт
        ||Метка:            | выключена
        ||Брелок:           | включен
        ||Ручник:           | затянут
        ||Паркинг:          | включен
        ||Двигатель:        | заглушен
        ||Зажигание:        | выключено
        ||Обороты:          | выключены
    */
    if (!setProgramNeutralAuto(GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return false;
    }

    /*!
        Включить зажигание
        ИЛИ
        Открыть дверь
        Включить зажигание
    */
    /*!
        Дверь открыта (если открывалась)
        Зажигание включено
    */
    if (alt_srv_btn_type == ALT_SRV_BTN_TYPE_DOOR)
    {
        if (!p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("INFO Дверь не открыта\n");
            return false;
        }
    }

    if (!p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("INFO Зажигание не включено\n");
        return false;
    }

    /*!
        Нажать штатную кнопку "Да" в imitCan 3 раза
        ИЛИ
        3 раза закрыть и открыть дверь
    */
    /*!
        Нет изменений
        ИЛИ
        Дверь открыта
    */
    p_gen6->clickAltSrvBtn(alt_srv_btn_type, COUNT_STRUCT::ALT_SRV_BTN_MODE_ARM_CLICKS_COUNT);

    if (alt_srv_btn_type == ALT_SRV_BTN_TYPE_DOOR)
    {
        if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                      SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                      DIAG_PERIM_BIT_DOORS,
                                      ON,
                                      TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("INFO Дверь не открыта\n");
            return false;
        }
    }

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Зажигание не отключено\n");
        return false;
    }

    /*!
        Не ранее чем через 5 сек (внутренний таймаут) включить зажигание
    */
    /*!
        Зажигание включено
    */
    p_gen6->wait_s(TIME_DELAY::ALT_SRV_BTN_ARM_EN_TIMEOUT_S + TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("INFO Зажигание не включено\n");
        return false;
    }

    /*!
        Нажать штатную кнопку "Да" в imitCan 3 раза
        ИЛИ
        3 раза закрыть и открыть дверь
    */
    /*!
        Через 5 сек (внутренний таймаут) сигнала сирены отсутствуют
    */
    p_gen6->clickAltSrvBtn(alt_srv_btn_type, COUNT_STRUCT::ALT_SRV_BTN_MODE_ARM_CLICKS_COUNT);

    // На системах с буззером - оповещение о постановке выводится на буззер (аналогично постановке через обычную сервисную кнопку)
    if (p_gen6->getDeviceName() != GEN6_X96V2)
    {
        if (p_gen6->waitSiren(TIME_DELAY::ALT_SRV_BTN_ARM_EN_TIMEOUT_S + TIME_DELAY::MAX_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_SIREN)))
        {
            printf("INFO Получен сигнал сирены\n");
            return false;
        }
    }
    else
    {
        if (p_gen6->waitBuzzerExt(ON, TIME_DELAY::ALT_SRV_BTN_ARM_EN_TIMEOUT_S + TIME_DELAY::MAX_WIRE_EN_DELAY_S))
        {
            printf("INFO Получен сигнал внешнего звукоизвещателя\n");
            return false;
        }
    }

    /*!
        Выключить зажигание
        ИЛИ
        Выключить зажигание
        Закрыть дверь
    */
    /*!
        Зажигание отключено
        Дверь закрыта (если закрывалась)
        В течение 20 сек после выключения зажигания (внутренний таймаут) и позднее переход в охрану не произошел
    */
    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Зажигание не отключено\n");
        return false;
    }

    if (alt_srv_btn_type == ALT_SRV_BTN_TYPE_DOOR)
    {
        if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
        {
            printf("INFO Дверь не закрыта\n");
            return false;
        }
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::ALT_SRV_BTN_ARM_EN_WAIT_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("INFO Произошел переход в охрану\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::emergencyDisarming()
{
    p_gen6->setIgn(PIN,
                   OFF,
                   TIME_DELAY::MAX_WIRE_EN_DELAY_S);
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->emergencyDisarming();
}

bool AutoTestsModesP2::setWaitingAuthAndCheckHandsFreeTimings(zone_type_t            zone_type,
                                                              alert_check_statuses_t alert_check_status)
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf("INFO Отсутствуют необходимые модули для проведения теста\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Дверь:            | закрыта
        ||Багажник:         | закрыт
        ||Метка:            | выключена
        ||Брелок:           | включен
        ||Ручник:           | затянут
        ||Паркинг:          | включен
        ||Двигатель:        | заглушен
        ||Зажигание:        | выключено
        ||Обороты:          | выключены
    */
    if (!setProgramNeutralAuto())
    {
        printf("INFO Начальные условия\n");
        return false;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   getExecutionMethodDisarmNoTag(),
                                   DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("INFO Шаг 1. Переход из охраны в ожидание авторизации не произошел\n");
        return false;
    }

    /*!
        Шаг 2. Открыть zone_type
    */
    /*!
        zone_type открыта:
            Через 15 сек (Ожидание авторизации, шаг 1) переход в тревогу
            Через 25 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром не произошел
            Тревога продолжается
        ИЛИ
            Через 10 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром
            Через 20 сек (Ожидание авторизации, шаг 1) переход в тревогу не произошел
    */
    if (!setAndCheckZone(zone_type, OPEN))
    {
        printf("INFO Шаг 2\n");
        return false;
    }

    if (alert_check_status == ALERT_CHECK_ON)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    m_auth_step_one_time_s,
                                    TimeoutCalculator::calcToutError(m_auth_step_one_time_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
        {
            printf("INFO Шаг 2. Переход в тревогу не произошел\n");
            return false;
        }

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                   OFF,
                                   TimeoutCalculator::calcTimeWithError(m_hf_arm_after_zone_open_delay_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
        {
            printf("INFO Шаг 2. Тревога отключилась\n");
            return false;
        }
    }
    else
    {

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    m_hf_arm_after_zone_open_delay_s,
                                    TimeoutCalculator::calcToutError(m_hf_arm_after_zone_open_delay_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
        {
            printf("INFO Шаг 2. Переход в охрану с нарушенным периметром не произошел\n");
            return false;
        }

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                   ON,
                                   TimeoutCalculator::calcTimeWithError(m_auth_step_one_time_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
        {
            printf("INFO Шаг 2. Произошел переход в тревогу\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setBleSettingsModeClicksAndWaitLight()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует BLE модуль\n");
        return false;
    }

    printf("INFO Нажатие сервисной кнопки и ожидание подтверждения светом (включение/отключение режима настройки по BLE)\n");

    for (uint8_t i = 0; i < COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
    }

    p_gen6->wait_s(TIME_DELAY::BTN_LED_ON_AFTER_BLE_MODE_CLICKS_DELAY_S + TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (p_gen6->getDeviceName() != GEN6_X96V2)
    {
        if (!p_gen6->isServiceLedOn())
        {
            printf("INFO Светодиод сервисной кнопки не включился\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::checkBleSettingsModeIndication(out_statuses_t out_status)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует BLE модуль\n");
        return false;
    }

    printf("INFO Проверка сервисного светодиода после включения/выключения режима настройки по BLE\n");

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf("INFO Светодиод на трансивере не проверяется, ожидание окончания сигналов\n");
        p_gen6->wait_s(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);

        return true;
    }

    if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT,
                                        TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
    {
        printf("INFO Отсутствует 9-кратное подтверждение сервисным светодиодом\n");
        return false;
    }

    if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                        TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S))
    {
        printf("INFO Отсутствует 2-кратное подтверждение сервисным светодиодом\n");
        return false;
    }

    if (out_status == ON)
    {
        if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_ALWAYS_BLINK_LED_LIGHTS_COUNT,
                                            TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("INFO Сервисный светодиод не начал постоянно моргать\n");
            return false;
        }
    }
    else
    {
        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::MIN_BTN_LIGHTS_COUNT,
                                           TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("INFO Сервисный светодиод не перестал постоянно моргать\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckBleSettingsMode(out_statuses_t              out_status,
                                                  ble_settings_mode_en_type_t ble_settings_mode_en_type)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует BLE модуль\n");
        return false;
    }

    if (out_status == ON)
    {
        printf("INFO Включение и проверка режима настройки по BLE\n");
    }
    else
    {
        printf("INFO Отключение и проверка режима настройки по BLE\n");
    }

    switch (ble_settings_mode_en_type)
    {
        case BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN:

            for (uint8_t i = 0; i < COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT; ++i)
            {
                p_gen6->clickServiceBtn();
                wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
            }

            if (!p_gen6->setAndCheckIgn(ON, PIN))
            {
                printf("INFO Зажигание не включено\n");
                return false;
            }

            if (!checkBleSettingsModeIndication(out_status))
            {
                printf("INFO Ошибка при проверке индикации режима настройки по BLE\n");
                return false;
            }

            break;

        case BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN_NO_IGN:

            if (!setBleSettingsModeClicksAndWaitLight())
            {
                printf("INFO Ошибка при включении режима настройки по BLE\n");
                return false;
            }

            p_gen6->clickServiceBtn();

            if (!checkBleSettingsModeIndication(out_status))
            {
                printf("INFO Ошибка при проверке индикации режима настройки по BLE\n");
                return false;
            }

            break;

        case BLE_SETTINGS_MODE_EN_TYPE_SMS:

            if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
            {
                printf("INFO Отсутствует модуль для работы с SMS\n");
                return false;
            }

            if (out_status == ON)
            {
                if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[SHIELD_PHONE_NO_1],
                                                               SMS_CMD_TOKENS_RUS::SMS_PARSE_CMD_BLE_SETTINGS_MODE_SET,
                                                               Sim900::combineStr("%s\n%s",
                                                                                  SMS_MSG_STR::SMS_ANSW_STR_BLE_SETTINGS_MODE_ON,
                                                                                  SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM).c_str()) != SIM900ACT_TRUESMS)
                {
                    printf("INFO Ответное СМС не получено или неверно\n");
                    return false;
                }

                if (p_gen6->getDeviceName() != GEN6_X96V2)
                {
                    if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_ALWAYS_BLINK_LED_LIGHTS_COUNT,
                                                        TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
                    {
                        printf("INFO Сервисный светодиод не начал постоянно моргать\n");
                        return false;
                    }
                }
            }
            else
            {
                if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[SHIELD_PHONE_NO_1],
                                                               SMS_CMD_TOKENS_RUS::SMS_PARSE_CMD_BLE_SETTINGS_MODE_RESET,
                                                               Sim900::combineStr("%s\n%s",
                                                                                  SMS_MSG_STR::SMS_ANSW_STR_BLE_SETTINGS_MODE_OFF,
                                                                                  SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM).c_str()) != SIM900ACT_TRUESMS)
                {
                    printf("INFO Ответное СМС не получено или неверно\n");
                    return false;
                }

                if (p_gen6->getDeviceName() != GEN6_X96V2)
                {
                    if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::MIN_BTN_LIGHTS_COUNT,
                                                       TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
                    {
                        printf("INFO Сервисный светодиод не перестал постоянно моргать\n");
                        return false;
                    }
                }
            } // if (out_status == ON)

            break;

        default:
            printf("INFO Неизвестный способ включения режима настройки по BLE: %d\n", ble_settings_mode_en_type);
            return false;
    }

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                  SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                  DIAG_EEFLAG_SYSDATA::ID_FLAG_BLE_UPDATER,
                                  out_status,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Статус режима настройки по BLE не соответствует ожидаемому\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::checkServiceLedInBleSettingsMode(mobile_conn_type_t mobile_conn_type, float timeout_s)
{
    // Погрешности измерения импульсов сервисного светодиода
    // Погрешность 25% т.к. низкой точности измерения на автостенде (из-за множества printf и вызовов методов)
    const float srv_led_pulse_err_time_s       = TimeoutCalculator::calcToutError(TIME_DELAY::BTN_LED_MODE_BLE_PULSE_WIDTH_S,           PERCENT::TWENTY_FIVE_PERCENT);
    const float srv_led_short_pause_err_time_s = TimeoutCalculator::calcToutError(TIME_DELAY::BTN_LED_MODE_BLE_PULSE_IN_SERIES_PAUSE_S, PERCENT::TWENTY_FIVE_PERCENT); // Короткая пауза: в серии импульсов
    const float srv_led_long_pause_err_time_s  = TimeoutCalculator::calcToutError(TIME_DELAY::BTN_LED_MODE_BLE_PULSE_PAUSE_S,           PERCENT::TWENTY_FIVE_PERCENT); // Длинная пауза: между сериями импульсов

    Timer   timer;                                                                   
    uint8_t led_pause_counter          = 0;                                          // Счетчик кол-ва пауз между импульсами сервисного светодиода
    float   srv_led_pause_time_s       = TIME_DELAY::BTN_LED_MODE_BLE_PULSE_PAUSE_S; // Длитеьность паузы между импульсами сервисного светодиода
    float   srv_led_pause_err_time_s   = srv_led_long_pause_err_time_s;              // Погрешность паузы между импульсами сервисного светодиода
    float   srv_led_pause_start_time_s = TIME_DELAY::NULL_DELAY_S;                   // Время начала паузы между импульсами сервисного светодиода


    printf("INFO Проверка сервисного светодиода в режиме настройки по BLE, время проверки: %.2f\n", timeout_s);
    timer.start();

    // Синхронизируемся по получению длинной паузы между вспышками сервисного светодиода
    while (timer.read() < timeout_s)
    {
        p_gen6->waitServiceLed(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S);

        if (timer.read() - srv_led_pause_start_time_s > TIME_DELAY::BTN_LED_MODE_BLE_PULSE_PAUSE_S - srv_led_pause_err_time_s)
        {
            printf("INFO Выполнена синхронизация по длинной паузе между вспышками сервисного светодиода\n");
            break;
        }

        p_gen6->waitServiceLed(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S);

        srv_led_pause_start_time_s = timer.read();
    }

    // Проверяем длительность и паузу между вспышками
    while (timer.read() < timeout_s)
    {
        // Если установлена связь со смартфоном, то там особые длительности паузы
        if (mobile_conn_type == MOBILE_CONNECTED)
        {
            // Если пауза в серии импульсов, то она короткая
            // Если пауза между сериями импульсов, то она длинная
            if (led_pause_counter % COUNT_STRUCT::BTN_MODE_BLE_LIGHT_SERIES_COUNT == 0)
            {
                srv_led_pause_time_s     = TIME_DELAY::BTN_LED_MODE_BLE_PULSE_IN_SERIES_PAUSE_S;
                srv_led_pause_err_time_s = srv_led_short_pause_err_time_s;
            }
            else
            {
                srv_led_pause_time_s     = TIME_DELAY::BTN_LED_MODE_BLE_PULSE_PAUSE_S;
                srv_led_pause_err_time_s = srv_led_long_pause_err_time_s;
            }

            ++led_pause_counter;
        }

        if (    p_gen6->waitServiceLed(OFF, TIME_DELAY::BTN_LED_MODE_BLE_PULSE_WIDTH_S - srv_led_pulse_err_time_s)
            || !p_gen6->waitServiceLed(OFF, srv_led_pulse_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("INFO Проверка неуспешна: светодиод не отключился или отключился раньше времени\n");
            return false;
        }

        if (    p_gen6->waitServiceLed(ON, srv_led_pause_time_s - srv_led_pause_err_time_s)
            || !p_gen6->waitServiceLed(ON, srv_led_pause_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("INFO Проверка неуспешна: светодиод не включился или включился раньше времени\n");
            return false;
        }
    }

    printf("INFO Проверка сервисного светодиода успешна\n");

    return true;
}

bool AutoTestsModesP2::setAhjAndCheckSms(ahj_type_t ahj_type)
{
    float tag_rem_visible_time_s = TIME_DELAY::NULL_DELAY_S; // Время ожидания появления метки/брелока


    if (   ahj_type                            == AHJ_TYPE_TAG_OFF
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует модуль для работы с меткой\n");
        return false;
    }

    if (   ahj_type                             == AHJ_TYPE_REMOTE_OFF
        && (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf("INFO Отсутствует модуль для работы с брелком\n");
        return false;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | снято
        ||Зажигание:        | включено
        ||Дверь:            | закрыта
        ||Метка:            | включена
        ||Брелок:           | включен
        ||Паркинг:          | отключен
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("INFO Начальные условия. Автомобиль не в снято\n");
        return false;
    }

    if (!p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("INFO Начальные условия. Зажигание не включено\n");
        return false;
    }

    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("INFO Начальные условия. Дверь не закрыта\n");
        return false;
    }

    if (!p_gen6->setAndCheckParking(OFF, PIN))
    {
        printf("INFO Начальные условия. Паркинг не отключен\n");
        return false;
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();

        tag_rem_visible_time_s = max(tag_rem_visible_time_s,
                                     (float)TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);

        tag_rem_visible_time_s = max(tag_rem_visible_time_s,
                                     (float)TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    printf("INFO Ожидание появления метки/брелока\n");
    p_gen6->wait_s(tag_rem_visible_time_s);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("INFO Шаг 1. Дверь не открыта\n");
        return false;
    }

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("INFO Шаг 2. Дверь не закрыта\n");
        return false;
    }

    /*!
        Шаг 3. Выключить метку/брелок (ahj_type)
    */
    /*!
        Метка/брелок потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        На М1 отправлено СМС "Тревога! Антиограбление по потере блютуз-метки/брелока. Если блютуз-метка/брелок находятся в автомобиле, то необходимо заменить батарейку."
    */
    if (!resetTagOrRemoteAndCheckAhj(ahj_type,
                                     AHJ_STATUS_TAG)) // В регионе нет отдельного статуса АО по брелку, поэтому всегда проверяем статус АО по метке
    {
        printf("INFO Шаг 3-4\n");
        return false;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(Sim900::combineStr("%s %s %s",
                                                                   SMS_MSG_STR::SMS_ANSW_STR_ALERT,
                                                                   SMS_MSG_STR::SMS_ANSW_STR_AHJ_TAG_REM,
                                                                   SMS_MSG_STR::SMS_ANSW_STR_AHJ_TAG_REM_LOW_VOLTAGE).c_str(),
                                                TIME_DELAY::STD_WAITING_SMS_TIME_S) != SIM900ACT_TRUESMS)
    {
        printf("INFO Шаг 4. СМС оповещение не получено\n");
        return false;
    }

    /*!
        Шаг 5. Включить метку/брелок (ahj_type)
    */
    /*!
        Метка/брелок найдена
        СМС оповещение отсутствует
    */
    switch (ahj_type)
    {
        case AHJ_TYPE_TAG_OFF:
            p_gen6->setTagVcc();
            break;

        case AHJ_TYPE_REMOTE_OFF:
            p_gen6->setLcdKeyringVcc(ON);
            break;

        default:
            printf("INFO Шаг 5. Неизвестный тип активации АО: %d\n", ahj_type);
            return false;
    }

    if (p_gen6->outputSms(TIME_DELAY::STD_WAITING_SMS_TIME_S) != SIM900ACT_NOSMS)
    {
        printf("INFO Шаг 5. Получено СМС оповещение после включения метки/брелока\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::setTagAndRemoteVcc(tag_statuses_t    tag_status,
                                          remote_statuses_t remote_status)
{
    float delay_s = TIME_DELAY::NULL_DELAY_S; // Задержка после управления питанием


    printf("INFO Управление питанием метки и брелока (при наличии соответствующих модулей)\n");

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        if (tag_status == TAG_ON)
        {
            printf("INFO Включение питания метки\n");
            p_gen6->setTagVcc();

            delay_s = max(delay_s,
                          (float)TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        }
        else
        {
            printf("INFO Отключение питания метки\n");
            p_gen6->resetTagVcc();

            delay_s = max(delay_s,
                          (float)TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
        }
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        if (remote_status == REMOTE_ON)
        {
            printf("INFO Включение питания брелока\n");
            p_gen6->setLcdKeyringVcc(ON);

            delay_s = max(delay_s,
                          (float)TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
        }
        else
        {
            printf("INFO Отключение питания брелока\n");
            p_gen6->setLcdKeyringVcc(OFF);

            delay_s = max(delay_s,
                          (float)TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
        }
    }

    printf("INFO Ожидание пропадания/появления метки/брелока\n");
    p_gen6->wait_s(delay_s);
}

bool AutoTestsModesP2::setTrunkAndCheckAlarm(alert_statuses_t alert_status, float time_s)
{
    Timer timer;                                                 // Таймер, нужен для подсчета времени, затраченного на проверку включения охраны с открытым багажником
    float time_err_s = TimeoutCalculator::calcToutError(time_s); // Погрешность ожидания тревоги


    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт:
            Через time_s сек. включена тревога
            ИЛИ
            Охрана с откр. багажником включена
            Через time_s сек. тревога не включилась
    */
    p_gen6->setTrunk(OPEN,                      // Без проверки по SLP, т.к. нужно сразу проверять тайминги тревоги
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    switch (alert_status)
    {
        case ALERT_ON:

            if (p_gen6->waitLightAndAlarm(time_s - time_err_s))
            {
                printf("INFO Тревога включилась раньше времени\n");
                return false;
            }

            if (!p_gen6->waitLightAndAlarm(time_err_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
            {
                printf("FAIL Тревога не включилась\n");
                return false;
            }

            if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                        ON,
                                        TIME_DELAY::MIN_WAITING_REGION_STATE_S))
            {
                printf("INFO Тревога не включилась (регион)\n");
            }

            break;

        case ALERT_OFF:

            timer.start();

            // Проверка входа в охрану с откр. багажником по проводу
            // Чтобы эти импульсы не мешали при проверке тревоги
            if (!(   p_gen6->waitLights(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S,  p_gen6->getPolarity(ID_OUT_LIGHTS))
                  && p_gen6->waitLights(TIME_DELAY::MAX_WIRE_EN_DELAY_S,       !p_gen6->getPolarity(ID_OUT_LIGHTS))))
            {
                printf("INFO Охрана с открытым багажником не включена\n");
                return false;
            }

            wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
            timer.stop();

            if (p_gen6->waitLightAndAlarm(time_s + time_err_s - timer.read()))
            {
                printf("INFO Тревога включилась\n");
                return false;
            }

            if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                       ON,
                                       TIME_DELAY::MIN_WAITING_REGION_STATE_S))
            {
                printf("INFO Тревога включилась (регион)\n");
                return false;
            }

            if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                         SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                         DIAG_GUARD_STATE_ARM_TRUNK))
            {
                printf("INFO Охрана с откр. багажником не включена (регион)\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип проверки тревоги: %d\n", alert_status);
            return false;
    }

    return true;
}

bool AutoTestsModesP2::checkStartStopBtnBlock(start_btn_check_pulses_count_t start_btn_check_pulses_count,
                                              float                          no_pulses_check_time_s)
{
    const bool  polarity    = p_gen6->getPolarity(ID_OUT_START_STOP_BTN);                                // Полярность кнопки Старт-Стоп
    const float pause_err_s = TimeoutCalculator::calcToutError(TIME_DELAY::START_STOP_BTN_PAUSE_TIME_S); // Погрешность паузы между нажатиями кнопки Старт-Стоп

    float       pulse_err_s;                                                                             // Погрешность длительности импульса кнопки Старт-Стоп


    printf("INFO Проверка блокировки двигателя кнопкой Старт-Стоп\n");

    if (m_eng_btn_block_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("INFO Настройка \"Длительность импульса на кнопку старт-стоп\" не задана\n");
        return false;
    }

    pulse_err_s = TimeoutCalculator::calcToutError(m_eng_btn_block_time_s);

    // Ожидаем первое нажатие
    if (start_btn_check_pulses_count > 0)
    {
        if (!p_gen6->waitStartStopBtn(TIME_DELAY::MAX_STD_BLOCK_WAIT_TIME_S, polarity))
        {
            printf("INFO Кнопка Старт-Стоп не нажата\n");
            return false;
        }
    }

    // Проверка длительности и паузы между нажатиями кнопки Старт-Стоп
    for (uint8_t i = 1; i <= start_btn_check_pulses_count; ++i)
    {
        p_gen6->setPolarity(ID_OUT_START_STOP_BTN);

        if (!p_gen6->checkPulseWidth(ID_OUT_START_STOP_BTN,
                                     m_eng_btn_block_time_s,
                                     m_eng_btn_block_time_s + pause_err_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S,
                                     pulse_err_s))
        {
            printf("INFO %d-й импульс кнопки Старт-Стоп не получен (кнопка не нажата или не отпущена вовремя)\n", i);
            return false;
        }

        // Проверка паузы между нажатиями
        if (i < start_btn_check_pulses_count)
        {
            if (p_gen6->waitStartStopBtn(TIME_DELAY::START_STOP_BTN_PAUSE_TIME_S - pause_err_s, polarity))
            {
                printf("INFO Пауза между нажатиями кнопки Старт-Стоп не выдержана (%d-е нажатие)\n", i);
                return false;
            }
        }
    } // for

    // Проверка на лишние нажатия кнопки
    if (p_gen6->waitStartStopBtn(no_pulses_check_time_s, polarity))
    {
        printf("INFO Получен лишний сигнал кнопки Старт-Стоп\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setBlockTriggerAndCheckStartStopBtnBlock(start_stop_block_trigger_t     start_stop_block_trigger,
                                                                start_btn_check_pulses_count_t start_btn_check_pulses_count,
                                                                float                          no_pulses_check_time_s)
{
    bool result;


    printf("INFO Вызов срабатывания блокировки и проверка блокировки кнопкой Старт-Стоп, ожидаемое количество нажатий: %d\n", start_btn_check_pulses_count);

    switch (start_stop_block_trigger)
    {
        case START_STOP_BLOCK_TRIGGER_IGN_ON:
            printf("INFO Включение зажигания для проверки блокировки\n");
            p_gen6->setIgn(PIN,
                           ON,
                           TIME_DELAY::NULL_DELAY_S);
            break;

        case START_STOP_BLOCK_TRIGGER_DOOR_OPEN:
            printf("INFO Открытие двери для проверки блокировки\n");
            p_gen6->setDoor(OPEN,
                            PIN,
                            TIME_DELAY::NULL_DELAY_S);
            break;

        case START_STOP_BLOCK_TRIGGER_PARKING_OFF:
            printf("INFO Выключение паркинга для проверки блокировки\n");
            p_gen6->setParking(OFF,
                               PIN,
                               TIME_DELAY::NULL_DELAY_S);
            break;

        case START_STOP_BLOCK_TRIGGER_SENSOR_MOVE:
            printf("INFO Вызов срабатывания ДД для проверки блокировки\n");
            p_gen6->setSensorNoDelay(DIAG_SENSOR_BIT_MOVE);
            break;

        case START_STOP_BLOCK_TRIGGER_SENSOR_SHOCK_LOW:
            printf("INFO Вызов срабатывания ДУ: тревожный для проверки блокировки\n");
            p_gen6->setSensorNoDelay(DIAG_SENSOR_BIT_SHOCK_LOW);
            break;

        default:
            printf("INFO Неизвестный триггер для вызова срабатывания блокировки: %d\n", start_stop_block_trigger);
            return false;
    }

    result = checkStartStopBtnBlock(start_btn_check_pulses_count, no_pulses_check_time_s);

    return result;
}

bool AutoTestsModesP2::checkModulesForWaitingAuthTagRem()
{
    const int32_t modules = p_gen6->getModules();                   // Модули в основном блоке
    const bool    is_r868 = (modules & R868_MODULE) == R868_MODULE; // Проверить наличие 868 модуля
    const bool    is_ble  = (modules & BLE_MODULE)  == BLE_MODULE;  // Проверить наличие BLE модуля
    const bool    is_gsm  = (modules & GSM_MODULE)  == GSM_MODULE;  // Проверить наличие GSM модуля


    // Авторизация по метке, снятие брелком
    if (   is_r868
        && is_ble)
    {
        return true;
    }

    // Авторизация по брелку, снятие по СМС
    if (   is_r868
        && is_gsm)
    {
        return true;
    }

    // Авторизация по метке, снятие по СМС
    if (   is_ble
        && is_gsm)
    {
        return true;
    }

    return false;
}

bool AutoTestsModesP2::setAndCheckWaitingAuthTagRem()
{
    const int32_t  modules = p_gen6->getModules();                   // Модули в основном блоке
    const bool     is_r868 = (modules & R868_MODULE) == R868_MODULE; // Проверить наличие 868 модуля
    const bool     is_ble  = (modules & BLE_MODULE)  == BLE_MODULE;  // Проверить наличие BLE модуля
    const bool     is_gsm  = (modules & GSM_MODULE)  == GSM_MODULE;  // Проверить наличие GSM модуля

    command_type_t execution_method;                                 // Способ снятия с охраны для перехода в ожидание авторизации
    float          wait_time_s;                                      // Время ожидания статуса системы


    printf("INFO Переход в ожидание авторизации\n");

    if (!checkModulesForWaitingAuthTagRem())
    {
        printf("INFO Отсутствуют модули для перехода в ожидание авторизации\n");
        return false;
    }

    if (is_r868)
    {
        if (is_ble)
        {
            execution_method = KEYRING;
            wait_time_s      = TIME_DELAY::WAITING_REGION_STATE_S;
        }
        else if (is_gsm)
        {
            execution_method = SMS;
            wait_time_s      = TIME_DELAY::MAX_WAITING_SMS_STATUS_TIME_S;
        }
    }
    else if (is_ble)
    {
        if (is_gsm)
        {
            execution_method = SMS;
            wait_time_s      = TIME_DELAY::MAX_WAITING_SMS_STATUS_TIME_S;
        }
    }

    p_gen6->setSecureNoDelay(OFF, execution_method);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_WAITING_AUTH,
                                ON,
                                wait_time_s))
    {
        printf("INFO Переход в ожидание авторизации не произведен\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::setAuthDeviceVcc(out_statuses_t out_status)
{
    const int32_t  modules = p_gen6->getModules();                   // Модули в основном блоке
    const bool     is_r868 = (modules & R868_MODULE) == R868_MODULE; // Проверить наличие 868 модуля
    const bool     is_ble  = (modules & BLE_MODULE)  == BLE_MODULE;  // Проверить наличие BLE модуля
    const bool     is_gsm  = (modules & GSM_MODULE)  == GSM_MODULE;  // Проверить наличие GSM модуля


    printf("INFO Управление питанием устройства авторизации\n");

    if (!checkModulesForWaitingAuthTagRem())
    {
        printf("FAIL Отсутствуют модули для перехода в ожидание авторизации\n");
        return;
    }

    // Авторизация по метке, снятие брелком => управляем меткой
    // Авторизация по метке, снятие по СМС  => управляем меткой
    if (is_ble)
    {
        if (   is_r868
            || is_gsm)
        {
            printf("INFO Управление питанием метки\n");

            if (out_status == ON)
            {
                p_gen6->setTagVcc();
                p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
            }
            else
            {
                p_gen6->resetTagVcc();
                p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
            }
        }
    }
    // Авторизация по брелку, снятие по СМС => управялем брелком
    else if (   is_r868
             && is_gsm)
    {
        printf("INFO Управление питанием брелка\n");

        if (out_status == ON)
        {
            p_gen6->setLcdKeyringVcc(ON);
            p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
        }
        else
        {
            p_gen6->setLcdKeyringVcc(OFF);
            p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
        }
    }
}

bool AutoTestsModesP2::setAndCheckAhjSmsOrMobile()
{
    printf("INFO Включение АО по команде\n");

    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        printf("INFO Включение АО по СМС\n");
        p_gen6->onAntiHijacking(SMS);
    }
    else if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        printf("INFO Включение АО через моб. приложение (BLE)\n");
        p_gen6->onAntiHijacking(MOBILE);
    }
    else
    {
        printf("INFO Отсутствуют модули для включения АО по команде\n");
        return false;
    }

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_CMD, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("INFO Антиограбление по команде не включено\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::setCanCarSpeed(int8_t speed)
{
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::MAX_WIRE_EN_DELAY_S);
    p_gen6->setSpeed(speed);
    p_gen6->setIgn(PIN,
                   OFF,
                   TIME_DELAY::MAX_WIRE_EN_DELAY_S);
}

bool AutoTestsModesP2::setTagAndSlaveDisarmAndCheckDisarm(tag_statuses_t           tag_status,
                                                          slave_type_t             slave_type,
                                                          slp_diag_data_statuses_t diag_data_status)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует модуль для работы с меткой\n");
        return false;
    }

    if (tag_status == TAG_ON)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }
    else
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Снять с охраны через Slave аналог/CAN (slave_type)
    */
    /*!
        Переход из охраны в снято не произошел (diag_data_status)
        ИЛИ
        Произошел переход из охраны в снято (diag_data_status)
    */
    switch (slave_type)
    {
        case SLAVE_TYPE_ANALOG:
            p_gen6->sendAnalogSlaveStatus(OFF,
                                          TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                          TIME_DELAY::STD_LOCK_SLAVE_PAUSE_S,
                                          TIME_DELAY::STD_LIGHTS_SLAVE_PULSE_S,
                                          TIME_DELAY::STD_LIGHTS_SLAVE_PULSE_S,
                                          SLAVE_LIGHT_LR);
            break;

        case SLAVE_TYPE_CAN:
            p_gen6->setSecure(OFF, CAN_USE);
            break;

        default:
            printf("INFO Неизвестный тип Slave: %d\n", slave_type);
            return false;
    }

    switch (diag_data_status)
    {
        case DIAG_GUARD_STATE_ARM:

            if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                       OFF,
                                       TIME_DELAY::WAITING_REGION_STATE_S))
            {
                printf("INFO Произошел переход из охраны в снято\n");
                return false;
            }

            break;

        case DIAG_GUARD_STATE_DISARM:

            if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                        ON,
                                        TIME_DELAY::WAITING_REGION_STATE_S))
            {
                printf("INFO Не произошел переход из охраны в снято\n");
                return false;
            }

            break;

        default:
            printf("INFO Неизвестный тип проверки охраны: %d\n", diag_data_status);
            return false;

    }

    return true;
}

bool AutoTestsModesP2::setSrvBtnMenu(uint8_t                  clicks_count,
                                     srv_btn_menu_on_type_t   srv_btn_menu_on_type,
                                     slp_diag_data_statuses_t diag_data_status)
{
    const float led_on_err_time_s = TimeoutCalculator::calcToutError(TIME_DELAY::BTN_LED_AFTER_PUSH_NUM_DELAY_S); // Погрешность времени включения сервисного светодиода


    /*!
        Нажать clicks_count раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    // Если мы входим в режим регистрации - нужно встать в очередь
    if (clicks_count == COUNT_STRUCT::BTN_MODE_REG_CLICKS_COUNT)
    {
        p_gen6->addDeviceToRegistrationQueue();
    }

    for (uint8_t i = 0; i < clicks_count; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
    }

    if (srv_btn_menu_on_type == SRV_BTN_MENU_ON_TYPE_BTN)
    {
        // Не проверяем светодиод на трансивере
        if (p_gen6->getDeviceName() != GEN6_X96V2)
        {
            if (    p_gen6->waitServiceLed(ON, TIME_DELAY::BTN_LED_AFTER_PUSH_NUM_DELAY_S - led_on_err_time_s - TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S) // Вычитается время задержки после последнего нажатия сервисной кнопки
                || !p_gen6->waitServiceLed(ON, led_on_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
            {
                printf("INFO Светодиод сервисной кнопки не включился или включился вне времени ожидания (после нажатий кнопки)\n");
                return false;
            }
        }
        else
        {
            // Ожидаем, пока не загорится светодиод
            p_gen6->wait_s(TIME_DELAY::BTN_LED_AFTER_PUSH_NUM_DELAY_S);
        }

        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S); // Не моментально нажимаем сервисную кнопку после получения сигнала
        p_gen6->clickServiceBtn();
    }

    /*!
        Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
        ИЛИ
        Включить зажигание
    */
    /*!
        Светодиод сервисной кнопки отключился (если нажимали сервисную кнопку, а не вкл. зажигание)
        clicks_count-кратное подтверждение сервисным светодиодом входа в режим slp_diag_data_status
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
    */
    if (srv_btn_menu_on_type == SRV_BTN_MENU_ON_TYPE_BTN)
    {
        // Не проверяем светодиод на трансивере
        if (p_gen6->getDeviceName() != GEN6_X96V2)
        {
            if (!p_gen6->waitServiceLed(OFF, TIME_DELAY::MAX_WIRE_EN_DELAY_S))
            {
                printf("INFO Светодиод сервисной кнопки не отключился (после нажатия сервисной кнопки для входа в режим)\n");
                return false;
            }
        } // if p_gen6->getDeviceName() == GEN6_X96V2
    }
    else
    {
        // Без проверки по SLP, т.к. сразу нужно проверять сервисный светодиод
        p_gen6->setIgn(PIN,
                       ON,
                       TIME_DELAY::NULL_DELAY_S);
    }

    // Не проверяем светодиод на трансивере
    if (p_gen6->getDeviceName() != GEN6_X96V2)
    {
        if (!p_gen6->waitServicePulseAmount(clicks_count, TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("INFO Отсутствует %d-кратное подтверждение сервисным светодиодом\n", clicks_count);
            return false;
        }

        if (!p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                            TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S))
        {
            printf("INFO Отсутствует 2-кратное подтверждение выполнение команды\n");
            return false;
        }

        if (p_gen6->waitServiceLed(ON, TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S))
        {
            printf("INFO Получен лишний сигнал сервисного светодиода\n");
            return false;
        }
    }
    else
    {
        printf("INFO Ожидание, пока не пройдут сигналы сервисного светодиода\n");
        p_gen6->wait_s(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);
    }

    // Охрана включается с задержкой 20 секунд (внутренний тайминг)
    if (diag_data_status == DIAG_GUARD_STATE_ARM)
    {
        if (srv_btn_menu_on_type == SRV_BTN_MENU_ON_TYPE_IGN) // Нужно отключить зажигание, иначе охрана не включится
        {
            wait(TIME_DELAY::MAX_WIRE_EN_DELAY_S); // Чтобы не моментально выключать зажигание после получения сигналов сервисного светодиода

            if (!p_gen6->setAndCheckIgn(OFF, PIN))
            {
                printf("INFO Зажигание не выключено\n");
                return false;
            }
        }

        p_gen6->wait_s(TIME_DELAY::BTN_MODE_ARM_DELAY_S);
    }

    if (!p_gen6->waitGuardState(diag_data_status,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Статус системы не соответствует ожидаемому\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setImmoByIgn()
{
    p_gen6->setSecure(ON, KEYRING); // Нужно, т.к. после снятия кодом экстр. снятия - все защитные функции отключены на 1 цикл охраны

    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("INFO Охрана не отключена\n");
        return false;
    }

    p_gen6->setIgn(PIN, ON);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                  SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                  DIAG_PERIM_BIT_IGN,
                                  ON,
                                  TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("INFO Зажигание не включено\n");
        return false;
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_RUN_ENGINE_TIME_S);

    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Зажигание не отключено\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Запрет поездки не включился\n");
        return false;
    }

    return true;
}

void AutoTestsModesP2::resetAndSetKeyringAndRelayVcc()
{
    const bool is_ble     = (p_gen6->getModules() & BLE_MODULE) == BLE_MODULE; // Наличие BLE модуля

    float      off_time_s = TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S;           // Время потери устройств
    float      on_time_s  = TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S;             // Время нахождения устройств


    printf("INFO Перезагрузка брелков и BLE-реле (для выхода из режима программирования)\n");

    // Отключаем устройства
    p_gen6->setLcdKeyringVcc(OFF);

    if (is_ble)
    {
        p_gen6->resetR6Vcc();
        p_gen6->getR6Eco()->setVcc(OFF);

        off_time_s = max(off_time_s,
                         (float)TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S);
    }

    p_gen6->wait_s(off_time_s);

    // Включаем устройства
    p_gen6->setLcdKeyringVcc(ON);

    if (is_ble)
    {
        p_gen6->setR6Vcc();
        p_gen6->getR6Eco()->setVcc(ON);

        on_time_s = max(on_time_s,
                        (float)TIME_DELAY::R6_CONN_WAIT_TIME_S);
    }

    p_gen6->wait_s(off_time_s);
}

void AutoTestsModesP2::setAndResetIgn()
{
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::MAX_WIRE_EN_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
}

bool AutoTestsModesP2::sendBtnAndCheckSignals(uint8_t        click_count,
                                              uint8_t        signal_count,
                                              siren_status_t siren_status)
{
    const bool                        is_srv_btn_check = p_gen6->getDeviceName() != GEN6_X96V2; // Не проверяем светодиод сервисной кнопки на транисвере
    const std::vector<can_sts_btn_t> &buttons          = p_gen6->getValidatorCode();            // Нажимаемые кнопки


    /*!
        Ввести с помощью штатных кнопок (imitcan) желаемый код валидатора (количество нажатий кнопок от 2 до 15) (промежутки между нажатиями кнопок не более 3 сек. (внутренний таймаут))
    */
    /*!
        Каждое нажатие кнопок подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки

        Через 3 сек (внутренний таймаут):
        подтверждение ввода 2мя импульсами на светодиоде сервисной кнопки
        ИЛИ
        подтверждение ввода 2мя импульсами на светодиоде сервисной кнопки и на сирене (импульсы сирены и светодиода одновременны) (siren_status)
    */
    click_count = min(buttons.size(), (size_t)click_count);

    p_can1_act->sendBtnOff();

    for (uint8_t i = 0; i < click_count; ++i)
    {
        if (is_srv_btn_check)
        {
            p_gen6->setPolaritySrvBtn();
        }

        p_can1_act->sendBtn(buttons[i]);
        printf("INFO Штатная кнопка нажата (%d из %d)\n",
               i + 1,
               click_count);

        if (is_srv_btn_check)
        {
            if (!p_gen6->checkPulseWidthSrvBtn(TIME_DELAY::BTN_LED_AFTER_VALIDATOR_DURATION_S,
                                               TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S,
                                               TimeoutCalculator::calcToutError(TIME_DELAY::BTN_LED_AFTER_VALIDATOR_DURATION_S)))
            {
                printf("INFO Сервисный светодиод не загорелся или длительность сигнала не соответствует ожидаемой\n");
                return false;
            }
        }

        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    switch (siren_status)
    {
        // Проверить сирену
        case SIREN_ON:

            if (is_srv_btn_check)
            {
                if (!p_gen6->checkSrvLedAndSiren(signal_count, TIME_DELAY::MAX_WAIT_CL_SIGNALS_S))
                {
                    printf("INFO Ошибка при проверке сигналов сервисного светодиода и сирены\n");
                    return false;
                }
            }
            else
            {
                for (uint8_t i = 0; i < signal_count; ++i)
                {
                    p_gen6->setPolarity(ID_OUT_SIREN);

                    if (!p_gen6->checkPulseWithoutWidth(ID_OUT_SIREN, TIME_DELAY::MAX_WAIT_CL_SIGNALS_S))
                    {
                        printf("INFO %d-й сигнал сирены не получен\n", i);
                        return false;
                    }
                }
            } // if is_srv_btn_check

            break;

        // Не проверять сирену
        case SIREN_OFF:
        case SIREN_NOT_ON:

            if (is_srv_btn_check)
            {
                if (!p_gen6->waitServicePulseAmount(signal_count, TIME_DELAY::MAX_WAIT_CL_SIGNALS_S))
                {
                    printf("INFO Ошибка при проверке сигналов сервисного светодиода\n");
                    return false;
                }
            }

            break;

        default:
            printf("INFO Неизвестный тип проверки сирены: %d\n", siren_status);
            return false;
    }

    if (is_srv_btn_check)
    {
        if (p_gen6->waitServiceLed(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S)) // Долго не проверяем, т.к. до повторного ввода кода есть всего 3 секунды (внутренний тайминг)
        {
            printf("INFO Получен лишний сигнал сервисного светодиода\n");
            return false;
        }
    }

    return true;
}

bool AutoTestsModesP2::setIgnAndCheckVideoRegOn(ign_statuses_t ign_status, Timer *timer)
{
    const bool video_reg_polarity    = p_gen6->getPolarity(ID_OUT_VIDEO_REG); // Полярность выхода видеорегистратора

    const      out_statuses_t status = ign_status == IGN_ON ? ON              // Желаемый статус зажигания
                                                            : OFF;


    /*!
        Включить/выключить зажигание (ign_status)
    */
    /*!
        Зажигание включено/выключено (ign_status)
        Выход видеорегистратора включен
    */
    if (timer != NULL)
    {
        timer->start();
    }

    if (!p_gen6->setAndCheckIgn(status, PIN))
    {
        printf("INFO Статус зажигания не соответствует ожидаемому\n");
        return false;
    }

    if (   !p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S,  video_reg_polarity)  // Ожидание включения выхода
        ||  p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, !video_reg_polarity)) // Проверка, что выход не отключился
    {
        printf("INFO Выход видеорегистратора не включен\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setServiceAndCheckVideoRegOn(service_statuses_t service_status)
{
    const bool video_reg_polarity    = p_gen6->getPolarity(ID_OUT_VIDEO_REG); // Полярность выхода видеорегистратора

    const      out_statuses_t status = service_status == SERVICE_ON ? ON      // Желаемый статус сервисного режима
                                                                    : OFF;


    /*!
        Включить/выключить сервисный режим (service_status)
    */
    /*!
        Сервисный режим включен/выключен (service_status)
        Выход видеорегистратора включен
    */
    p_gen6->setServiceMode(status);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                status,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Неудачное управление сервисным режимом\n");
        return false;
    }

    if (   !p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S,  video_reg_polarity)  // Ожидание включения выхода
        ||  p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, !video_reg_polarity)) // Проверка, что выход не отключился
    {
        printf("INFO Выход видеорегистратора не включен\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::waitVideoRegOff(float delay_s, float err_time_s)
{
    const bool video_reg_polarity = p_gen6->getPolarity(ID_OUT_VIDEO_REG); // Полярность выхода видеорегистратора


    printf("INFO Ожидание отключение выхода видеорегистратора через: %.2f сек., погрешность: %.6f сек.\n",
           delay_s,
           err_time_s);

    if (p_gen6->waitVideoReg(delay_s - err_time_s, !video_reg_polarity))
    {
        printf("INFO Выход видеорегистратора отключился раньше времени\n");
        return false;
    }

    if (!p_gen6->waitVideoReg(err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S, !video_reg_polarity))
    {
        printf("INFO Выход видеорегистратора не отключился\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::resetIgnAndCheckVideoRegOff()
{
    const float video_reg_err_time_s = TimeoutCalculator::calcToutError(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S); // Погрешность времени выкл. выхода видеорегистратора

    Timer       ign_off_timer;                                                                                  // Таймер, включается в момент выключения зажигания

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Выход видеорегистратора включен
    */
    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Зажигание не выключено\n");
        return false;
    }

    ign_off_timer.start();

    if (p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, !p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("INFO Выход видеорегистратора отключился\n");
        return false;
    }

    /*!
        Ожидать 5 мин. после отключения зажигания (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    ign_off_timer.stop();

    if (!waitVideoRegOff(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S - ign_off_timer.read(), video_reg_err_time_s))
    {
        printf("INFO Неудачная проверка задержки выключения выхода видеорегистратора\n");
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAlertAndServiceAndCheckVideoReg(service_statuses_t service_status)
{
    Timer  alert_timer; // Таймер, включается в момент включения тревоги
    int8_t step = 0;    // Номер текущего шага (для логирования)


    /*!
        Шаг 1. Не ранее чем через 15 сек после включения охраны
        Вызвать тревогу (имитация датчика движения)
    */
    /*!
        Тревога включена
        Выход видеорегистратора включен
    */
    p_gen6->wait_s(TIME_DELAY::UNMASK_ZONE_TIME_S);
    p_gen6->setMoveSensor();

    p_gen6->waitSiren(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, p_gen6->getPolarity(ID_OUT_SIREN)); // Для точного определения момента включения тревоги
    alert_timer.start();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Шаг 1. Тревога не включилась\n");
        return false;
    }

    if (!p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("INFO Шаг 1. Выход видеорегистратора не включен\n");
        return false;
    }

    /*!
        Шаг 2. Отменить тревогу любым способом
    */
    /*!
        Тревога выключена
        Выход видеорегистратора включен
    */
    p_gen6->setSecureNoDelay(OFF, KEYRING);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Шаг 2. Тревога не выключилась\n");
        return false;
    }

    if (p_gen6->waitVideoReg(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, !p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("INFO Шаг 2. Выход видеорегистратора не включен\n");
        return false;
    }

    /*!
        Шаг 3. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */
    step = 3;

    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("INFO Шаг %d. Охрана не отключена перед переходом в сервис\n", step);
        return false;
    }

    if (!setServiceAndCheckVideoRegOn(SERVICE_ON))
    {
        printf("INFO Шаг %d. Сервисный режим не включен\n", step);
        return false;
    }

    /*!
        Шаг 4. Выключить сервисный режим
    */
    /*!
        Сервисный режим выключен
        Выход видеорегистратора включен
    */
    if (service_status == SERVICE_OFF)
    {
        ++step;

        if (!setServiceAndCheckVideoRegOn(SERVICE_OFF))
        {
            printf("INFO Шаг %d. Сервисный режим не выключен\n", step);
            return false;
        }
    }

    /*!
        Шаг 5. Ожидать 2 мин. после включения тревоги (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    alert_timer.stop();

    if (!waitVideoRegOff(TIME_DELAY::VIDEO_REG_AFTER_ALARM_WORK_TIME_S - alert_timer.read(),
                         TimeoutCalculator::calcToutError(TIME_DELAY::VIDEO_REG_AFTER_ALARM_WORK_TIME_S)))
    {
        printf("INFO Шаг %d. Выход видеорегистратора не выключен\n", step);
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setAndCheckServiceAndVideoReg(service_statuses_t service_status)
{
    Timer  video_reg_timer; // Таймер, включается в момент включения видеорегистратора

    int8_t step = 0;        // Номер текущего шага (для логирования)


    /*!
        Шаг 1. Отправить СМС "69"
    */
    /*!
        Выход видеорегистратора включен
        Получено СМС "команда "включить видеорегистратор" выполнена"
    */
    ++step;

    p_gsm->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1], SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_VIDEO_REG_ON);

    if (!p_gen6->waitVideoReg(TIME_DELAY::MAX_WAITING_SMS_STATUS_TIME_S, p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("INFO Шаг %d. Выход видеорегистратора не включился\n", step);
        return false;
    }

    video_reg_timer.start();

    if (p_gsm->waitCyrillicSms(Sim900::combineStr("%s %s %s",
                                                  SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                  SMS_MSG_STR::SMS_PARSE_CMD_VIDEO_REG_ON,
                                                  SMS_MSG_STR::SMS_ANSW_STR_CMD_COMPLETE).c_str()) != SIM900ACT_TRUESMS)
    {
        printf("INFO Шаг %d. Ошибка чтения СМС сообщения\n", step);
        return false;
    }

    /*!
        Шаг 2. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */
    if (service_status != SERVICE_NO_CONTROL)
    {
        ++step;

        if (!setServiceAndCheckVideoRegOn(service_status))
        {
            printf("INFO Шаг %d. Неудачная проверка включения видеорегистратора\n", step);
            return false;
        }
    }

    /*!
        Шаг 3. Ожидать 5 мин. после включения выхода видеорегистратора (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    ++step;

    video_reg_timer.stop();

    if (!waitVideoRegOff(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S - video_reg_timer.read(),
                         TimeoutCalculator::calcToutError(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S)))
    {
        printf("INFO Шаг %d. Выход видеорегистратора не выключен\n", step);
        return false;
    }

    return true;
}

bool AutoTestsModesP2::setDisarmAndResetBleRelayVcc()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует модуль для работы с R6/R6 ECO\n");
        return false;
    }

    p_gen6->resetR6Vcc();
    p_gen6->getR6Eco()->setVcc(OFF);
    p_gen6->wait_s(TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S);

    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("INFO Охрана не отключилась\n");
        return false;
    }

    p_gen6->wait_s(TIME_DELAY::DELAY_AFTER_ARM_S);

    return true;
}

bool AutoTestsModesP2::registerBleRelayFewTimesAndCheckBlock(relay_registration_sequence_t relay_registration_sequence,
                                                             uint8_t                       registration_count)
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf("INFO Отсутствует модуль для работы с R6/R6 ECO\n");
        return false;
    }

    /*!
        Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */
    if (!p_gen6->registrationMode(ON))
    {
        printf("INFO Ошибка при переходе в режим регистрации устройств\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_REG,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Переход в режим регистрации устройств не произошел\n");
        return false;
    }

    /*!
        Зарегистрировать R6 registration_count раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */
    /*!
        Зарегистрировать R6eco registration_count раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */
    for (int8_t i = 0; i < registration_count; ++i)
    {
        switch (relay_registration_sequence)
        {
            case RELAY_REGISTRATION_SEQUENCE_R6_ONLY:

                if (!p_gen6->registerR6())
                {
                    printf("INFO Ошибка при проверке регистрации R6 на %d-й регистрации\n", i + 1);
                    return false;
                }

                break;

            case RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY:

                if (!p_gen6->registerR6Eco())
                {
                    printf("INFO Ошибка при проверке регистрации R6 ECO на %d-й регистрации\n", i + 1);
                    return false;
                }

                break;

            case RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO:

                if (!p_gen6->registerR6())
                {
                    printf("INFO Ошибка при проверке регистрации R6 на %d-й регистрации\n", i + 1);
                    return false;
                }

                if (!p_gen6->registerR6Eco())
                {
                    printf("INFO Ошибка при проверке регистрации R6 ECO на %d-й регистрации\n", i + 1);
                    return false;
                }

                break;

            case RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6:

                if (!p_gen6->registerR6Eco())
                {
                    printf("INFO Ошибка при проверке регистрации R6 ECO на %d-й регистрации\n", i + 1);
                    return false;
                }

                if (!p_gen6->registerR6())
                {
                    printf("INFO Ошибка при проверке регистрации R6 на %d-й регистрации\n", i + 1);
                    return false;
                }

                break;

            default:
                printf("INFO Неизвестная последовательность регистрации кодовых реле: %d\n", relay_registration_sequence);
                return false;
        } // switch (relay_registration_sequence)
    } // for

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_EN_DELAY_S); // Не сразу выкл. зажигание после регистрации устройства

    if (!p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("INFO Зажигание не отключено\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                ON,
                                TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("INFO Переход в снято не произошел\n");
        return false;
    }

    /*!
        Включить охрану
    */
    /*!
        Переход в охрану
    */
    p_gen6->wait_s(TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S); // Не сразу ставим в охрану после выхода из регистрации

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("INFO Переход в охрану не произошел\n");
        return false;
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку (если регистрировалось: relay_registration_sequence)
        R6eco включило блокировку (если регистрировалось: relay_registration_sequence)
    */
    if (!p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("INFO Зажигание не включено\n");
        return false;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("INFO Тревога не включилась\n");
        return false;
    }

    // Проверка блокировки на R6
    if (   relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6_ONLY
        || relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO
        || relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6)
    {
        if (!waitR6Block(ON))
        {
            printf("INFO Блокировка R6 не включилась\n");
            return false;
        }
    }

    // Проверка блокировки на R6 ECO
    if (   relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY
        || relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO
        || relay_registration_sequence == RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6)
    {
        if (!waitR6EcoBlock(ON))
        {
            printf("INFO Блокировка R6 ECO не включилась\n");
            return false;
        }
    }

    return true;
}

// 1. Нажатие сенсора с зажиганием не включает Пляж 
void AutoTestsModesP2::C168671_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true; // полярность сирены/буззера

    if (settings_check(p_c168671) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Режим пляж не активен
        Снято с охраны
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 3. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Охрана включена\n");
        return;
    }
}

// 2. Постановка в Охрану с отключенным Пляжем 
void AutoTestsModesP2::C168672_TestCase()
{
    if (settings_check(p_c168672) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    polarity             = true;

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse,
                                       polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    else
    {
        polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse,
                                   polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }

        if (p_gen6->waitSirenPulse(short_number_impulse,
                                   polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        Ожидать 20 секунд
    */
    /*!
        Охрана включена
    */
    wait(TIME_DELAY::TWENTY_S + TIME_DELAY::THREE_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
}

// 3. Включение зажигания до 3 нажатий сенсора 
void AutoTestsModesP2::C168673_TestCase()
{
    if (settings_check(p_c168671) == 0)
    {
        return;
    }

    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    siren_polarity       = true; // полярность сирены/буззера
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        Включить зажигание
    */
    /*!
        Снято с охраны
    */
    p_gen6->setIgn(PIN, ON);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
}

// 4. Нажатия сенсора в Снято до ожидания ввода 
void AutoTestsModesP2::C168674_TestCase()
{
    bool cap_polarity = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Снято с охраны
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
}

// 5. 1ый импульс сенсора постановки менее 0,2 сек. 
void AutoTestsModesP2::C168675_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true; // полярность сирены/буззера

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(1ый импульс сенсора постановки менее 0,2 сек.)
    */
    /*!
        В охране
    */
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_LESS_MIN_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);

    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 6. 2ой импульс сенсора постановки менее 0,2 сек. 
void AutoTestsModesP2::C168676_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(2ый импульс сенсора постановки менее 0,2 сек.)
    */
    /*!
        В охране
    */
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_LESS_MIN_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 7. 3ий импульс сенсора постановки менее 0,2 сек. 
void AutoTestsModesP2::C168677_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(3ый импульс сенсора постановки менее 0,2 сек.)
    */
    /*!
        В охране
    */
    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_LESS_MIN_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 8. 3 импульса сенсора постановки менее 0,2 сек. 
void AutoTestsModesP2::C168678_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(3 импульса сенсора постановки менее 0,2 сек.)
    */
    /*!
        В охране
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_LESS_MIN_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
}

// 9. 1ый импульс сенсора постановки более 1 сек. 
void AutoTestsModesP2::C168679_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(1ый импульс сенсора постановки более 1 сек.)
    */
    /*!
        Снято с охраны
    */
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_GREATER_MAX_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);

    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
}

// 10. 2ой импульс сенсора постановки более 1 сек. 
void AutoTestsModesP2::C168680_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(2ой импульс сенсора постановки более 1 сек.)
    */
    /*!
        Снято с охраны
    */
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_GREATER_MAX_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
}

// 11. 3ий импульс сенсора постановки более 1 сек. 
void AutoTestsModesP2::C168681_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(3й импульс сенсора постановки более 1 сек.)
    */
    /*!
        Снято с охраны
    */
    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_GREATER_MAX_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
}

// 12. 3 импульса сенсора постановки более 1 сек. 
void AutoTestsModesP2::C168682_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор(3 импульса сенсора постановки более 1 сек.)
    */
    /*!
        Снято с охраны
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::CAP_SENSOR_GREATER_MAX_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
}

// 13. Включение режима пляж без видимой метки 
void AutoTestsModesP2::C168683_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 14. Включение Пляж с видимой меткой 
void AutoTestsModesP2::C168684_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
        Метка в зоне видимости
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    p_gen6->resetTagVcc();
}

// 15. Попытка выключить охрану в Пляж штатным(CAN) Slave 
void AutoTestsModesP2::C168685_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168685) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану CAN slave
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(OFF, STD);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 16. Попытка выключить охрану в Пляж аналог. Slave 
void AutoTestsModesP2::C168686_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if (settings_check(p_c168686) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }

    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану аналоговым slave
    */
    /*!
        Охрана включена
    */
    p_gen6->sendAnalogSlaveStatus(OFF,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 17. Попытка выключить охрану звонком с чужого номера 
void AutoTestsModesP2::C168687_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168687) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану звонком с чужого номера
    */
    /*!
        Охрана включена
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_DISARM,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 5. Ошибка при отправке DTMF команды\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 18. Попытка выключить охрану звонком с номера владельца 
void AutoTestsModesP2::C168688_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168688) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану звонком с номера владельца
    */
    /*!
        Охрана включена
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_DISARM,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 5. Ошибка при отправке DTMF команды\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 19. Попытка выключить охрану СМС с чужого номера 
void AutoTestsModesP2::C168689_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168687) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану смс с чужого номера
    */
    /*!
        Охрана включена
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_PROT_OFF);
    
    wait(TIME_DELAY::MIN_WAITING_SMS_STATUS_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 20. Попытка выключить охрану СМС с номера владельца 
void AutoTestsModesP2::C168690_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168688) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану смс с номера владельца
    */
    /*!
        Охрана включена
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_PROT_OFF);
    
    wait(TIME_DELAY::MIN_WAITING_SMS_STATUS_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 21. Попытка выключить охрану брелоком 
void AutoTestsModesP2::C168691_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану смс с номера владельца
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 22. Попытка выключить охрану меткой 
void AutoTestsModesP2::C168692_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану меткой
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(OFF, TAG);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 23. Попытка выключить охрану через личный кабинет 
void AutoTestsModesP2::C168693_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану через личный кабинет
    */
    /*!
        Охрана включена
    */
    if (p_gen6->setStarlineOnlineParam(StarlineOnline::ARM, OFF))
    {
        printf("FAIL Шаг 5. Ошибка при запросе на выключение охраны в режиме пляж\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 24. Попытка выключить охрану мобильным приложением  
void AutoTestsModesP2::C168694_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 25. Попытка выключить охрану Свободными руками 
void AutoTestsModesP2::C168695_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168695) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setTagVcc();
    p_gen6->setCapSensor(!cap_polarity);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану свободными руками
    */
    /*!
        Охрана включена
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 26. Попытка выключить охрану Своб. руками через сенсор 
void AutoTestsModesP2::C168696_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168696) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->resetTagVcc();
    p_gen6->setCapSensor(!cap_polarity);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Выключить охрану свободными руками по сенсору
    */
    /*!
        Охрана включена
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    p_gen6->setCapSensor(cap_polarity);
    wait(TIME_DELAY::ONE_S);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 27. Попытка выключить охрану штатными Свободными руками 
void AutoTestsModesP2::C168697_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 28. Появление и пропадание метки в Пляж 
void AutoTestsModesP2::C168698_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Включить метку
    */
    /*!
        Охрана включена
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }
    
    /*!
        Выключить метку
    */
    /*!
        Охрана включена
    */
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 6. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 6. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 29. Выключение Пляж гибкой логикой с видимой меткой 
void AutoTestsModesP2::C168699_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 30. Выключение Пляж гибкой логикой без метки 
void AutoTestsModesP2::C168700_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 31. Включение Пляж гибкой логикой с видимой меткой 
void AutoTestsModesP2::C168701_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 32. Включение Пляж гибкой логикой без метки 
void AutoTestsModesP2::C168702_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// 33. Попытка выключить Пляж сенсором с запозданием ввода цифры более 5 сек. 
void AutoTestsModesP2::C168703_TestCase()
{
    uint8_t long_number_impulse = 3;
    bool    cap_polarity        = true;

    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }

    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->waitSirenPulse(long_number_impulse, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::LONG_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
        return;
    }
    
    uint8_t short_number_impulse = 2;
    
    if (p_gen6->waitSirenPulse(short_number_impulse, 
                               siren_polarity, 
                               TIME_DELAY::FIVE_S, 
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Начать ввод кода экстренного снятия с временем между вводом цифр более 5 секунд
    */
    /*!
        Вспышка светодиодом
        Охрана включена
    */
    uint8_t press_count = 4;
    
    for (uint8_t i = 0; i < press_count; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    wait(TIME_DELAY::FIVE_S);
    
    uint8_t impulse_count = 1;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 5. Вспышка подтверждения светодиодом не получена\n");
    }
    else
    {
        printf("PASS Шаг 5. Вспышка подтверждения светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 34. Попытка выкл. Пляж сенсором с неправильным ПИН 
void AutoTestsModesP2::C168704_TestCase()
{
    uint8_t long_number_impulse = 3;
    bool    cap_polarity        = true;

    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }

    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->waitSirenPulse(long_number_impulse, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::LONG_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
        return;
    }
    
    uint8_t short_number_impulse = 2;
    
    if (p_gen6->waitSirenPulse(short_number_impulse, 
                               siren_polarity, 
                               TIME_DELAY::FIVE_S, 
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Ввести неверный ПИН
    */
    /*!
        4 вспышки светодиодом
        Охрана включена
    */
    const char *incorrect_pin = "7777";
    
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                               incorrect_pin);
    
    uint8_t impulse_count = 4;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 5. Вспышки подтверждения светодиодом не получены\n");
    }
    else
    {
        printf("PASS Шаг 5. Вспышки подтверждения светодиодом получены\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 35. Выключение Пляж с активной меткой с выключенными свободными руками по сенсору 
void AutoTestsModesP2::C168705_TestCase()
{
    uint8_t long_number_impulse = 3;
    bool    cap_polarity        = true;

    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168695) == 0)
    {
        return;
    }

    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
        Метка в зоне видимости
    */
    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    p_gen6->setCapSensor(!cap_polarity);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->waitSirenPulse(long_number_impulse, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::LONG_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
        return;
    }
    
    uint8_t short_number_impulse = 2;
    
    if (p_gen6->waitSirenPulse(short_number_impulse, 
                               siren_polarity, 
                               TIME_DELAY::FIVE_S, 
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    int8_t inactive_status_tag = p_gen6->getTagStatus1();
    
    /*!
        Ввод кода экстренного снятия
    */
    /*!
        Охрана выключена
        Включен статус метки
    */
    p_gen6->emergencyDisarming();
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана включена\n");
        return;
    }
    
    if (inactive_status_tag != p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 5. Статусный выход метки активен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Статусный выход метки не активен\n");
    }
}

// 36. Выключение Пляж с активной меткой с включенными свободными руками по сенсору 
void AutoTestsModesP2::C168706_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168696) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setTagVcc();
    p_gen6->setCapSensor(!cap_polarity);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
    
    int8_t inactive_status_tag = p_gen6->getTagStatus1();
    
    /*!
        Ввести код экстренного снятия
    */
    /*!
        Охрана выключена
    */
    p_gen6->emergencyDisarming();
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана включена\n");
        return;
    }
    
    if (inactive_status_tag != p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 5. Статусный выход метки активен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Статусный выход метки не активен\n");
        return;
    }
}

// 37. Выключение Пляж без метки с выключенными свободными руками по сенсору 
void AutoTestsModesP2::C168707_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168707) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
        
    int8_t inactive_status_tag = p_gen6->getTagStatus1();
    
    /*!
        Ввести код экстренного снятия
    */
    /*!
        Охрана выключена
        Включен статус метки
    */
    p_gen6->emergencyDisarming();
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана включена\n");
        return;
    }
    
    if (inactive_status_tag == p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 5. Статусный выход метки не активен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Статусный выход метки активен\n");
        return;
    }
}

// 38. Выключение Пляж без метки с включенными свободными руками по сенсору 
void AutoTestsModesP2::C168708_TestCase()
{
    uint8_t long_number_impulse  = 3;
    uint8_t short_number_impulse = 2;
    bool    cap_polarity         = true;
    bool    siren_polarity       = true;

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168696) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->resetTagVcc();
    p_gen6->setCapSensor(!cap_polarity);
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_BUZZER_EXT);

        if (p_gen6->waitBuzzerExtPulse(long_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы буззером отсутствуют\n");
            return;
        }

        if (p_gen6->waitBuzzerExtPulse(short_number_impulse, 
                                       siren_polarity, 
                                       TIME_DELAY::FIVE_S, 
                                       TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы буззером присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы буззером отсутствуют\n");
            return;
        }
    }
    else
    {
        siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

        if (p_gen6->waitSirenPulse(long_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::LONG_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
            return;
        }
    
        if (p_gen6->waitSirenPulse(short_number_impulse, 
                                   siren_polarity, 
                                   TIME_DELAY::FIVE_S, 
                                   TIME_DELAY::SHORT_SIREN_IMPULSE_S))
        {
            printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
        }
        else
        {
            printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
            return;
        }
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
    
    int8_t inactive_status_tag = p_gen6->getTagStatus1();
    
    /*!
        Ввести код экстренного снятия
    */
    /*!
        Охрана выключена
    */
    p_gen6->emergencyDisarming();
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана включена\n");
        return;
    }
    
    if (inactive_status_tag == p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 5. Статусный выход метки не активен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Статусный выход метки активен\n");
        return;
    }
}

// 39. Попытка выключить Пляж сервисной кнопкой с запозданием ввода цифры более 5 сек. 
void AutoTestsModesP2::C168709_TestCase()
{
    uint8_t long_number_impulse = 3;
    bool    cap_polarity        = true;

    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }

    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->waitSirenPulse(long_number_impulse, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::LONG_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
        return;
    }
    
    uint8_t short_number_impulse = 2;
    
    if (p_gen6->waitSirenPulse(short_number_impulse, 
                               siren_polarity, 
                               TIME_DELAY::FIVE_S, 
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
    }
    
    /*!
        Начать ввод кода экстренного снятия с временем между вводом цифр более 5 секунд
    */
    /*!
        Вспышка светодиодом
        Охрана включена
    */
    uint8_t press_count = 4;
    
    for (uint8_t i = 0; i < press_count; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    for (uint8_t i = press_count; i < 9; ++i)
    {
        wait(TIME_DELAY::MIN_WIRE_EN_DELAY_S);
    }

    wait(TIME_DELAY::SEVEN_S);
    
    uint8_t impulse_count = 1;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 5. Вспышка подтверждения светодиодом не получена\n");
    }
    else
    {
        printf("PASS Шаг 5. Вспышка подтверждения светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 40. Попытка выкл. Пляж сервисной кнопкой с неправильным ПИН 
void AutoTestsModesP2::C168710_TestCase()
{
    uint8_t long_number_impulse = 3;
    bool    cap_polarity        = true;

    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }

    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->setCapSensor(!cap_polarity);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        3 раза нажать сервисную кнопку
    */
    /*!
        Нет изменений
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Включить зажигание
    */
    /*!
        3 длинных + 2 коротких сигнала сирены
    */
    p_gen6->setIgn(PIN, ON);
    
    if (p_gen6->waitSirenPulse(long_number_impulse, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::LONG_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Длинные сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Длинные сигналы сиреной отсутствуют\n");
        return;
    }
    
    uint8_t short_number_impulse = 2;
    
    if (p_gen6->waitSirenPulse(short_number_impulse, 
                               siren_polarity, 
                               TIME_DELAY::FIVE_S, 
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 2. Короткие сигналы сиреной присутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 2. Короткие сигналы сиреной отсутствуют\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Нет изменений
    */
    p_gen6->setIgn(PIN, OFF);
    
    /*!
        3 раза нажать сенсор
    */
    /*!
        Охрана включена
    */
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 4. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
    
    /*!
        Ввести неверный ПИН
    */
    /*!
        4 вспышки светодиодом
        Охрана включена
    */
    const char *incorrect_pin = "7777";
    
    p_gen6->emergencyDisarming(incorrect_pin);
    
    uint8_t impulse_count = 4;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 5. Вспышки подтверждения светодиодом не получены\n");
    }
    else
    {
        printf("PASS Шаг 5. Вспышки подтверждения светодиодом получены\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 5. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
        return;
    }

    p_gen6->setDisarmBeachMode(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
}

// 1. Нажатие сенсора 1 раз в охране с разрешенным вводом ПИН через сенсор 
void AutoTestsModesP2::C168711_TestCase()
{
    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 1 раз
    */
    /*!
        Длинная вспышка ошибки
        Охрана включена
    */
    bool polarity = true;
    
    p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    uint8_t impulse_count = 1;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1. Вспышка подтверждения светодиодом не получена\n");
        return;
    }
    else
    {
        printf("PASS Шаг 1. Вспышка подтверждения светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

// 2. Нажатие сенсора 2 раза в охране с разрешенным вводом ПИН через сенсор 
void AutoTestsModesP2::C168712_TestCase()
{
    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 2 раза
    */
    /*!
        Длинная вспышка ошибки
        Охрана включена
    */
    bool polarity = true;

    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    uint8_t impulse_count = 1;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1. Вспышка подтверждения светодиодом не получена\n");
        return;
    }
    else
    {
        printf("PASS Шаг 1. Вспышка подтверждения светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

// 3. Нажатие сенсора 4 раза в охране с разрешенным вводом ПИН через сенсор 
void AutoTestsModesP2::C168713_TestCase()
{
    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 4 раза
    */
    /*!
        Длинная вспышка ошибки
        Охрана включена
    */
    bool polarity = true;

    for (uint8_t i = 0; i < 4; ++i)
    {
        p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    uint8_t impulse_count = 1;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1. Вспышка подтверждения светодиодом не получена\n");
        return;
    }
    else
    {
        printf("PASS Шаг 1. Вспышка подтверждения светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

// 4. Нажатие сенсора 1 раз в охране с запрещенным вводом ПИН через сенсор 
void AutoTestsModesP2::C168714_TestCase()
{
    if (settings_check(p_c168714) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 1 раз
    */
    /*!
        Охрана включена
    */
    bool polarity = true;
    
    p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::CAP_SENSOR_LESS_MIN_PRESSED_TIME_S);
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

// 5. Нажатие сенсора 2 раза в охране с запрещенным вводом ПИН через сенсор  
void AutoTestsModesP2::C168715_TestCase()
{
    if (settings_check(p_c168714) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 2 раза
    */
    /*!
        Охрана включена
    */
    bool polarity = true;

    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

//  6. Нажатие сенсора 4 раза в охране с запрещенным вводом ПИН через сенсор 
void AutoTestsModesP2::C168716_TestCase()
{
    if (settings_check(p_c168714) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 4 раза
    */
    /*!
        Охрана включена
    */
    bool polarity = true;

    for (uint8_t i = 0; i < 4; ++i)
    {
        p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }
}

// 7. Появление и пропадание метки в охране без Пляжа  
void AutoTestsModesP2::C168717_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, TAG);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
        
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::TEN_S);
    
    int8_t inactive_status_tag = p_gen6->getTagStatus1();
    
    /*!
        Включить метку
    */
    /*!
        Включился статус метки
        Система в охране
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (inactive_status_tag != p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 1. Статусный выход метки активен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Статусный выход метки не активен\n");
        return;
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }   
    
    /*!
        Выключить метку
    */
    /*!
        Выключился статус метки
        Система в охране
    */
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::TEN_S);
    
    if (inactive_status_tag == p_gen6->getTagStatus1())
    {
        printf("PASS Шаг 2. Статусный выход метки не активен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Статусный выход метки активен\n");
        return;
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
}

// 8. Выключение охраны без режима Пляж меткой 
void AutoTestsModesP2::C168718_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, TAG);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану меткой
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
}

// 9. Выключение охраны без режима Пляж брелоком  
void AutoTestsModesP2::C168719_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелком
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
}

// 10. Выключение охраны сенсором (без метки и с отключенными свободными руками по сенсору) 
void AutoTestsModesP2::C168720_TestCase()
{
    bool cap_polarity = true;

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка выключена
        Система в охране (Пляж)
    */
    p_gen6->resetTagVcc();
    p_gen6->setArmBeachMode(cap_polarity,
                            TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                            TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                            TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    wait(TIME_DELAY::FIVE_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана выключена
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
}

// 11. Выключение охраны сенсором (с меткой и с отключенными свободными руками по сенсору)  
void AutoTestsModesP2::C168721_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Система в охране
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    p_gen6->setSecure(ON, TAG);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана выключена
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// 12. Выключение охраны сенсором (без метки и с включенными свободными руками по сенсору) 
void AutoTestsModesP2::C168722_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168723) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка выключена
        Система в охране
    */
    p_gen6->resetTagVcc();
    p_gen6->setSecure(ON, TAG);
    
    wait(TIME_DELAY::FIVE_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана выключена
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// 13. Выключение охраны сенсором (с меткой и с включенными свободными руками по сенсору)  
void AutoTestsModesP2::C168723_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168723) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Система в охране
    */
    p_gen6->setSecure(ON, TAG);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана выключена
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
    
    /*!
        Выключить метку
    */
    /*!
        Охрана включена
    */
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 3. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Охрана не включена\n");
        return;
    }
}

// 14. Ввод ПИН без разрашенного снятия сенсором 
void AutoTestsModesP2::C168724_TestCase()
{
    if (settings_check(p_c168714) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Нет изменений
    */
    bool polarity = true;

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана включена
    */
    p_gen6->setDisarmBeachMode(polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
}

// 15. Окончание времени ожидания ввода ПИН (5 мин.)  
void AutoTestsModesP2::C168725_TestCase()
{
    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ожидать 5 минут
    */
    /*!
        Охрана включена
    */
    wait(TIME_DELAY::FIVE_MINUTE);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
}

// 16. Ввод цифр ПИН с промежутком более 5 сек. 
void AutoTestsModesP2::C168726_TestCase()
{
    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);

    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ввести цифру ПИН
    */
    /*!
        Длинная вспышка светодиода
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                               NULL,
                               1); // вводим первую цифру
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::FIFTEEN_S))
    {
        printf("FAIL Шаг 2. Вспышка ошибки светодиодом не получена\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Вспышка ошибки светодиодом получена\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
}

// 17. Ввод неправильного ПИН  
void AutoTestsModesP2::C168727_TestCase()
{
    // На X96 не заложена проверка светодиода транссивера
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c168703) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Нажать сенсор 3 раза
    */
    /*!
        Импульс на канале сирены
    */
    bool cap_polarity   = true;
    bool siren_polarity = p_gen6->getPolarity(ID_OUT_SIREN);
    
    for (uint8_t i = 0; i < 3; ++i)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    int32_t impulse_count = 1;
    
    if (p_gen6->waitSirenPulse(impulse_count, 
                               siren_polarity,
                               TIME_DELAY::FIVE_S,
                               TIME_DELAY::SHORT_SIREN_IMPULSE_S))
    {
        printf("PASS Шаг 1. Короткий сигнал сиреной присутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Короткий сигнал сиреной отсутствует\n");
        return;
    }
    
    /*!
        Ввести ПИН сенсором
    */
    /*!
        Охрана включена
    */
    const char *incorrect_pin = "7777";
    
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                               incorrect_pin);
    
    impulse_count = 4;
    
    if (!p_gen6->waitServicePulseAmount(impulse_count, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Вспышки ошибки светодиодом не получены\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Вспышки ошибки светодиодом получены\n");
    }
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
}

// Выключение поддержки зажигания при переходе в сервис 
void AutoTestsModesP2::C170779_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПЗ
    */
    /*!
        ПЗ включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN);
    
    if (p_gen6->getSupportIgn())
    {
        printf("PASS Шаг 1. ПЗ включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПЗ выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        ПЗ выключена
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    if (!p_gen6->getSupportIgn())
    {
        printf("PASS Шаг 2. ПЗ выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. ПЗ включена\n");
        return;
    }
}

// Сброс программной нейтрали при переходе в сервис 
void AutoTestsModesP2::C170780_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПН
    */
    /*!
        ПН включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 1. ПН включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПН выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        ПЗ выключена
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    if (!p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 2. ПН выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. ПН включена\n");
        return;
    }
}

// Отсутствие автозапуска в сервисе 
void AutoTestsModesP2::C170781_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170781) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Выполнена ПН
        Система не в охране
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Начальные условия. ПН включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. ПН выключена\n");
        return;
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    printf("INFO Ждем 5 минут после последнего запуска двигателя\n");
    wait(TIME_DELAY::FIVE_MINUTE);
    
    /*!
        Уменьшить температуру ниже порога
    */
    /*!
        Отсутсвие автозапуска
    */
    p_gen6->setEngineTemperatureSensor(0);
    printf("INFO Ждем запуск двигателя\n");
    
    if (!p_gen6->waitInspector(TIME_DELAY::THIRTY_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, 0))
    {
        printf("PASS Шаг 2. Обходчик не включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Обходчик включен\n");
        return;
    }
}

// Отсутствие отпирания ЦЗ в поездке в сервисе 
void AutoTestsModesP2::C170782_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170782) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система не охране
        Зажигание включено
        ЦЗ заперт
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setSecure(ON, KEYRING);
    wait(TIME_DELAY::FIVE_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG, 
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE, 
                                DIAG_FLAG_BIT_LOCK))
    {
        printf("PASS Начальные условия. ЦЗ заперт\n");
    }
    else
    {
        printf("FAIL Начальные условия. ЦЗ не заперт\n");
        return;
    } 
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        ЦЗ заперт
    */
    p_gen6->setIgn(PIN, OFF);
    wait(TIME_DELAY::FIVE_S);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG, 
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE, 
                                DIAG_FLAG_BIT_LOCK))
    {
        printf("PASS Шаг 2. ЦЗ заперт\n");
    }
    else
    {
        printf("FAIL Шаг 2. ЦЗ не заперт\n");
        return;
    } 
}

// Отсутствие запирания ЦЗ в поездке в сервисе 
void AutoTestsModesP2::C170783_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170782) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система не охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить зажигание
    */
    /*!
        ЦЗ не заперт
    */
    p_gen6->setIgn(PIN, ON);
    wait(TIME_DELAY::FIVE_S);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE, 
                                 DIAG_FLAG_BIT_LOCK))
    {
        printf("PASS Шаг 2. ЦЗ не заперт\n");
    }
    else
    {
        printf("FAIL Шаг 2. ЦЗ заперт\n");
        return;
    } 
}

// Невозможность включения антиограбления по метке (меткой) в сервисе  
void AutoTestsModesP2::C170784_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система не охране
    */
    p_gen6->setSecure(OFF, TAG);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить антиограбление меткой
    */
    /*!
        Антиограбление выключено
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    p_gen6->pushTagBtn(TAG_LONG_1);
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                  SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                  DIAG_FLAG_BIT_ANTI_HIJACK_TAG_EN,
                                  ON,
                                  TIME_DELAY::AHJ_TAG_EN_TIME_S))
    {
        printf("PASS Шаг 2. Антиограбление выключено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Антиограбление включено\n");
    }
}

// Невозможность выключения антиограбления по метке (меткой) в сервисе  
void AutoTestsModesP2::C170785_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Антиограбление включено
    */
    if (p_gen6->setAhjTagSetting(ON))
    {
        printf("PASS Начальные условия. Антиограбление включено\n");
    }
    else
    {
        printf("PASS Начальные условия. Антиограбление выключено\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TWO_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить антиограбление меткой
    */
    /*!
        Антиограбление включено
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    p_gen6->pushTagBtn(TAG_LONG_1);
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                  SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                  DIAG_FLAG_BIT_ANTI_HIJACK_TAG_EN,
                                  OFF,
                                  TIME_DELAY::AHJ_TAG_EN_TIME_S))
    {
        printf("PASS Шаг 2. Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Антиограбление выключено\n");
    }
}

// Постановка в охрану голосовой командой в сервисе 
void AutoTestsModesP2::C170786_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану голосом
    */
    /*!
        Охрана выключена
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_ARM,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 2. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::DTMF_CMD_ACTIVATION_TIME_S))
    {
        printf("FAIL Шаг 2. Система не находится в \"Снято\" после отправки DTMF команды\n");
        return;
    }
}

// Постановка в охрану SMS командой в сервисе 
void AutoTestsModesP2::C170787_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану СМС
    */
    /*!
        Охрана выключена
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_PROT_ON);
    
    wait(TIME_DELAY::MIN_WAITING_SMS_STATUS_TIME_S);
    
    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Система не находится в \"Снято\"\n");
        return;
    }
}

// Постановка в охрану брелоком SL в сервисе  
void AutoTestsModesP2::C170788_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану брелком
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// Постановка в охрану штатным брелоком в сервисе
void AutoTestsModesP2::C170789_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        && (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3202904) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setServiceModeTag(ON);
    }
    else
    {
        p_gen6->setServiceModeKeyring();
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }

    /*!
        Поставить в охрану штатным брелком (аналог)
    */
    /*!
        Сервисный режим не выключился
    */
    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 2. Сервисный режим не выключился\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим выключился\n");
        return;
    }

    /*!
        Поставить в охрану штатным брелком (CAN)
    */
    /*!
        Сервисный режим не выключился
    */
    p_gen6->setSecure(ON,
                      CAN_USE,
                      TIME_DELAY::NULL_DELAY_S);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 3. Сервисный режим не выключился\n");
    }
    else
    {
        printf("FAIL Шаг 3. Сервисный режим выключился\n");
    }
}

// Постановка в охрану меткой в сервисе  
void AutoTestsModesP2::C170790_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, TAG);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану меткой
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(ON, TAG);
    
    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Система не находится в \"Снято\"\n");
        return;
    }
}

// Постановка в охрану через SLO в сервисе 
void AutoTestsModesP2::C170791_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану SLO
    */
    /*!
        Охрана выключена
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::ARM, ON);
    
    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Система не находится в \"Снято\"\n");
        return;
    }
}

// Постановка в охрану по свободным рукам в сервисе 
void AutoTestsModesP2::C170792_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170792) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
        Метка включена
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Поставить в охрану свободными руками
    */
    /*!
        Охрана выключена
    */
    p_gen6->resetTagVcc();
    
    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Система не находится в \"Снято\"\n");
        return;
    }
}

// Снятие с охраны голосовой командой в сервисе  
void AutoTestsModesP2::C170793_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    bool polarity_open_inactive = p_gen6->getLockB();
    
    /*!
        Начальные условия
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны голосом
    */
    /*!
        Снято с охраны
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_ARM,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 2. Ошибка при отправке DTMF команды\n");
        return;
    }
   
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// Снятие с охраны SMS командой в сервисе 
void AutoTestsModesP2::C170794_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    bool polarity_open_inactive = p_gen6->getLockB();
    
    /*!
        Начальные условия
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны СМС
    */
    /*!
        Снято с охраны
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_PROT_ON);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// Снятие с охраны брелоком SL в сервисе 
void AutoTestsModesP2::C170795_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    bool polarity_open_inactive = p_gen6->getLockB();
    
    /*!
        Начальные условия
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны
    */
    /*!
        Импульс на ЦЗ открыть
    */
    p_gen6->setSecure(OFF, KEYRING, TIME_DELAY::NULL_DELAY_S);
    
    if (p_gen6->waitCLockOpen(TIME_DELAY::TWENTY_S, !polarity_open_inactive))
    {
        printf("PASS Шаг 2. Получен импульс на открытие ЦЗ\n");
    }
    else
    {
        printf("FAIL Шаг 2. Импульс на открытие ЦЗ отсутствует\n");
        return;
    }
}

// Снятие с охраны штатным брелоком в сервисе
void AutoTestsModesP2::C170796_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        && (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3202904) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }

    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setServiceModeTag(ON);
    }
    else
    {
        p_gen6->setServiceModeKeyring();
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }

    wait(TIME_DELAY::MAX_WAITING_LOCK_B_PULSE_S); // Чтобы не поймать ЦЗ из-за входа в сервис/охраны

    /*!
        Снять с охраны штатным брелком (аналог)
    */
    /*!
        Сервисный режим не выключился
        Импульс на ЦЗ открыть
    */
    p_gen6->sendAnalogSlaveStatus(OFF,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitCLockOpen(TIME_DELAY::MAX_WAITING_LOCK_B_PULSE_S, ID_OUT_LOCK_B))
    {
        printf("PASS Шаг 2. Получен импульс на открытие ЦЗ\n");
    }
    else
    {
        printf("FAIL Шаг 2. Импульс на открытие ЦЗ отсутствует\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 2. Сервисный режим не выключился\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим выключился\n");
        return;
    }

    /*!
        Снять с охраны штатным брелком (CAN)
    */
    /*!
        Сервисный режим не выключился
        Импульс на ЦЗ открыть
    */
    p_gen6->setSecure(OFF,
                      CAN_USE,
                      TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitCLockOpen(TIME_DELAY::MAX_WAITING_LOCK_B_PULSE_S, ID_OUT_LOCK_B))
    {
        printf("PASS Шаг 3. Получен импульс на открытие ЦЗ\n");
    }
    else
    {
        printf("FAIL Шаг 3. Импульс на открытие ЦЗ отсутствует\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 3. Сервисный режим не выключился\n");
    }
    else
    {
        printf("FAIL Шаг 3. Сервисный режим выключился\n");
    }
}

// Снятие с охраны меткой в сервисе 
void AutoTestsModesP2::C170797_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    bool polarity_open_inactive = p_gen6->getLockB();
    
    /*!
        Начальные условия
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны меткой
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, TAG, TIME_DELAY::NULL_DELAY_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана включена\n");
        return;
    }
}

// Снятие с охраны через SLO в сервисе 
void AutoTestsModesP2::C170798_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны SLO
    */
    /*!
        Снято в сервисе
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::ARM, OFF);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
}

// Снятие с охраны по свободным рукам в сервисе 
void AutoTestsModesP2::C170799_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170799) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Система в охране
        Метка выключена
    */
    p_gen6->setSecure(OFF, TAG);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Снять с охраны свободными руками
    */
    /*!
        Снято в сервисе
    */
    p_gen6->setTagVcc();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
}

// Отправка SMS "калибровка" в сервисе
void AutoTestsModesP2::C170800_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c170800) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Система в снято
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }

    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::DTMF_CMD_ACTIVATION_TIME_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }

    /*!
        Отправка SMS - Калибровка
    */
    /*!
        Ответ Команда "Вход в обучение страховой телематики" не выполнена: функция не разрешена в настройках или включен сервисный режим
    */
    if (p_gsm->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                     SMS_CMD_TOKENS_EN::SMS_PARSE_CMD_INSURANCE_LEARN,
                                     Sim900::combineStr("%s %s %s: %s",
                                                        SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                        SMS_MSG_STR::SMS_ANSW_STR_INSURANCE_LEARN_FAILED_1,
                                                        SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                        SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_ENABLE_OR_SERVICE_MODE).c_str()) != SIM900ACT_TRUESMS)
    {
        printf("FAIL Шаг 2. Присутсвует неверное СМС после отправки Калибровка\n");
        return;
    }
}

// Запрос OBD-ошибок в сервисе
void AutoTestsModesP2::C170801_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetCanCarNum);


    if (!p_gen6->loadCanFirmware("5272"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c170801) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запроса OBD-ошибок в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:             | снято
        ||Зажигание:                | отключено
        ||Двигатель:                | заглушен
        ||Подключение к серверу:    | подключен
        ||Настройки:
        ||CAN-автомобиль:           | 5256 - Toyota RAV 4 (кнопка Start-Stop) 2013-2019
        ||Запрос OBD-ошибок:        | включен
        ||Сервер:                   | настроен
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    p_gen6->setRpm(RPM_OFF, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Двигатель не заглушен\n");
        return;
    }

    /*!
        Шаг 1. Включить охрану
    */
    /*!
        Охрана включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    p_gen6->wait_s(TIME_DELAY::DELAY_AFTER_ARM_S);

    /*!
        Шаг 2. Отключить охрану
    */
    /*!
        Переход в снято
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не выключена\n");
        return;
    }

    /*!
        Шаг 3. Завести двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель заведен
        Не позднее чем через 10 мин (сервер делат запрос OBD-ошибок 1 раз в 3 мин) ЦБ отправляет в CAN запросы:
        ID=7DF D1=03
        ID=7DF D1=07
    */
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);
    p_gen6->setRpm(RPM_ON,
                   PIN,
                   TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitObdErrorRequest(TIME_DELAY::OBD_ERROR_REQUEST_MSG_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Пакеты получены\n");
    }
    else
    {
        printf("FAIL Шаг 3. Пакеты не получены\n");
        // Без return, чтобы проверить завелся ли двигатель
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Двигатель не заведен\n");
        return;
    }

    /*!
        Шаг 4. Заглушить двигатель
    */
    /*!
        Двигатель заглушен
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 4. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 4. Зажигание не выключено|n");
        return;
    }

    p_gen6->setRpm(RPM_OFF, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 4. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 4. Двигатель не заглушен\n");
        return;
    }


    /*!
        Шаг 5. Включить Сервисный режим
    */
    /*!
        Переход из снято в сервис
    */
    p_gen6->setServiceMode(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 5. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Сервисный режим не включен\n");
        return;
    }

    /*!
        Шаг 6. Завести двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель заведен
        В течение 10 мин (сервер делат запрос OBD-ошибок 1 раз в 3 мин) запросы ЦБ в CAN:
        ID=7DF D1=03
        ID=7DF D1=07
        - отсутствуют (не отправляются)
    */
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S); // Подождать, пока не дойдут оставшиеся пакеты CAN
    p_gen6->getCanBusActions()->clearFifo();               // Чтобы непрочитанные пакеты не мешали тестированию

    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);
    p_gen6->setRpm(RPM_ON,
                   PIN,
                   TIME_DELAY::NULL_DELAY_S);

    if (!p_gen6->waitObdErrorRequest(TIME_DELAY::OBD_ERROR_REQUEST_MSG_WAIT_TIME_S))
    {
        printf("PASS Шаг 6. Пакеты отсутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 6. Пакеты получены\n");
        // Без return, чтобы проверить завелся ли двигатель
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 6. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 6. Двигатель не заведен\n");
    }
}

// Дистанционный запуск голосовой командой в сервисе 
void AutoTestsModesP2::C170802_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПН
    */
    /*!
        ПН включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 1. ПН включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПН выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 2. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Сделать ДЗ голосом
    */
    /*!
        Нет потенциала на модуле обхода
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_ENG_START,
                     strlen(DTMF_CMD_STR::DTMF_CMD_ENG_START));
    
    if (!p_gen6->waitInspector(TIME_DELAY::THIRTY_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, 0))
    {
        printf("PASS Шаг 3. Обходчик не включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Обходчик включен\n");
        return;
    }
}

// Дистанционный запуск SMS командой в сервисе 
void AutoTestsModesP2::C170803_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПН
    */
    /*!
        ПН включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 1. ПН включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПН выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 2. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Сделать ДЗ SMS
    */
    /*!
        Нет потенциала на модуле обхода
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ENGINE_START);
    
    if (!p_gen6->waitInspector(TIME_DELAY::THIRTY_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, 0))
    {
        printf("PASS Шаг 3. Обходчик не включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Обходчик включен\n");
        return;
    }
}

//  Дистанционный запуск брелоком SL в сервисе 
void AutoTestsModesP2::C170804_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПН
    */
    /*!
        ПН включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 1. ПН включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПН выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Сделать ДЗ брелком
    */
    /*!
        Нет потенциала на модуле обхода
    */
    p_gen6->setRemoteRun(KEYRING);
    
    if (!p_gen6->waitInspector(TIME_DELAY::THIRTY_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, 0))
    {
        printf("PASS Шаг 3. Обходчик не включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Обходчик включен\n");
        return;
    }
}

// Дистанционный запуск штатным брелоком в сервисе
void AutoTestsModesP2::C170805_TestCase()
{
    // Для включения сервиса нужен либо брелок, либо метка
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c170805) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | выключено
        ||Паркинг:                                      | включен
        ||Система в:                                    | Сервисный режим
        ||Настройки:
        ||Тип КПП:                                      | АКПП
        ||Тип запуска:                                  | Кнопка Старт-Стоп
        ||CAN-автомобиль:                               | Batmobile (9999)
        ||Постановка штатной системы охраны:            | включено (галочка стоит)
        ||Разрешение запуска двигателя:                 | включено (галочка стоит)
        ||Разрешение запуска двигателя штатным брелком: | включено (галочка стоит)
    */
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->setAndCheckParking(ON, PIN))
    {
        printf("PASS Начальные условия. Паркинг включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Паркинг не включен\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
    }
    else if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setServiceModeTag(ON);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    /*!
        Шаг 1. Выполнить ДЗ штатным брелком
    */
    /*!
        Двигатель не начал заводиться (нет потенциала на проводе обходчика иммобилайзера)
        Двигатель заглушен
    */
    p_gen6->setRemoteRun(STD);

    if (!p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Двигатель не начал заводиться (нет потенциала на проводе обходчика иммобилайзера)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Двигатель начал заводиться (получен потенциал на проводе обходчика иммобилайзера)\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("PASS Шаг 1. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Двигатель не заглушен\n");
    }
}

// Дистанционный запуск гибкой логикой в сервисе
void AutoTestsModesP2::C170806_TestCase()
{
    // Для включения сервиса нужен либо брелок, либо метка
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c170806) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Охрана:                                    | выключена
        ||Ручник:                                    | включен
        ||Настройки:
        ||Разрешение запуска двигателя:              | Галочка стоит
        ||КПП:                                       | АКПП
        ||Система запуска:                           | Замок зажигания
        ||Управление обходом штатного иммобилайзера: | Аналоговый сигнал
        ||Алгоритм модуля работы иммобилайзера:      | Активен все время работы при АЗ/ДЗ, в том числе при ПН и ТТ
        ||Настроена и включена программа ГЛ:         | Если (состояние охранного комплекса/режим работы/вход в сервисный режим) то (состояние охранного комплекса/запуск двигателя/завести двигатель)
        ||Настроен канал:                            | Управление потенциалом модуля обхода штатного иммобилайзера
        ||Настроен канал:                            | Концевой выключатель стояночного тормоза
        ||Не настроен канал:                         | Паркинг
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Начальные условия. Ручник включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Ручник не включен\n");
        return;
    }

    /*!
        Шаг 1. Войти в сервисный режим
    */
    /*!
        Сервисный режим включен
        Двигатель не начал заводиться (нет потенциала на проводе обходчика иммобилайзера)
        Двигатель заглушен
    */
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
    }
    else if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setServiceModeTag(ON);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }

    if (!p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_ACTION_CHECK_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Двигатель не начал заводиться (нет потенциала на проводе обходчика иммобилайзера)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Двигатель начал заводиться (получен потенциал на проводе обходчика иммобилайзера)\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("PASS Шаг 1. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Двигатель не заглушен\n");
    }
}

// Дистанционный запуск через SLO в сервисе 
void AutoTestsModesP2::C170807_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить ПН
    */
    /*!
        ПН включена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("PASS Шаг 1. ПН включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. ПН выключена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 2. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Сделать ДЗ через SLO
    */
    /*!
        Нет потенциала на модуле обхода
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::IGN, ON);
    
    if (!p_gen6->waitInspector(TIME_DELAY::THIRTY_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, 0))
    {
        printf("PASS Шаг 3. Обходчик не включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Обходчик включен\n");
        return;
    }
}

// Запуск ППП голосовой командой в сервисе 
void AutoTestsModesP2::C170808_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170808) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Запуск ППП голосом
    */
    /*!
        Нет потенциала на проводе ППП
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ENG_HEAT_START,
                     strlen(SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ENG_HEAT_START));
    
    if (p_gen6->getPppStart() != m_engine_block_type)
    {
        printf("PASS Шаг 2. Импульс запуска ППП не получен\n"); 
    }
    else
    {
        printf("FAIL Шаг 2. Импульс запуска ППП получен\n");   
    }
}

// Запуск ППП SMS командой в сервисе 
void AutoTestsModesP2::C170809_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170808) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Запуск ППП СМС
    */
    /*!
        Нет потенциала на проводе ППП
    */
    p_gen6->getSim900()->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                 SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ENG_HEAT_START);
    
    if (p_gen6->getPppStart() != m_engine_block_type)
    {
        printf("PASS Шаг 2. Импульс запуска ППП не получен\n"); 
    }
    else
    {
        printf("FAIL Шаг 2. Импульс запуска ППП получен\n");   
    }
}

// Запуск ППП брелоком SL в сервисе 
void AutoTestsModesP2::C170810_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170808) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Запуск ППП СМС
    */
    /*!
        Нет потенциала на проводе ППП
    */
    p_gen6->startPpp(KEYRING);
    
    if (p_gen6->getPppStart() != m_engine_block_type)
    {
        printf("PASS Шаг 2. Импульс запуска ППП не получен\n"); 
    }
    else
    {
        printf("FAIL Шаг 2. Импульс запуска ППП получен\n");   
    }
}

// Запуск ППП штатным брелоком в сервисе  
void AutoTestsModesP2::C170811_TestCase()
{
    printf(CASE_NOT_FOUND);
    return;
}

// Запуск ППП через SLO в сервисе  
void AutoTestsModesP2::C170812_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170808) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Запуск ППП через SLO
    */
    /*!
        Нет потенциала на проводе ППП
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::WEBASTO, ON);
    
    if (p_gen6->getPppStart() != m_engine_block_type)
    {
        printf("PASS Шаг 2. Импульс запуска ППП не получен\n"); 
    }
    else
    {
        printf("FAIL Шаг 2. Импульс запуска ППП получен\n");   
    }
}

// Отсутствие подхвата зажигания по турботаймеру в сервисе 
void AutoTestsModesP2::C170813_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выполнить подхват зажигания по ТТ
    */
    /*!
        ПЗ выключена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setRpm(RPM_800, PIN);
    p_gen6->setRpm(RPM_2000, PIN);
    p_gen6->setRpm(RPM_800, PIN);
    p_gen6->setHandBreak(ON, PIN);
    
    if (!p_gen6->getTurboTimer())
    {
        printf("PASS Шаг 2. ТТ выключен\n");
    }
    else
    {
        printf("FAIL Шаг 2. ТТ включен\n");
        return;
    }
}

// Отсутствие подхвата зажигания при установке программной нейтрали в сервисе 
void AutoTestsModesP2::C170814_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выполнить ПЗ
    */
    /*!
        ПЗ выключена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setHandBreak(ON, PIN);
    
    if (!p_gen6->getSupportIgn())
    {
        printf("PASS Шаг 2. ПЗ выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. ПЗ включена\n");
        return;
    }
}

// Отсутствие подхвата зажигания при постановке в охрану с работающим двигателем в сервисе 
void AutoTestsModesP2::C170815_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выполнить ПЗ с работающим двигателем
    */
    /*!
        ПЗ выключена
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::ONE_S); 
    p_gen6->setHandBreak(ON, PIN);   
    p_gen6->setIgn(PIN, OFF);
    wait(TIME_DELAY::ONE_S);
    
    if (!p_gen6->getSupportIgn())
    {
        printf("PASS Шаг 2. ПЗ выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. ПЗ включена\n");
        return;
    }
}

// Открытие багажника брелоком SL в сервисе 
void AutoTestsModesP2::C170816_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168685) == 0)
    {
        return;
    }
    
    int8_t trunk_inactive = p_gen6->getTrunkOpen();
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Отпирание багажника брелком
    */
    /*!
        Импульс на проводе отпирание багажника
    */
    p_gen6->unlockTrunk(KEYRING);

    if (!p_gen6->waitTrunk(TIME_DELAY::THREE_S, !trunk_inactive))
    {
        printf("PASS Шаг 1. Импульс на открытие багажника не получен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Импульс на открытие багажника получен\n");
        return;
    }
}

// Открытие багажника через SLO в сервисе  
void AutoTestsModesP2::C170817_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168685) == 0)
    {
        return;
    }
    
    int8_t trunk_inactive = p_gen6->getTrunkOpen();
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Отпирание багажника SLO
    */
    /*!
        Импульс на проводе отпирание багажника
    */
    p_gen6->unlockTrunk(SLO);

    if (!p_gen6->waitTrunk(TIME_DELAY::THREE_S, !trunk_inactive))
    {
        printf("PASS Шаг 1. Импульс на открытие багажника не получен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Импульс на открытие багажника получен\n");
        return;
    }
}

// Включение паники SMS командой в сервисе  
void AutoTestsModesP2::C170818_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    int8_t siren_inactive = p_gen6->getSiren();
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить панику СМС
    */
    /*!
        Отсутсвует импульс на проводе сирены
    */
    p_gen6->setPanic(PANIC_SMS);
    
    if (!p_gen6->waitSiren(TIME_DELAY::THREE_S, !siren_inactive))
    {
        printf("PASS Шаг 2. Сирена выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сирена включена\n");
        return;
    }
}

// Включение паники брелоком SL в сервисе 
void AutoTestsModesP2::C170819_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    int8_t siren_inactive = p_gen6->getSiren();
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить панику брелком
    */
    /*!
        Отсутсвует импульс на проводе сирены
    */
    p_gen6->setPanic(PANIC_REMOTE);
    
    if (!p_gen6->waitSiren(TIME_DELAY::THREE_S, !siren_inactive))
    {
        printf("PASS Шаг 2. Сирена выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сирена включена\n");
        return;
    }
}

// Включение паники через SLO в сервисе 
void AutoTestsModesP2::C170820_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c168671) == 0)
    {
        return;
    }
    
    int8_t siren_inactive = p_gen6->getSiren();
    
    /*!
        Начальные условия
    */
    /*!
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    if (!checkDtmfOwnerAccess(M1,
                              DTMF_CMD_STR::DTMF_CMD_SERVICE_ON,
                              GSM_PASS_DIS,
                              GSM_M2_OWNER_ACCESS_DIS))
    {
        printf("FAIL Шаг 1. Ошибка при отправке DTMF команды\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить панику SLO
    */
    /*!
        Отсутсвует импульс на проводе сирены
    */
    p_gen6->setPanic(PANIC_SLO);
    
    if (!p_gen6->waitSiren(TIME_DELAY::THREE_S, !siren_inactive))
    {
        printf("PASS Шаг 2. Сирена выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сирена включена\n");
        return;
    }
}

// Включение свободных рук голосовой командой в сервисе  
void AutoTestsModesP2::C170821_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить свободные руки голосом
    */
    /*!
        Свободные руки выключены
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON));
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 2. Свободные руки включены\n");
        return;
    }
}

// Включение свободных рук SMS командой в сервисе 
void AutoTestsModesP2::C170822_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить свободные руки по SMS
    */
    /*!
        Свободные руки выключены
    */
    p_gsm->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                   SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_HANDS_FREE_ON);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 2. Свободные руки включены\n");
        return;
    }
}

// Включение свободных рук брелоком SL в сервисе 
void AutoTestsModesP2::C170823_TestCase()
{
    if (   ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
        || ((p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить свободные руки брелком
    */
    /*!
        Свободные руки выключены
    */
    p_gen6->setHandsFreeKeyring();
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 2. Свободные руки включены\n");
        return;
    }
}

// Включение свободных рук через SLO в сервисе 
void AutoTestsModesP2::C170824_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Включить свободные руки через SLO
    */
    /*!
        Свободные руки выключены
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::HFREE, ON);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 2. Свободные руки включены\n");
        return;
    }
}

// Выключение свободных рук голосовой командой в сервисе  
void AutoTestsModesP2::C170825_TestCase()
{    
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить свободные руки голосом
    */
    /*!
        Нет изменений
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON));
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить свободные руки голосом
    */
    /*!
        Свободные руки включены
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_OFF,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_OFF));
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 3. Свободные руки выключены\n");
        return;
    }
}

// Выключение свободных рук SMS командой в сервисе 
void AutoTestsModesP2::C170826_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить свободные руки голосом
    */
    /*!
        Нет изменений
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON));
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить свободные руки СМС
    */
    /*!
        Свободные руки включены
    */
    p_gsm->sendSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                   SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_HANDS_FREE_OFF);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 3. Свободные руки выключены\n");
        return;
    }
}

// Выключение свободных рук брелоком SL в сервисе  
void AutoTestsModesP2::C170827_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
        || ((p_gen6->getModules() & R868_MODULE) != R868_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить свободные руки голосом
    */
    /*!
        Нет изменений
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON));
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeKeyring();
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить свободные руки брелком
    */
    /*!
        Свободные руки включены
    */
    p_gen6->setHandsFreeKeyring();
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 3. Свободные руки выключены\n");
        return;
    }
}

// Выключение свободных рук через SLO в сервисе 
void AutoTestsModesP2::C170828_TestCase()
{
    if (   ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
        || ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170821) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Метка включена
        Снято с охраны
    */
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    /*!
        Включить свободные руки голосом
    */
    /*!
        Нет изменений
    */
    p_gen6->sendDtmf(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                     DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON,
                     strlen(DTMF_CMD_STR::DTMF_CMD_HANDSFREE_ON));
    
    /*!
        Включить сервисный режим
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 ON,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сервисный режим не включен\n");
        return;
    }
    
    /*!
        Выключить свободные руки через SLO
    */
    /*!
        Свободные руки включены
    */
    p_gen6->setStarlineOnlineParam(StarlineOnline::HFREE, OFF);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_HANDS_FREE))
    {
        printf("FAIL Шаг 3. Свободные руки выключены\n");
        return;
    }
}

// Проверка блокировки по CAN 
void AutoTestsModesP2::C169639_TestCase()
{
    if (settings_check(p_c169639) == 0)
    {
        return;
    }
    
    p_gen6->sigmaWorkMode();
    
    /*!
        Начальные условия
    */
    /*!
        Включена Блокировка двигателя по CAN
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
    }   
    
    /*!
        Вызвать тревогу (запустить двигатель)
    */
    /*!
        Включилась тревога
        отправлены CAN пакеты блокировки двигателя (по CAN-шине)     
    */
    p_gen6->setEngine(ON, PIN);
    p_gen6->setIgn(PIN, ON);
     
    if (!p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя не получены\n");
    }
    
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S,
                                  NULL,
                                  false))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
    }
    
    p_gen6->sigmaSettingMode();
}

// Проверка запрета запуска по CAN 
void AutoTestsModesP2::C169640_TestCase()
{
    if (settings_check(p_c169640) == 0)
    {
        return;
    }
    
    p_gen6->sigmaWorkMode();
    
    /*!
        Начальные условия
    */
    /*!
        Включен Запрет запуска по CAN
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
    }   
   
    /*!
        Завести двигатель
    */
    /*!
        CAN-пакеты запрета запуска
        Запуск не произошел
        Тревога
    */
    p_gen6->setIgn(CAN_USE, ON, TIME_DELAY::NULL_DELAY_S);
    
    if (!p_can1_act->waitBlockEnabled(TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска не получены\n");
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 1. Система не находится в соостоянии \"Тревога\" после блокировки по CAN\n");
    }

    p_gen6->sigmaSettingMode();
}

// 1. Блокировка заглушенного двигателя (блок. только заведенного двиг. откл.)
void AutoTestsModesP2::C169641_TestCase()
{
    if (settings_check(p_c169641) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД отключена
        Блокировка двигателя в АО только при нажатии педали тормоза ОТключена
        Охрана включена
        Двигатель заглушен
        ДД настроен
    */
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (открыть дверь)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 2. Блокировка заглушенного двигателя (блок. с педалью тормоза вкл.)
void AutoTestsModesP2::C169642_TestCase()
{
    if (settings_check(p_c169642) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД отключена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Охрана включена
        Двигатель заглушен
        ДД настроен
    */
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (открыть дверь)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 3. Отсутствие блокировки заглушенного двигателя (блок. только заведенного двиг. вкл.)
void AutoTestsModesP2::C169643_TestCase()
{
    if (settings_check(p_c169643) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД Включена
        Блокировка двигателя в АО только при нажатии педали тормоза ОТключена
        Охрана включена
        Двигатель заглушен
        ДД настроен
    */
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (открыть дверь)
    */
    /*!
        Включилась тревога
        Выход блокировки НЕ включился
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка включена\n");
    }

}

// 4. Блокировка заведенного двигателя (блок. только заведенного двиг. откл.)
void AutoTestsModesP2::C169644_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169644) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД отключена
        Блокировка двигателя в АО только при нажатии педали тормоза ОТключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 5. Блокировка заведенного двигателя (блок. только заведенного двиг. вкл.)
void AutoTestsModesP2::C169645_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169645) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза отключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Длительность блокировки: 5
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включилась тревога
        Выход блокировки включился
        Через 5 сек (длительность блокировки) выход блокировки отключился
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    if (!p_gen6->waitBlock(m_eng_block_local0_block_s,
                           TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                           OFF))
    {
        printf("FAIL Шаг 1. Выход блокировки не отключился или отключился за пределами времени ожидания\n");
    }
}

// 6. Включение блокировки в тревоге на заведенном двигателе
void AutoTestsModesP2::C169646_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169645) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза отключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Длительность блокировки: 5
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (включить зажигание)
    */
    /*!
        Включилась тревога
        Выход блокировки не включился
    */
    p_gen6->setIgn(PIN, ON);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка включена\n");
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Выход блокировки включился
        Через 5 сек (длительность блокировки) выход блокировки отключился
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S))
    {
        printf("FAIL Шаг 2. Выход блокировки не включился\n");
        return;
    }

    if (!p_gen6->waitBlock(m_eng_block_local0_block_s,
                           TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                           OFF))
    {
        printf("FAIL Шаг 2. Выход блокировки не отключился или отключился за пределами времени ожидания\n");
    }
}

// 7. Отсутствие блокировки при скорости выше разрешенной
void AutoTestsModesP2::C169647_TestCase()
{
    uint8_t speed = 40;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169645) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза отключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Длительность блокировки: 5
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 40
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки не включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка включена\n");
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выход блокировки не включился
    */
    if (p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S))
    {
        printf("FAIL Шаг 2. Выход блокировки включился\n");
    }
}

// 8. Блокировка с не нажатой педалью тормоза со скоростью меньше 10 км/ч
void AutoTestsModesP2::C169648_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169648) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД выключена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 9. Блокировка с нажатой педалью тормоза (скорость 10 - разрешенная)
void AutoTestsModesP2::C169649_TestCase()
{
    uint8_t speed = 20;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169648) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД выключена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 20
        Педаль тормоза нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setBreak(ON, PIN);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 10. Отсутствие блокировки с не нажатой педалью тормоза с последующим нажатием
void AutoTestsModesP2::C169650_TestCase()
{
    uint8_t speed = 20;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169648) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД выключена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 20
        Педаль тормоза не нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка не включена\n");
        return;
    }

    /*!
        Нажать педаль тормоза
    */
    /*!
        Выход блокировки не отключился
    */
    p_gen6->setBreak(ON,
                     PIN,
                     TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);

    if (p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S,
                          TIME_DELAY::NO_ERROR_TIME_S,
                          OFF))
    {
        printf("FAIL Шаг 2. Блокировка выключена\n");
    }
}

// 11. Глушение двигателя в тревоге с выключением блокировки
void AutoTestsModesP2::C169651_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169645) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза Выключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки не включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка включена\n");
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выход блокировки включился
        Через 5 сек (длительность блокировки) выход блокировки отключился
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S))
    {
        printf("FAIL Шаг 2. Выход блокировки не включился\n");
        return;
    }

    if (!p_gen6->waitBlock(m_eng_block_local0_block_s,
                           TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                           OFF))
    {
        printf("FAIL Шаг 2. Выход блокировки не отключился или отключился за пределами времени ожидания\n");
    }
}

// 12. Глушение двигателя в тревоге без выключения блокировки
void AutoTestsModesP2::C169652_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169644) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВЫКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза Выключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
        ДД настроен
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (по ДД)
    */
    /*!
        Сработал ДД
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Дождаться прекращения фиксации движения (ДД не активен)
    */
    /*!
        Выход блокировки не вЫключился
    */
    if (p_gen6->waitBlock(TIME_DELAY::MAX_WAITING_REGION_STATE_S,
                          TIME_DELAY::NO_ERROR_TIME_S,
                          OFF))
    {
        printf("FAIL Шаг 2. Блокировка выключена\n");
    }
}

// 13. Выключение педали тормоза в тревоге без выключения блокировки
void AutoTestsModesP2::C169653_TestCase()
{
    uint8_t speed = 20;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169648) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВЫКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 20
        Педаль тормоза нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setBreak(ON, PIN);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Выключить педаль тормоза
    */
    /*!
        Выход блокировки не вЫключился
    */
    p_gen6->setBreak(OFF, PIN);

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 2. Блокировка выключена\n");
    }
}

// 14. Превышение скорости 10 км/ч в тревоге без выключения блокировки
void AutoTestsModesP2::C169654_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169648) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВЫКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза Включена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Повысить скорость до 20 км/ч
    */
    /*!
        Выход блокировки не вЫключился
    */
    speed = 20;

    p_can1_act->setSpeed(speed);

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 2. Блокировка выключена\n");
    }
}

// 15. Превышение скорости выше разрешенной в тревоге без выключения блокировки
void AutoTestsModesP2::C169655_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169644) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВЫКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза ВЫключена
        Скорость ниже которой разрешена блокировка двигателя: 30
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Повысить скорость до 40 км/ч
    */
    /*!
        Выход блокировки не вЫключился
    */
    speed = 40;

    p_can1_act->sendSpeed(speed);

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 2. Блокировка выключена\n");
    }
}

// 16. Выключение блокировки
void AutoTestsModesP2::C169656_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ВЫКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза ВЫключена
        Скорость ниже которой разрешена блокировка двигателя: 0
        Задержка блокировки: 0
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Педаль тормоза не нажата
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Заглушить двигатель и дождаться окончания тревоги
    */
    /*!
        Выход блокировки вЫключился
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->setEngine(OFF, PIN);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::ALARM_DIS_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("FAIL Шаг 2. Тревога не выключилась\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 2. Блокировка включена\n");
    }
}

// Блокировка заглушенного двигателя с задержкой
void AutoTestsModesP2::C1578122_TestCase()
{
    uint8_t speed = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1578122) == 0)
    {
        return;
    }

    if (m_eng_block_local0_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Задержка блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НЗ
        Блокировка при срабатывании ДД ОтКлючена
        Блокировка двигателя в АО только при нажатии педали тормоза отключена
        Задержка блокировки 60 сек
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
    */
    p_can1_act->sendSpeed(speed);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    /*!
        Вызвать тревогу (завести двигатель)
    */
    /*!
        Включилась тревога
        Через 60 сек Выход блокировки включился
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setEngine(ON, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    if (!p_gen6->waitBlock(m_eng_block_local0_delay_s, TimeoutCalculator::calcToutError(m_eng_block_local0_delay_s)))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 1. Выключение блокировки при выключении охраны
void AutoTestsModesP2::C169657_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169657) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При снятии с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 0 сек
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка включена (выход блокировки выключен)
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    if (!waitBlock(ON))
    {
        printf("FAIL Начальные условия. Блокировка выключена\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Выход блокировки включился (блокировка отключилась)
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }

    if (!waitBlock(OFF))
    {
        printf("FAIL Шаг 1. Блокировка включена\n");
    }
}

// 2. Включение блокировки при включении охраны
void AutoTestsModesP2::C169658_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169657) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При снятии с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 0 сек
        Охрана вЫключена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка вЫключена (выход блокировки включен)
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }

    if (!waitBlock(OFF))
    {
        printf("FAIL Начальные условия. Блокировка включена\n");
        return;
    }

    /*!
        Включить охрану
    */
    /*!
        Охрана включена
        Выход блокировки отключился (блокировка включилась)
    */
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана выключена\n");
        return;
    }

    if (!waitBlock(ON))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 3. Отсутствие выключения блокировки при выключении охраны
void AutoTestsModesP2::C169659_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169659) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При включении зажигания в снято с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 0 сек
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка включена (выход блокировки отключен)
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    if (!waitBlock(ON))
    {
        printf("FAIL Начальные условия. Блокировка выключена\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Выход блокировки НЕ включился (блокировка осталась включенной)
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }

    if (waitBlock(OFF))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// 4. Выключение блокировки при включении зажигания
void AutoTestsModesP2::C169660_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169659) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При включении зажигания в снято с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 0 сек
        Охрана включена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка включена (выход блокировки отключен)
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(ON, KEYRING);

    if (p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    if (!waitBlock(ON))
    {
        printf("FAIL Начальные условия. Блокировка выключена\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Выход блокировки НЕ включился (блокировка осталась включенной)
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }

    if (p_gen6->getBlock(PIN))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
        return;
    }

    /*!
        Включить зажигание
    */
    /*!
        Выход блокировки включился (блокировка отключилась)
    */
    p_gen6->setIgn(PIN, ON);

    if (!waitBlock(OFF))
    {
        printf("FAIL Шаг 2. Блокировка включена\n");
    }
}

// 5. Включение блокировки при выключении зажигания
void AutoTestsModesP2::C169661_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169659) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При включении зажигания в снято с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 0 сек
        Охрана вЫключена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка вЫключена (выход блокировки включен)
        Зажигание включено
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setIgn(PIN, ON);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }

    if (!waitBlock(OFF))
    {
        printf("FAIL Начальные условия. Блокировка включена\n");
        return;
    }

    /*!
        ВЫключить зажигание
    */
    /*!
        Выход блокировки отключился (блокировка включилась)
    */
    p_gen6->setIgn(PIN, OFF);

    if (!waitBlock(ON))
    {
        printf("FAIL Шаг 1. Блокировка выключена\n");
    }
}

// Включение блокировки при выключении зажигания с задержкой
void AutoTestsModesP2::C1578123_TestCase()
{
    uint8_t speed_kmph = 0;


    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1578123) == 0)
    {
        return;
    }

    if (m_eng_block_local0_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не найдена настройка \"Задержка блокировки\"\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен выход блокировки двигателя
        Тип блокировки двигателя: НР
        Снятие блокировки При включении зажигания в снято с охраны
        Блокировка двигателя только при нажатии педали тормоза ОТключена
        Задержка блокировки 60 сек
        Охрана вЫключена
        Двигатель заглушен
        Скорость автомобиля: 0
        Блокировка вЫключена (выход блокировки включен)
        Зажигание включено
    */
    p_can1_act->sendSpeed(speed_kmph);
    p_gen6->setSecure(OFF, KEYRING);
    p_gen6->setIgn(PIN, ON);

    if (!p_gen6->checkSecure())
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }

    if (!waitBlock(OFF))
    {
        printf("FAIL Начальные условия. Блокировка включена\n");
        return;
    }

    /*!
        ВЫключить зажигание
    */
    /*!
        Через 60 сек Выход блокировки вЫключился (блокировка включилась)
    */
    p_gen6->setIgn(PIN, OFF);

    if (!waitBlock(ON,
                   m_eng_block_local0_delay_s,
                   TimeoutCalculator::calcToutError(m_eng_block_local0_delay_s)))
    {
        printf("FAIL Шаг 1. Выход блокировки не выключился или выключился за пределами настроенного значения\n");
    }
}

//    22. Выключение перепостановки включением ручника 
void AutoTestsModesP2::C171184_TestCase()
{
    if (settings_check(p_c171184) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Перепостановка включена =
        Время до перепостановки 10 сек =
        Охрана включена
        Ручник не затянут
    */
    p_gen6->setHandBreak(OFF, PIN);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_HAND_BRAKE))
    {
        printf("FAIL Начальные условия. Ручник затянут.\n");
    }
    
    printf("PASS Начальные условия. Ручник не затянут.\n");

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Ошибка при постановке в охрану.\n");
        return;
    }  
     
    printf("PASS Начальные условия. Охрана включена.\n");

    /*!
        Выключение охраны
    */
    /*!
        Автомобиль не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Система не находится в снято с охраны (перепостановка включена).\n");
        return;
    }
     
    printf("PASS Шаг 1. Охрана выключена (перепостановка включена).\n");

    /*!
        Затянуть ручник
    */
    /*!
        Снято с охраны
    */
    p_gen6->setHandBreak(ON, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM,
                                 ON,
                                 TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 2. Охрана включена, сработала перепостановка.\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Охрана выключена (перепостановка включена).\n");
    }
}

//    23. Выключение перепостановки вЫключением ручника 
void AutoTestsModesP2::C171185_TestCase()
{
    if (settings_check(p_c171184) == 0)
    {
        return;
    }
    /*!
        Начальные условия
    */
    /*!
        Перепостановка включена =
        Время до перепостановки 10 сек =
        Охрана включена
        Ручник затянут
    */
    p_gen6->setHandBreak(ON, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HAND_BRAKE))
    {
        printf("FAIL Начальные условия. Ручник не затянут.\n");
    }

    printf("PASS Начальные условия. Ручник затянут.\n");

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Ошибка при постановке в охрану.\n");
        return;
    }  
     
    printf("PASS Начальные условия. Охрана включена.\n");

    /*!
        Выключение охраны
    */
    /*!
        Автомобиль не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Система не находится в снято с охраны (перепостановка включена).\n");
        return;
    }
     
    printf("PASS Шаг 1. Охрана выключена (перепостановка включена).\n");

    /*!
        Опустить ручник
    */
    /*!
        Снято с охраны
    */
    p_gen6->setHandBreak(OFF, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM,
                                 ON,
                                 TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 2. Охрана включена, сработала перепостановка.\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Охрана выключена (перепостановка включена).\n");
    }
}

//    24. Выключение перепостановки включением педали тормоза.
void AutoTestsModesP2::C171188_TestCase()
{
    if (settings_check(p_c171184) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Перепостановка включена =
        Время до перепостановки 10 сек =
        Охрана включена
        Педаль тормоза не нажата
    */
    p_gen6->setBreak(OFF, PIN);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_BRAKE_PEDAL))
    {
        printf("FAIL Начальные условия. Педаль тормоза нажата.\n");
    }

    printf("PASS Начальные условия. Педаль тормоза не нажата.\n");

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Ошибка при постановке в охрану.\n");
        return;
    }  
     
    printf("PASS Начальные условия. Охрана включена.\n");

    /*!
        Выключение охраны
    */
    /*!
        Автомобиль не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Система не находится в снято с охраны (перепостановка включена).\n");
        return;
    }
     
    printf("PASS Шаг 1. Охрана выключена (перепостановка включена).\n");

    /*!
        Нажать педаль тормоза
    */
    /*!
        Снято с охраны
    */
    p_gen6->setBreak(ON, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM,
                                 ON,
                                 TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 2. Охрана включена, сработала перепостановка.\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Охрана выключена (перепостановка включена).\n");
    }
}

//    25. Выключение перепостановки вЫключением педали тормоза.
void AutoTestsModesP2::C171189_TestCase()
{
    if (settings_check(p_c171184) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Перепостановка включена =
        Время до перепостановки 10 сек =
        Охрана включена
        Нажата педаль тормоза
    */
    p_gen6->setBreak(ON, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_BRAKE_PEDAL))
    {
        printf("FAIL Начальные условия. Педаль тормоза не нажата.\n");
    }

    printf("PASS Начальные условия. Нажата педаль тормоза.\n");

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Ошибка при постановке в охрану.\n");
        return;
    }  
     
    printf("PASS Начальные условия. Охрана включена.\n");

    /*!
        Выключение охраны
    */
    /*!
        Автомобиль не в охране
    */
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Система не находится в снято с охраны (перепостановка включена).\n");
        return;
    }
     
    printf("PASS Шаг 1. Охрана выключена (перепостановка включена).\n");

    /*!
        Отпустить педаль тормоза
    */
    /*!
        Снято с охраны
    */
    p_gen6->setBreak(OFF, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM,
                                 ON,
                                 TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 2. Охрана включена, сработала перепостановка.\n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Охрана выключена (перепостановка включена).\n");
    }
}

// Авторизация при мягкой посадке по педали тормоза
void AutoTestsModesP2::C1616162_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1616162) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Тип КПП: Автомобиль с ручной коробкой передач
        Система запуска двигателя: Старт-Стоп
        Вежливая посадка: Удерживание педали тормоза 3 секунды
        Требование авторизации при снятии брелоком: включено
        Авторизация владельца штатными кнопками: включена
        Охрана включена
        ПН выполнена
        Выполнен ДЗ
        Двигатель работает
    */
    p_gen6->setIgn(PIN, ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setEngine(ON, PIN, RPM_ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setIgn(PIN, OFF);
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->getProgramNeutral())
    {
        printf("FAIL Начальные условия. ПН не выполнена\n");
        return;
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны брелоком
    */
    /*!
        Автомобиль не в охране
        Переход в ожидание авторизации
    */    
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1. Система не находится в ожидании авторизации\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 2. Дверь закрыта\n");
        return;
    }
    
    /*!
        Нажать педаль тормоза не менее чем на 3 сек
    */
    /*!
        ПН сброшена
        Не должно быть произведено попыток сигнализацией заглушить двигатель подачей импульсов на кнопку Старт-Стоп
    */
    p_gen6->setBreak(ON, PIN);
    wait(TIME_DELAY::FIVE_S);
    p_gen6->setBreak(OFF, PIN);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("FAIL Шаг 3. ПН выполнена\n");
        return;
    }
    
    if (p_gen6->waitStartStopBtn(TIME_DELAY::TEN_S, 0))
    {
        printf("FAIL Шаг 3. Получен импульс старт-стоп\n");
        return;
    }
    
    /*!
        Нажать правильную комбинацию штатных кнопок
    */
    /*!
        Авторизация пройдена
        Внутренний Звукоизлучатель не включился 
        Сирена не включилась 
        Тревога не включилась
    */
    p_gen6->sendValidatorCode();
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 4. Система не находится в снято\n");
        return;
    }
    
    if (p_gen6->getAlarm())
    {
        printf("FAIL Шаг 4. Сирена включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 4. Тревога\n");
        return;
    }
}

// Авторизация при мягкой посадке по паркингу
void AutoTestsModesP2::C1616163_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1616163) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Тип КПП: Автомобиль с ручной коробкой передач
        Система запуска двигателя: Старт-Стоп
        Вежливая посадка: Снятие с паркинга
        Требование авторизации при снятии брелоком: включено
        Авторизация владельца штатными кнопками: включена
        Охрана включена
        ПН выполнена
        Выполнен ДЗ
        Двигатель работает
        Паркинг включен
    */
    p_gen6->setParking(ON, PIN);
    p_gen6->setIgn(PIN, ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setEngine(ON, PIN, RPM_ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setIgn(PIN, OFF);
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->getProgramNeutral())
    {
        printf("FAIL Начальные условия. ПН не выполнена\n");
        return;
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны брелоком
    */
    /*!
        Автомобиль не в охране
        Переход в ожидание авторизации
    */    
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1. Система не находится в ожидании авторизации\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 2. Дверь закрыта\n");
        return;
    }
    
    /*!
        Выключить паркинг
    */
    /*!
        ПН сброшена
        Не должно быть произведено попыток сигнализацией заглушить двигатель подачей импульсов на кнопку Старт-Стоп
    */
    p_gen6->setParking(OFF, PIN);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("FAIL Шаг 3. ПН выполнена\n");
        return;
    }
    
    if (p_gen6->waitStartStopBtn(TIME_DELAY::TEN_S, 0))
    {
        printf("FAIL Шаг 3. Получен импульс старт-стоп\n");
        return;
    }
    
    /*!
        Нажать правильную комбинацию штатных кнопок
    */
    /*!
        Авторизация пройдена
        Внутренний Звукоизлучатель не включился 
        Сирена не включилась 
        Тревога не включилась
    */
    p_gen6->sendValidatorCode();
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 4. Система не находится в снято\n");
        return;
    }
    
    if (p_gen6->getAlarm())
    {
        printf("FAIL Шаг 4. Сирена включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 4. Тревога\n");
        return;
    }
}

// Авторизация при мягкой посадке по ручному тормозу
void AutoTestsModesP2::C1616164_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1616164) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Тип КПП: Автомобиль с ручной коробкой передач
        Система запуска двигателя: Старт-Стоп
        Вежливая посадка: Выключение ручного тормоза
        Требование авторизации при снятии брелоком: включено
        Авторизация владельца штатными кнопками: включена
        Охрана включена
        ПН выполнена
        Выполнен ДЗ
        Двигатель работает
        Ручник включен
    */
    p_gen6->setIgn(PIN, ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setEngine(ON, PIN, RPM_ON, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setHandBreak(ON, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setDoor(CLOSE, PIN, TIME_DELAY::STD_WIRE_STATUS_EN_TIME_S);
    p_gen6->setIgn(PIN, OFF);
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->getProgramNeutral())
    {
        printf("FAIL Начальные условия. ПН не выполнена\n");
        return;
    }
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны брелоком
    */
    /*!
        Автомобиль не в охране
        Переход в ожидание авторизации
    */    
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1. Система не находится в ожидании авторизации\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 2. Дверь закрыта\n");
        return;
    }
    
    /*!
        Выключить ручник
    */
    /*!
        ПН сброшена
        Не должно быть произведено попыток сигнализацией заглушить двигатель подачей импульсов на кнопку Старт-Стоп
    */
    p_gen6->setHandBreak(OFF, PIN);
    
    if (p_gen6->getProgramNeutral())
    {
        printf("FAIL Шаг 3. ПН выполнена\n");
        return;
    }
    
    if (p_gen6->waitStartStopBtn(TIME_DELAY::TEN_S, 0))
    {
        printf("FAIL Шаг 3. Получен импульс старт-стоп\n");
        return;
    }
    
    /*!
        Нажать правильную комбинацию штатных кнопок
    */
    /*!
        Авторизация пройдена
        Внутренний Звукоизлучатель не включился 
        Сирена не включилась 
        Тревога не включилась
    */
    p_gen6->sendValidatorCode();
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 4. Система не находится в снято\n");
        return;
    }
    
    if (p_gen6->getAlarm())
    {
        printf("FAIL Шаг 4. Сирена включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 4. Тревога\n");
        return;
    }
}

// Код экстренной разблокировки (из охраны) отключает антиограбление по метке
void AutoTestsModesP2::C1624514_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624514) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Антиограбление при пропадании метки: включено
        Охрана включена
        Метка включена
    */
    p_gen6->setAhjTagSetting(ON);
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
    */  
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    /*!
        Выключить метку       
    */
    /*!
        Метка потеряна
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->resetTagVcc();
    wait(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 3. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени Антиограбление по метке не включилось
    */
    p_gen6->setMoveSensor();
    
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 4. Антиограбление по метке включено\n");
        return;
    }
    
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелоком
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 6. Охрана включена\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 7. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени включилось Антиограбление по метке
    */
    p_gen6->setMoveSensor();
    
    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 8. Антиограбление по метке выключено\n");
        return;
    }
}

// Код экстренной разблокировки (из АО) отключает антиограбление по метке
void AutoTestsModesP2::C1624515_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624514) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Антиограбление при пропадании метки: включено
        Охрана выключена
        Система находится в Антиограблении по метке
        Метка выключена
    */
    p_gen6->setAhjTagSetting(ON);
    p_gen6->onAntiHijacking(TAG);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана включена\n");
        return;
    }
    
    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Антиограбление по метке выключено\n");
        return;
    }
   
    /*!
        Выключение Антиограбления кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
        Антиограбление выключено
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->emergencyDisarming();  
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Антиограбление по метке включено\n");
        return;
    }
    
    /*!
        Выключить метку       
    */
    /*!
        Метка потеряна
    */
    p_gen6->setIgn(PIN, ON);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    p_gen6->resetTagVcc();
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 3. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени Антиограбление по метке не включилось
    */
    p_gen6->setMoveSensor();
    
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 4. Антиограбление по метке включено\n");
        return;
    }
    
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Шаг 5. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелоком
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 6. Охрана включена\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 7. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени включилось Антиограбление по метке
    */
    p_gen6->setMoveSensor();
    
    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 8. Антиограбление по метке выключено\n");
        return;
    }
}

// Код экстренной разблокировки отключает запрет поездки по снятию
void AutoTestsModesP2::C1624516_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624516) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Снятие запрета поездки: Метка
        Условие активации запрета поездки: При снятии с охраны
        Охрана включена
        Метка выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
        Запрет поездки отключен
    */      
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
    
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Шаг 2. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелоком
    */
    /*!
        Охрана выключена
        Включен запрет поездки
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 3. Охрана включена\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 3. Система не находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
}

// Код экстренной разблокировки отключает запрет поездки по зажиганию
void AutoTestsModesP2::C1624517_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624517) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Снятие запрета поездки: Метка
        Условие активации запрета поездки: При каждом включении зажигания
        Охрана включена
        Метка выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
        Запрет поездки отключен
    */
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
    
    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */ 
    p_gen6->setIgn(PIN, ON);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 2. Зажигание выключено\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Запрет поездки не включился
    */   
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 3. Зажигание включено\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 3. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
    
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Шаг 4. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелоком
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 5. Охрана включена\n");
        return;
    }
    
    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */ 
    p_gen6->setIgn(PIN, ON);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 6. Зажигание выключено\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Включился Запрет поездки
    */
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 7. Зажигание включено\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 7. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
}

// Выключение охраны кодом с включенными требованиями авторизации
void AutoTestsModesP2::C1624518_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624518) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*! 
        Требовать авторизацию владельца меткой
        Требовать авторизацию владельца при снятии с охраны всеми способами
        Охрана включена
        Метка выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране        
    */
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
        После истечения времени на авторизацию тревога не включилась
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 2. Дверь закрыта\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::TWENTY_S,
                                 TIME_DELAY::ONE_S,
                                 false))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }
    
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Шаг 3. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключить охрану брелоком
    */
    /*!
        Охрана выключена
    */
    p_gen6->setSecure(OFF, KEYRING);
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 4. Охрана включена\n");
        return;
    }
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
        После истечения времени на авторизацию включилась тревога
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 5. Дверь закрыта\n");
        return;
    }

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE, 
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE, 
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TWENTY_S,
                                  TIME_DELAY::ONE_S,
                                  false))
    {
        printf("FAIL Шаг 5. Тревога выключена\n");
        return;
    }
}

// Включение АО командой после снятия с охраны кодом
void AutoTestsModesP2::C1624519_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c170782) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Охрана включена
    */
    p_gen6->setSecure(ON, KEYRING);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
    */  
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }    
    
    /*!
        Включить антиограбление по СМС      
    */
    /*!
        Включен режим антиограбления
    */    
    p_gen6->onAntiHijacking(SMS);
    
    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_CMD, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Антиограбление по команде не включено\n");
        return;
    }
}

// Вкл.-выкл. регистрации после снятия кодом не восстанавливает АО
void AutoTestsModesP2::C1624520_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624514) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Антиограбление при пропадании метки: включено
        Охрана включена
        Метка включена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
    */ 
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    /*!
        Включить режим регистрации       
    */
    /*!
        Режим регистрации включен
    */
    if (!p_gen6->registrationMode(ON))
    {
        printf("FAIL Шаг 2. Ошибка входа в режим регистрации\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 2. Режим регистрации выключен\n");
        return;
    }
    
    /*!
        Выключить режим регистрации       
    */
    /*!
        Режим регистрации выключен
    */
    if (!p_gen6->registrationMode(OFF))
    {
        printf("FAIL Шаг 3. Ошибка выхода из режима регистрации\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 3. Режим регистрации включен\n");
        return;
    }
    
    /*!
        Выключить метку       
    */
    /*!
        Метка потеряна
    */
    p_gen6->resetTagVcc();
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 5. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени Антиограбление по метке не включилось
    */    
    p_gen6->setMoveSensor();
    
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 6. Антиограбление по метке включено\n");
        return;
    }
}

// Вкл.-выкл. регистрации после снятия кодом не восстанавливает запрет поездки
void AutoTestsModesP2::C1624521_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624517) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Снятие запрета поездки: Метка
        Условие активации запрета поездки: При каждом включении зажигания
        Охрана включена
        Метка выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
        Запрет поездки отключен
    */
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
    
    /*!
        Включить режим регистрации       
    */
    /*!
        Режим регистрации включен
    */
    if (!p_gen6->registrationMode(ON))
    {
        printf("FAIL Шаг 2. Ошибка входа в режим регистрации\n");
        return;
    }
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 2. Режим регистрации выключен\n");
        return;
    }
    
    /*!
        Выключить режим регистрации       
    */
    /*!
        Режим регистрации выключен
    */
    if (!p_gen6->registrationMode(OFF))
    {
        printf("FAIL Шаг 3. Ошибка выхода из режима регистрации\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 3. Режим регистрации включен\n");
        return;
    }
    
    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */ 
    p_gen6->setIgn(PIN, ON);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 4. Зажигание выключено\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Запрет поездки не включился
    */
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 5. Зажигание включено\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 5. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
}

// Вкл.-выкл. сервиса после снятия кодом не восстанавливает АО
void AutoTestsModesP2::C1624522_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624514) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Антиограбление при пропадании метки: включено
        Охрана включена
        Метка включена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
    */ 
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    /*!
        Включить сервисный режим,       
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  ON,
                                  TIME_DELAY::TWO_S))
    {
        printf("FAIL Шаг 2. Сервисный режим выключен\n");
        return;
    }
    
    /*!
        Выключить сервисный режим       
    */
    /*!
        Сервисный режим выключен
    */
    p_gen6->setServiceModeTag(OFF);
    
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TWO_S))
    {
        printf("FAIL Шаг 3. Сервисный режим включен\n");
        return;
    }
    
    /*!
        Выключить метку       
    */
    /*!
        Метка потеряна
    */
    p_gen6->resetTagVcc();
    
    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    p_gen6->setDoor(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Шаг 5. Дверь закрыта\n");
        return;
    }
    
    /*!
        Вызвать срабатывание датчика движения
    */
    /*!
        После истечения отведенного времени Антиограбление по метке не включилось
    */    
    p_gen6->setMoveSensor();
    
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("FAIL Шаг 6. Антиограбление по метке включено\n");
        return;
    }
}

// Вкл.-выкл. сервиса после снятия кодом не восстанавливает запрет поездки
void AutoTestsModesP2::C1624523_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c1624517) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Снятие запрета поездки: Метка
        Условие активации запрета поездки: При каждом включении зажигания
        Охрана включена
        Метка выключена
    */
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->resetTagVcc();
    
    if (!p_gen6->checkSecure())
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Выключение охраны кодом экстренного снятия
    */
    /*!
        Автомобиль не в охране
        Запрет поездки отключен
    */
    p_gen6->emergencyDisarming();
    
    if (p_gen6->checkSecure())
    {
        printf("FAIL Шаг 1. Охрана включена\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
    
    /*!
        Включить сервисный режим       
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeTag(ON);
    
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  ON,
                                  TIME_DELAY::TWO_S))
    {
        printf("FAIL Шаг 2. Сервисный режим выключен\n");
        return;
    }
    
    /*!
        Выключить сервисный режим       
    */
    /*!
        Сервисный режим выключен
    */
    p_gen6->setServiceModeTag(OFF);
    
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TWO_S))
    {
        printf("FAIL Шаг 3. Сервисный режим включен\n");
        return;
    }
    
    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */ 
    p_gen6->setIgn(PIN, ON);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 4. Зажигание выключено\n");
        return;
    }
    
    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Запрет поездки не включился
    */
    p_gen6->setIgn(PIN, OFF);
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 5. Зажигание включено\n");
        return;
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 5. Система находится в соостоянии \"Запрет поездки\"\n");
        return;
    }
}

// Сработал ДД через 10 сек после включения охраны
void AutoTestsModesP2::C1691143_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Движения настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана не выключена\n");
    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 10 сек после постановки сработал Датчик Движения       
    */
    /*!
        Тревога отсутствует
    */
    p_gen6->setAccelerometerAfterDelay(MOVE, TIME_DELAY::FIVE_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");
}

// Сработал ДН через 10 сек после включения охраны
void AutoTestsModesP2::C1691144_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Наклона настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");
    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 10 сек после постановки сработал Датчик Наклона       
    */
    /*!
        Тревога отсутствует
    */ 
    p_gen6->setAccelerometerAfterDelay(TILT, TIME_DELAY::FIVE_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");
}

// Сработал ДУ предупредительный через 10 сек после включения охраны
void AutoTestsModesP2::C1691145_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Предупредительный настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");
    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 10 сек после постановки сработал Датчик Удара Предупредительный       
    */
    /*!
        Тревога отсутствует
    */   
    p_gen6->setAccelerometerAfterDelay(SHOCK_L, TIME_DELAY::FIVE_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");
}

// Сработал ДУ тревожный через 10 сек после включения охраны
void AutoTestsModesP2::C1691146_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Тревожный настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");

    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 10 сек после постановки сработал Датчик Удара Тревожный       
    */
    /*!
        Тревога отсутствует
    */
    p_gen6->setAccelerometerAfterDelay(SHOCK_H, TIME_DELAY::FIVE_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");
}

// Сработал ДД через 20 сек после включения охраны
void AutoTestsModesP2::C1691147_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Движения настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");

    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 20 сек после постановки сработал Датчик Движения       
    */
    /*!
        Включилась Тревога
    */
    p_gen6->setAccelerometerAfterDelay(MOVE, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");      
}

// Сработал ДН через 20 сек после включения охраны
void AutoTestsModesP2::C1691148_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Наклона настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");

    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 20 сек после постановки сработал Датчик Наклона       
    */
    /*!
        Включилась Тревога
    */
    p_gen6->setAccelerometerAfterDelay(TILT, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");   
}

// Сработал ДУ предупредительный через 20 сек после включения охраны
void AutoTestsModesP2::C1691149_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Предупредительный настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");

    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 20 сек после постановки сработал Датчик Удара Предупредительный       
    */
    /*!
        Включилась Тревога
    */   
    p_gen6->setAccelerometerAfterDelay(SHOCK_L, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_NOTICE,
                                  ON,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");
}

// Сработал ДУ тревожный через 20 сек после включения охраны
void AutoTestsModesP2::C1691150_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Тревожный настроен (включен)
        Охрана выключена
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");
    wait(TIME_DELAY::TWO_S);

    /*!
        Шаг 1. Постановка в охрану
    */
    /*!
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    /*!
        Шаг 2. Через 20 сек после постановки сработал Датчик Удара Тревожный       
    */
    /*!
        Включилась Тревога 
    */ 
    p_gen6->setAccelerometerAfterDelay(SHOCK_H, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");  
}

// Сработал ДД через 10 сек после закрывания багажника
void AutoTestsModesP2::C1691151_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Движения настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 
   
    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 10 сек после закрывания багажника сработал Датчик Движения       
    */
    /*!
        Тревога отсутствует 
    */
    p_gen6->setAccelerometerAfterDelay(MOVE, TIME_DELAY::FIVE_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");     
}

// Сработал ДН через 10 сек после закрывания багажника
void AutoTestsModesP2::C1691152_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Наклона настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 

    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
       Шаг 2. Через 10 сек после закрывания багажника сработал Датчик Наклона       
    */
    /*!
        Тревога отсутствует 
    */
    p_gen6->setAccelerometerAfterDelay(TILT, TIME_DELAY::FIVE_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");  
}

// Сработал ДУ предупредительный через 10 сек после закрывания багажника
void AutoTestsModesP2::C1691153_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Предупредительный настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 

    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 10 сек после закрывания багажника сработал Датчик Удара Предупредительный       
    */
    /*!
        Тревога отсутствует 
    */ 
    p_gen6->setAccelerometerAfterDelay(SHOCK_L, TIME_DELAY::TEN_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");    
}

// Сработал ДУ тревожный через 10 сек после закрывания багажника
void AutoTestsModesP2::C1691154_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Тревожный настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 

    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 10 сек после закрывания багажника сработал Датчик Удара Тревожный       
    */
    /*!
        Тревога отсутствует 
    */ 
    p_gen6->setAccelerometerAfterDelay(SHOCK_H, TIME_DELAY::TEN_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога не включена\n");  
}

// Сработал ДД через 20 сек после закрывания багажника
void AutoTestsModesP2::C1691155_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Движения настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 

    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 20 сек после закрывания багажника сработал Датчик Движения       
    */
    /*!
        Включилась тревога 
    */
    p_gen6->setAccelerometerAfterDelay(MOVE, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");   
}

// Сработал ДН через 20 сек после закрывания багажника
void AutoTestsModesP2::C1691156_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Наклона настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 
   
    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 20 сек после закрывания багажника сработал Датчик Наклона       
    */
    /*!
        Включилась тревога 
    */  
    p_gen6->setAccelerometerAfterDelay(TILT, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");    
}

// Сработал ДУ предупредительный через 20 сек после закрывания багажника
void AutoTestsModesP2::C1691157_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Предупредительный настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 
   
    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 20 сек после закрывания багажника сработал Датчик Удара Предупредительный       
    */
    /*!
        Включилась тревога 
    */   
    p_gen6->setAccelerometerAfterDelay(SHOCK_L, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_NOTICE,
                                  ON,
                                  TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");
}

// Сработал ДУ тревожный через 20 сек после закрывания багажника
void AutoTestsModesP2::C1691158_TestCase()
{   
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Датчик Удара Тревожный настроен (включен)
        Включена Охрана с открытым багажником
        Багажник открыт
        Тревога отключена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->unlockTrunk(KEYRING, TIME_DELAY::MAX_WIRE_EN_DELAY_S);

    if (!p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("FAIL Начальные условия. Багажник не открыт\n");
        return;        
    }

    printf("PASS Начальные условия. Багажник открыт\n");

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Начальные условия. Тревога включена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога не включена\n"); 
   
    /*!
        Шаг 1. Закрыть багажник
    */
    /*!
        Багажник закрыт
        Охрана включена
    */
    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;        
    }

    printf("PASS Шаг 1. Багажник не закрыт\n");

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return; 
    }

    printf("PASS Шаг 1. Охрана включена\n"); 

    /*!
        Шаг 2. Через 20 сек после закрывания багажника сработал Датчик Удара Тревожный       
    */
    /*!
        Включилась тревога  
    */ 
    p_gen6->setAccelerometerAfterDelay(SHOCK_H, TIME_DELAY::FIFTEEN_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ALARM_EN_TIME_S))
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 2. Тревога включена\n");  
}

// 26. Выключение охраны с открытой дверью
void AutoTestsModesP2::C1827097_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1827097) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь открыта
        Включена Охрана с нарушенным периметром
        Перепостановка в охрану включена
        Время до перепостановки 30 сек
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_DOORS))
    {
        printf("FAIL Ошибка при открытии дверей (начальные условия)\n");
    }

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Ошибка при постановке в охрану (начальные условия)\n");
    }
   
    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Через 30 сек после снятия: перепостановка НЕ произошла
    */ 
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Ошибка при выключении охраны\n");
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               false,
                               TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 1. Система не находится в \"Снято\" по истечении ожидаемого времени \n");
    }

    settings_check(p_c1624518); 
}

// 27. Выключение охраны с открытым багажником
void AutoTestsModesP2::C1827098_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1827097) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Багажник открыт
        Включена Охрана с нарушенным периметром
        Перепостановка в охрану включена
        Время до перепостановки 30 сек
    */
    p_gen6->setTrunk(OPEN, PIN); 

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Ошибка при открытии багажника (начальные условия)\n");
    }

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Ошибка при постановке в охрану (начальные условия)\n");
    }
   
    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Через 30 сек после снятия: перепостановка НЕ произошла
    */ 
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Ошибка при выключении охраны\n");
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               false,
                               TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 1. Система не находится в \"Снято\" по истечении ожидаемого времени \n");
    }

    settings_check(p_c1624518);  
}

// 28. Выключение охраны с открытым капотом
void AutoTestsModesP2::C1827099_TestCase()
{       
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1827097) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Капот открыт
        Включена Охрана с нарушенным периметром
        Перепостановка в охрану включена
        Время до перепостановки 30 сек
    */
    p_gen6->setHood(OPEN, PIN);
    
    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD))
    {
        printf("FAIL Ошибка при открытии капота (начальные условия)\n");
    }

    p_gen6->setSecure(ON, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Ошибка при постановке в охрану (начальные условия)\n");
    }
   
    /*!
        Выключить охрану
    */
    /*!
        Охрана выключена
        Через 30 сек после снятия: перепостановка НЕ произошла
    */  
    p_gen6->setSecure(OFF, KEYRING);

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1. Ошибка при выключении охраны\n");
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               false,
                               TIME_DELAY::THIRTY_FIVE_S))
    {
        printf("FAIL Шаг 1. Система не находится в \"Снято\" по истечении ожидаемого времени \n");
    } 

    settings_check(p_c1624518); 
}

// 1. Переход в охрану с открытой дверью с включенной настройкой
void AutoTestsModesP2::C1950492_TestCase()
{
    /*!
        Начальные условия
    */
    /*!        
        Дверь открыта
        Охрана Выключена 
        Учет задержки выключения салонного света: ВКл
    */
   
    /*!
        Включить охрану
    */
    /*!
        Охрана включена
        Через 10 сек после постановки: тревога по открытой двери
    */   
}

// 2. Переход в охрану с закрыванием двери с включенной настройкой
void AutoTestsModesP2::C1950493_TestCase()
{   
    /*!
        Начальные условия
    */
    /*!        
        Дверь открыта
        Охрана Выключена 
        Учет задержки выключения салонного света: ВКл
    */
   
    /*!
        Включить охрану
    */
    /*!
        Охрана включена        
    */
    /*!
        Через 5 сек после включения охраны закрыть дверь
    */
    /*!
        Дверь закрыта
        Через 10 сек после постановки в охрану (5 сек после закрытия двери): тревога НЕ включилась
    */
}

// 3. Переход в охрану с закрытой дверью с включенной настройкой
void AutoTestsModesP2::C1950494_TestCase()
{   
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Охрана Выключена 
        Учет задержки выключения салонного света: ВКл
    */
   
    /*!
        Включить охрану
    */
    /*!
        Охрана включена 
        Через 10 сек после постановки в охрану: тревога НЕ включилась       
    */
}

// Открыть багажник с объединением двери и багажника
void AutoTestsModesP2::C1981106_TestCase()
{
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    }   

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт 
        Дверь открыта       
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть багажник без объединения двери и багажника
void AutoTestsModesP2::C1981107_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    }    

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт    
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != DIAG_PERIM_BIT_TRUNK)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть дверь с объединением двери и багажника
void AutoTestsModesP2::C1981108_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Багажник открыт
        Дверь открыта      
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть дверь без объединения двери и багажника
void AutoTestsModesP2::C1981109_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");

   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта      
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != DIAG_PERIM_BIT_DOORS)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть капот с объединением двери и багажника
void AutoTestsModesP2::C1981110_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Капот открыт      
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != DIAG_PERIM_BIT_HOOD)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть капот без объединения двери и багажника
void AutoTestsModesP2::C1981111_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Капот открыт      
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != DIAG_PERIM_BIT_HOOD)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть багажник с объединением капота и багажника
void AutoTestsModesP2::C1981112_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    }   

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть Багажник
    */
    /*!
        Капот открыт
        Багажник открыт
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть дверь с объединением капота и багажника
void AutoTestsModesP2::C1981113_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != DIAG_PERIM_BIT_DOORS)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть капот с объединением капота и багажника
void AutoTestsModesP2::C1981114_TestCase()
{  
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    } 
 
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Капот открыт
        Багажник открыт
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть багажник с объединением двери, капота и багажника
void AutoTestsModesP2::C1981115_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981115) == 0)
    {
        return;
    }   

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Капот открыт
        Багажник открыт
        Дверь открыта
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (  DIAG_PERIM_BIT_DOORS
                                                   | DIAG_PERIM_BIT_TRUNK
                                                   | DIAG_PERIM_BIT_HOOD))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть дверь с объединением двери, капота и багажника
void AutoTestsModesP2::C1981116_TestCase()
{
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981115) == 0)
    {
        return;
    } 
   
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!        
        Багажник открыт
        Дверь открыта
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть капот с объединением двери, капота и багажника
void AutoTestsModesP2::C1981117_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981115) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Выключена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
    */
    if (!setSecureZoneClosed(OFF, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Капот открыт
        Багажник открыт
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");
}

// Открыть дверь без объединения двери и багажника
void AutoTestsModesP2::C1981118_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включилась тревога
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != DIAG_PERIM_BIT_DOORS)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть дверь с объединением двери и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981119_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть дверь с объединением двери и багажника с командой с брелока (2,2)
void AutoTestsModesP2::C1981120_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Подать команду брелоком на открытие багажника двукратным нажатием кнопки "2" и Открыть дверь 
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    p_gen6->unlockTrunk(KEYRING,
                        TIME_DELAY::ONE_AND_HALF_S,
                        REPEAT_MODE_ON);

    if (setAndCheckMergeZone(DOOR_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть дверь с объединением двери и багажника с командой с активной меткой/брелоком
void AutoTestsModesP2::C1981121_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981121) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Да
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Открыть дверь 
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    if (setAndCheckMergeZone(DOOR_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть капот без объединения двери и багажника
void AutoTestsModesP2::C1981122_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть капот
    */
    /*!
        Капот открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != DIAG_PERIM_BIT_HOOD)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть капот с объединением капота и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981123_TestCase()
{  
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    } 
 
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть капот
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть капот с объединением капота и багажника с командой с брелока (2,2)
void AutoTestsModesP2::C1981124_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Шаг 1. Подать команду брелоком на открытие багажника двукратным нажатием кнопки "2" и Открыть капот 
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    p_gen6->unlockTrunk(KEYRING,
                        TIME_DELAY::ONE_AND_HALF_S,
                        REPEAT_MODE_ON);

    if (setAndCheckMergeZone(HOOD_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть капот с объединением капота и багажника с командой с активной меткой/брелоком
void AutoTestsModesP2::C1981125_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981125) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Да
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть капот 
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    if (setAndCheckMergeZone(HOOD_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник без объединения двери и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981126_TestCase()
{  
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981107) == 0)
    {
        return;
    } 
 
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != DIAG_PERIM_BIT_TRUNK)
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Открыть багажник с объединением двери и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981127_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с объединением двери и багажника с командой с брелока (2,2)
void AutoTestsModesP2::C1981128_TestCase()
{  
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981106) == 0)
    {
        return;
    } 
 
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Подать команду брелоком на открытие багажника двукратным нажатием кнопки "2" и Открыть багажник 
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    p_gen6->unlockTrunk(KEYRING,
                        TIME_DELAY::ONE_AND_HALF_S,
                        REPEAT_MODE_ON);

    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник с объединением двери и багажника с командой с активной меткой/брелоком
void AutoTestsModesP2::C1981129_TestCase()
{
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981121) == 0)
    {
        return;
    } 
   
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Нет
        Разрешить в охране открытие багажника при наличии метки или брелока: Да
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Дверь открыта
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_DOORS | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник с объединением капота и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981131_TestCase()
{  
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    }  

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с объединением капота и багажника с командой с брелока (2,2)
void AutoTestsModesP2::C1981132_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981112) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Подать команду брелоком на открытие багажника двукратным нажатием кнопки "2" и Открыть багажник 
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    p_gen6->unlockTrunk(KEYRING,
                        TIME_DELAY::ONE_AND_HALF_S,
                        REPEAT_MODE_ON);

    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник с объединением капота и багажника с командой с активной меткой/брелоком
void AutoTestsModesP2::C1981133_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981125) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Нет
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Да
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (DIAG_PERIM_BIT_HOOD | DIAG_PERIM_BIT_TRUNK))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник с объединением капота, двери и багажника без команды, метки и брелока
void AutoTestsModesP2::C1981134_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981115) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник
    */
    /*!
        Дверь открыта
        Капот открыт
        Багажник открыт
        Включилась тревога
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (  DIAG_PERIM_BIT_DOORS 
                                                 | DIAG_PERIM_BIT_TRUNK 
                                                 | DIAG_PERIM_BIT_HOOD))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с объединением капота, двери и багажника с командой с брелока (2,2)
void AutoTestsModesP2::C1981135_TestCase()
{ 
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981115) == 0)
    {
        return;
    } 
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Нет
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Подать команду брелоком на открытие багажника двукратным нажатием кнопки "2" и Открыть багажник 
    */
    /*!
        Дверь открыта
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    p_gen6->unlockTrunk(KEYRING,
                        TIME_DELAY::ONE_AND_HALF_S,
                        REPEAT_MODE_ON);

    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (  DIAG_PERIM_BIT_DOORS 
                                                 | DIAG_PERIM_BIT_TRUNK 
                                                 | DIAG_PERIM_BIT_HOOD))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть багажник с объединением капота, двери и багажника с командой с активной меткой/брелоком
void AutoTestsModesP2::C1981136_TestCase()
{   
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_M96)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1981136) == 0)
    {
        return;
    } 

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт
        Капот закрыт
        Охрана Включена 
        Объединение каналов дверей, багажника и капота: Объединение дверей с багажником: Да
        Объединение каналов дверей, багажника и капота: Объединение капота с багажником: Да
        Разрешить в охране открытие багажника при наличии метки или брелока: Да
        Брелок включен
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия не выполнены\n");
        return;
    }

    printf("PASS Начальные условия выполнены\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Дверь открыта
        Капот открыт
        Багажник открыт
        Включилась охрана с открытым багажником
    */
    if (setAndCheckMergeZone(TRUNK_IN, OPEN) != (  DIAG_PERIM_BIT_DOORS 
                                                 | DIAG_PERIM_BIT_TRUNK 
                                                 | DIAG_PERIM_BIT_HOOD))
    {
        printf("FAIL Шаг 1. Состояние зон охраны не соответствует ожидаемому\n");
        return;
    }

    printf("PASS Шаг 1. Состояние зон охраны соответствует ожидаемому\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ARM_TRUNK,
                                  ON,
                                  TIME_DELAY::WAITING_AUTH_BY_TRUNK_S))
    {
        printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
}

// Открыть дверь с включенным Slave-CAN
void AutoTestsModesP2::C2043655_TestCase()
{
    if (settings_check(p_c2043655) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN включен
        Аналоговый Slave выключен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть дверь 
    */
    /*!
        Дверь открыта
        Через 3 сек. включилась тревога по двери
    */
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::TWO_AND_HALF_S))
    {
        printf("FAIL Шаг 1. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога не включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");    
}

// Открыть багажник с включенным Slave-CAN
void AutoTestsModesP2::C2043656_TestCase()
{
    if (settings_check(p_c2043655) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN включен
        Аналоговый Slave выключен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Багажник открыт
        Через 3 сек. включилась тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TWO_AND_HALF_S))
    {
        printf("FAIL Шаг 1. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога не включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");  
}

// Открыть дверь с отключенным Slave
void AutoTestsModesP2::C2043657_TestCase()
{
    if (settings_check(p_c2043657) == 0)
    {
        return;
    }
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave выключен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть дверь 
    */
    /*!
        Дверь открыта
        Сразу включилась тревога по двери
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с отключенным Slave
void AutoTestsModesP2::C2043658_TestCase()
{
    if (settings_check(p_c2043657) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave выключен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Багажник открыт
        Сразу включилась тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть дверь с включенным аналоговым Slave с выключенной задержкой
void AutoTestsModesP2::C2043659_TestCase()
{
    if (settings_check(p_c2043659) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть дверь 
    */
    /*!
        Дверь открыта
        Сразу включилась тревога по двери
    */
    p_gen6->setDoor(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с включенным аналоговым Slave с выключенной задержкой
void AutoTestsModesP2::C2043660_TestCase()
{   
    if (settings_check(p_c2043659) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды выключена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Багажник открыт
        Сразу включилась тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть дверь с включенным аналоговым Slave с включенной задержкой
void AutoTestsModesP2::C2043661_TestCase()
{ 
    if (settings_check(p_c2043661) == 0)
    {
        return;
    }
  
    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды включена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть дверь 
    */
    /*!
        Дверь открыта
        Через 3 сек. включилась тревога по двери
    */
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TWO_AND_HALF_S))
    {
        printf("FAIL Шаг 1. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога не включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Открыть багажник с включенным аналоговым Slave с включенной задержкой
void AutoTestsModesP2::C2043662_TestCase()
{   
    if (settings_check(p_c2043661) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды включена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть багажник 
    */
    /*!
        Багажник открыт
        Через 3 сек. включилась тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TWO_AND_HALF_S))
    {
        printf("FAIL Шаг 1. Тревога включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога не включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::ONE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Сработала предупредительная тревога во время задержки после открытия двери
void AutoTestsModesP2::C2043663_TestCase()
{   
    if (settings_check(p_c2043661) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды включена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть дверь
        Сразу же не позднее чем через 3 сек. вызвать срабатывание предупредительной тревоги
    */
    /*!
        Дверь открыта
        Сработала предупредительная тревога
        Через 3 сек. включилась основная тревога по двери
    */
    wait(TIME_DELAY::FIFTEEN_S);
    p_gen6->setDoor(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setAccelerometerAfterDelay(SHOCK_L);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_NOTICE,
                                  ON,
                                  TIME_DELAY::TWO_S))
    {
        printf("FAIL Шаг 1. Предупредительная тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Предупредительная тревога включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::THREE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// Сработала предупредительная тревога во время задержки после открытия багажника
void AutoTestsModesP2::C2043664_TestCase()
{   
    if (settings_check(p_c2043661) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Дверь закрыта
        Багажник закрыт        
        Охрана Включена 
        Slave по CAN выключен
        Аналоговый Slave включен
        Задержка тревоги при открытии двери/багажника 3 секунды включена
    */
    if (!p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Дверь не закрыта.\n");
        return;
    }

    printf("PASS Начальные условия. Дверь закрыта.\n");

    if (!p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("FAIL Начальные условия. Багажник не закрыт.\n");
        return;
    }

    printf("PASS Начальные условия. Багажник закрыт.\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена.\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена.\n");
   
    /*!
        Открыть багажник
        Сразу же не позднее чем через 3 сек. вызвать срабатывание предупредительной тревоги
    */
    /*!
        Багажник открыт
        Сработала предупредительная тревога
        Через 3 сек. включилась основная тревога по двери
    */
    wait(TIME_DELAY::FIFTEEN_S);
    p_gen6->setTrunk(OPEN, PIN, TIME_DELAY::NULL_DELAY_S);
    p_gen6->setAccelerometerAfterDelay(SHOCK_L);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_NOTICE,
                                  ON,
                                  TIME_DELAY::THREE_S))
    {
        printf("FAIL Шаг 1. Предупредительная тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Предупредительная тревога включена\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::THREE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n"); 
}

// 1. Антиограбление по брелоку с зажиганием и скоростью, и выключение брелоком после понижения скорости
void AutoTestsModesP2::C2198656_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               CAN_USE,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне видимости
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 5\n");
    }
}

// 2. Антиограбление по брелоку с зажиганием и без скорости, и выключение брелоком
void AutoTestsModesP2::C2198657_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
        Включена блокировка
    */
    if (!setAhjTestsStepThree(CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне видимости
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 4\n");
    }
}

// 3. Антиограбление по брелоку без зажигания и без скорости, и выключение брелоком
void AutoTestsModesP2::C2198658_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
        return;
    }

    p_gen6->checkAlarm(OFF, m_ahj_step_four_time_s + TIME_DELAY::STD_ALARM_SIGNAL_TIME_S);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG))
    {
        printf("PASS Антиограбление по метке не включено \n");
    }
    else
    {
        printf("FAIL Антиограбление по метке включено \n");
        return;
    }
}

// 4. Антиограбление по брелоку без зажигания и без скорости, и выключение брелоком через 30 сек
void AutoTestsModesP2::C2198659_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
        return;
    }

    p_gen6->checkAlarm(OFF, m_ahj_step_four_time_s + TIME_DELAY::STD_ALARM_SIGNAL_TIME_S);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG))
    {
        printf("PASS Антиограбление по метке не включено \n");
    }
    else
    {
        printf("FAIL Антиограбление по метке включено \n");
        return;
    }
}

// 5. Антиограбление по брелоку с зажиганием и скоростью, и выключение брелоком с выключением зажигания в течение 30 сек
void AutoTestsModesP2::C2198660_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }

    /*!
        Выключить зажигание
    */
    /*!
        зажигание выключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 5. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не выключено\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне видимости
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 6\n");
    }
}

// 6. Антиограбление по брелоку с зажиганием и скоростью, и выключение брелоком через 30 сек
void AutoTestsModesP2::C2198661_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }

    /*!
        Включить брелок в течении 30 сек
    */
    /*!
        брелок появился в зоне видимости
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 5\n");
    }
}

// 7. Антиограбление по брелоку с зажиганием и скоростью, и выключение кодом после понижения скорости
void AutoTestsModesP2::C2198662_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }


    /*!
        Ввести код экстренного снятия с охраны
    */
    /*!
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->offAntiHijacking();

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 5\n");
    }
}

// 8. Антиограбление по брелоку с зажиганием и без скорости, и выключение кодом
void AutoTestsModesP2::C2198663_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
        Включена блокировка
    */
    if (!setAhjTestsStepThree(CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Ввести код экстренного снятия с охраны
    */
    /*!
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->offAntiHijacking();

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 4\n");
    }
}

// 9. Антиограбление по брелоку без зажигания и без скорости, и выключение кодом
void AutoTestsModesP2::C2198664_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
        return;
    }

    p_gen6->checkAlarm(OFF, m_ahj_step_four_time_s + TIME_DELAY::STD_ALARM_SIGNAL_TIME_S);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG))
    {
        printf("PASS Антиограбление по метке не включено \n");
    }
    else
    {
        printf("FAIL Антиограбление по метке включено \n");
        return;
    }
}

// 10. Антиограбление по брелоку без зажигания и без скорости, и выключение кодом через 30 сек
void AutoTestsModesP2::C2198665_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
        return;
    }

    p_gen6->checkAlarm(OFF, m_ahj_step_four_time_s + TIME_DELAY::STD_ALARM_SIGNAL_TIME_S);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG))
    {
        printf("PASS Антиограбление по метке не включено \n");
    }
    else
    {
        printf("FAIL Антиограбление по метке включено \n");
        return;
    }

}

// 11. Антиограбление по брелоку с зажиганием и скоростью, и выключение кодом с выключением зажигания в течение 30 сек
void AutoTestsModesP2::C2198666_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 5
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }

    /*!
        Выключить зажигание
    */
    /*!
        зажигание выключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 5. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не выключено\n");
        return;
    }

    /*!
        Ввести код экстренного снятия с охраны через 30 сек
    */
    /*!
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->offAntiHijacking();

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 6\n");
    }
}

// 12. Антиограбление по брелоку с зажиганием и скоростью, и выключение кодом через 30 сек
void AutoTestsModesP2::C2198667_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Снизить скорость менее 30 км/ч
    */
    /*!
        Включена блокировка
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitBlock(TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 4. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включена\n");
        return;
    }

    /*!
        Ввести код экстренного снятия с охраны через 30 сек
    */
    /*!
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    wait(TIME_DELAY::THIRTY_S);
    p_gen6->setIgn(PIN, OFF);
    p_gen6->offAntiHijacking();

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 5\n");
    }
}

// 13. Антиограбление по брелоку с зажиганием и скоростью, и выключение брелоком без понижения скорости
void AutoTestsModesP2::C2198668_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне видимости
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 4\n");
    }
}

// 14. Антиограбление по брелоку с зажиганием и скоростью, и выключение кодом без понижения скорости
void AutoTestsModesP2::C2198669_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 40 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON,
                               PIN,
                               40);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелоку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Ввести код экстренного снятия
    */
    /*!
        выключен режим "Антиограбление по брелоку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->offAntiHijacking();

    if (!checkAhjTestsStepLast())
    {
        printf("FAIL Шаг 4\n");
    }
}

// 15. Антиограбление по брелоку без заж. и без скор. с включением зажигания(нарушена зона охраны) без скорости через 30 сек
void AutoTestsModesP2::C2198670_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
    }
}

// 16. Антиограбление по брелоку без заж. и без скор. с включением через 30 сек зажигания со скоростью
void AutoTestsModesP2::C2198671_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание выключено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_OFF);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        режим "Антиограбление по метке" не включен
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение сиреной
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(  m_ahj_steps_one_and_two_time_s
                                   + m_ahj_step_three_time_s
                                   + TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Предупредительные сигналы не получены\n");
    }
    else
    {
        printf("FAIL Предупредительные сигналы получены\n");
    }
}

// 17. Сработал ДД с закрытой дверью
void AutoTestsModesP2::C2198672_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включение режима "Антиограбление по брелоку" не произошло
    */
    p_gen6->setMoveSensor();

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 2. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 2. Антиограбление по брелку не включено \n");
    }

}

// 18. Сработал ДД с открытой и закрытой дверью до этого
void AutoTestsModesP2::C2198673_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    /*!
        Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 2. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не закрыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включение режима "Антиограбление по брелоку" не произошло
    */
    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 3. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 3. Антиограбление по брелку не включено \n");
    }
}

// 19. Исчезновение брелока без дальнейших последствий
void AutoTestsModesP2::C2198674_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
        через 15 сек Включение режима "Антиограбление по брелоку" не произошло
    */
    p_gen6->setLcdKeyringVcc(OFF);
    p_gen6->setMoveSensor();

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 1. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 1. Антиограбление по брелку не включено \n");
    }
}

// 20. Появление брелока до начала поиска брелока
void AutoTestsModesP2::C2198675_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        Отсчет времени до поиска брелока
    */
    p_gen6->setMoveSensor();

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне действия
        Включение режима "Антиограбление по брелоку" не произошло
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 4. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 4. Антиограбление по брелку не включено \n");
    }
}

// 21. Появление брелока во время поиска брелока
void AutoTestsModesP2::C2198676_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        Отсчет времени до поиска брелока
    */
    p_gen6->setMoveSensor();

    /*!
        Включить брелок не позднее чем через 5 сек
    */
    /*!
        брелок появился в зоне действия
        Включение режима "Антиограбление по брелоку" не произошло
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 4. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 4. Антиограбление по брелку не включено \n");
    }
}

// 22. Появление брелока во время работы внутреннего звукоизлучателя
void AutoTestsModesP2::C2198677_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелку"
        включен внутренний звукоизлучатель
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, NO_CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне действия
        выключен внутренний звукоизлучатель
        выключен режим "Антиограбление по брелку"
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        if (p_gen6->waitBuzzerExt(ON, TIME_DELAY::FIVE_S))
        {
            printf("FAIL Шаг 4. Предупредительные сигналы бузером получены\n");
            return;
        }

        printf("PASS Шаг 4. Предупредительные сигналы не получены\n");
    }

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 4. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 4. Антиограбление по брелку не включено \n");
    }
}

// 23. Появление брелока во время работы сирены
void AutoTestsModesP2::C2198678_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        Включен режим "Антиограбление по брелку"
        включен внутренний звукоизлучатель
        через 5 сек:
        выключен внутренний звукоизлучатель
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек:
        выключено предупреждение сиреной
        выключено предупреждение световыми сигналами
        включена тревога (звуковые и световые сигналы)
        включена блокировка
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Включить брелок
    */
    /*!
        брелок появился в зоне действия
        выключен режим "Антиограбление по брелку"
        выключена тревога (звуковые и световые сигналы)
        выключена блокировка
        выключена охрана
    */
    p_gen6->setLcdKeyringVcc(ON, TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 4. Антиограбление по брелку включено \n");
        return;
    }
    else
    {
        printf("PASS Шаг 4. Антиограбление по брелку не включено \n");
    }
}

// 24. Антиограбление по брелоку с зажиганием с выключенным звукоизлучателем
void AutoTestsModesP2::C2198679_TestCase()
{
    if (    (p_gen6->getModules() & R868_MODULE) != R868_MODULE
         ||  p_gen6->getDeviceName()              == GEN6_X96V2) // Для теста требуется система без внутреннего звукоизлучателя
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        ||  settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание выключено
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 5
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 1
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
        в системе отсутствует внутренний звукоизвещатель
        выход внешнего звукоизвещателя не настроен
    */
    setAhjTestsStartConditions(IGN_ON);

    /*!
        Выключить брелок
    */
    /*!
        брелок пропал из зоны действия
    */
    p_gen6->setLcdKeyringVcc(OFF);

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 10 сек (шаг1+шаг2):
        включено предупреждение сиреной
        включено предупреждение световыми сигналами
        через 5 сек (шаг4):
        включена тревога (звуковые и световые сигналы)
        режим "Антиограбление по брелоку" включен
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitLightAndAlarm(m_ahj_steps_one_and_two_time_s - TIME_DELAY::STD_ERROR_TIME_S))
    {
        printf("PASS Шаг 3. Предупредительные сигналы не получены раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 3. Предупредительные сигналы получены раньше времени\n");
        return;
    }

    if (p_gen6->waitLightAndAlarm(TIME_DELAY::STD_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
    {
        printf("PASS Шаг 3. Предупредительные сигналы получены\n");
    }
    else
    {
        printf("FAIL Шаг 3. Предупредительные сигналы не получены\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                ON,
                                m_ahj_step_four_time_s - TIME_DELAY::STD_ERROR_TIME_S)) // Также вычитается время, потраченное на проверку АО
    {
        printf("PASS Шаг 3. Тревога не включилась раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 3. Тревога включилась раньше времени\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::STD_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
    {
        printf("PASS Шаг 3. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Тревога не включена\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ANTI_HIJACK,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Режим \"Антиограбление по брелоку\" включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Режим \"Антиограбление по брелоку\" не включен\n");
    }
}

// 25. Антиогр. не включилось из-за отключеной настройки
void AutoTestsModesP2::C2198680_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198680)
        || settings_check(p_c2198680) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: нет
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по брелоку
    */
    /*!
        режим "Антиограбление по брелоку" не включился
    */
    p_gen6->onAntiHijacking(KEYRING);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 1. Антиограбление по брелку включено\n");
        return;
    }

    printf("PASS Шаг 1. Антиограбление по брелку не включено\n");
}

// 26. Повторное вкл. антиогр. после отключения антиогр. кодом экстр. снятия
void AutoTestsModesP2::C2198681_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        капот закрыт
        багажник закрыт
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска брелока, сек: 10
        Антиограбление, шаг 2: Время поиска брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по брелоку
    */
    /*!
        Режим антиограбления по брелоку включился
    */
    p_gen6->onAntiHijacking(KEYRING);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 1. Антиограбление по брелку не включено\n");
        return;
    }

    printf("PASS Шаг 1. Антиограбление по брелку включено\n");

    /*!
        Выключить режим Антиограбления по брелоку с помощью кода экстренного снятия
    */
    /*!
        Переход в Снято (Режим антиограбления по брелоку выключился)
    */
    p_gen6->setIgn(PIN, OFF);
    p_gen6->offAntiHijacking();

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 2. Антиограбление по брелку выключено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Антиограбление по брелку включено\n");
        return;
    }

    /*!
        Перейти в режим Антиограбления по брелоку
    */
    /*!
        Режим антиограбления по брелоку НЕ включился
    */
    p_gen6->onAntiHijacking(KEYRING);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("FAIL Шаг 3. Антиограбление по брелку включено\n");
        return;
    }

    printf("PASS Шаг 3. Антиограбление по брелку не включено\n");
}

// Антиограбление по метке с отключенной настройкой и включенным антиограблением по брелоку
void AutoTestsModesP2::C2198682_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198656)
        || settings_check(p_c2198656) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании метки: нет
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска метки или брелока, сек: 10
        Антиограбление, шаг 2: Время поиска метки или брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    p_gen6->setTagVcc();
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по метке
    */
    /*!
        Режим антиограбления по метке не включился
        Режим антиограбления по брелоку не включился
    */
    p_gen6->onAntiHijacking(TAG);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("PASS Шаг 1. Антиограбление не включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление включено\n");
    }
}

// Антиограбление по метке с включенным антиограблением по брелоку
void AutoTestsModesP2::C2198683_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198685)
        || settings_check(p_c2198685) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании метки: да
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска метки или брелока, сек: 10
        Антиограбление, шаг 2: Время поиска метки или брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    p_gen6->setTagVcc();
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по метке
    */
    /*!
        Режим антиограбления по метке включился
        Режим антиограбления по брелоку не включился
    */
    p_gen6->onAntiHijacking(TAG);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("PASS Шаг 1. Антиограбление по метке включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление по метке не включено\n");
    }
}

// Антиограбление по брелоку с отключенной настройкой и включенным антиограблением по метке
void AutoTestsModesP2::C2198684_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198684)
        || settings_check(p_c2198684) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании метки: да
        Антиограбление при пропадании брелока: нет
        Антиограбление, шаг 1: Время до начала поиска метки или брелока, сек: 10
        Антиограбление, шаг 2: Время поиска метки или брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    p_gen6->setTagVcc();
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по брелоку
    */
    /*!
        Режим антиограбления по метке не включился
        Режим антиограбления по брелоку не включился
    */
    p_gen6->onAntiHijacking(KEYRING);

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("PASS Шаг 1. Антиограбление не включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление включено\n");
    }
}

// Антиограбление по брелоку с включенным антиограблением по метке
void AutoTestsModesP2::C2198685_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE)!= R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2198685)
        || settings_check(p_c2198685) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        дверь закрыта
        зажигание включено
        ручник выключен
        охрана выключена
        скорость: 0 км/ч
        брелок включен
        Антиограбление при пропадании метки: да
        Антиограбление при пропадании брелока: да
        Антиограбление, шаг 1: Время до начала поиска метки или брелока, сек: 10
        Антиограбление, шаг 2: Время поиска метки или брелока, сек: 5
        Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: 5
        Антиограбление, шаг 4: Предупреждение сиреной, сек: 5
    */
    p_gen6->setTagVcc();
    setAhjTestsStartConditions(IGN_ON, PIN);

    /*!
        Перейти в режим Антиограбления по брелоку
    */
    /*!
        Режим антиограбления по метке не включился
        Режим антиограбления по брелоку включился
    */
    p_gen6->onAntiHijacking(KEYRING);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_TAG, m_ahj_wait_time_s))
    {
        printf("PASS Шаг 1. Антиограбление по брелку включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление по брелку не включено\n");
    }
}

// Блокировка по CAN при тревоге по двери отсутствует
void AutoTestsModesP2::C172480_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    p_can1_act->waitWakeUp(TIME_DELAY::FIVE_S);

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    p_gen6->setDoor(OPEN, CAN_USE);

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Блокировка по CAN при тревоге по капоту отсутствует
void AutoTestsModesP2::C172481_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    p_gen6->setHood(OPEN, CAN_USE);

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Блокировка по CAN при тревоге по багажнику отсутствует
void AutoTestsModesP2::C172482_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    p_gen6->setTrunk(OPEN, CAN_USE);

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// 4. Блокировка по CAN при тревоге по зажиганию присутствует
void AutoTestsModesP2::C172483_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Завести двигатель
    */
    /*!
        Есть пакеты блокировки по CAN
        Тревога включена
    */
    p_gen6->setIgn(CAN_USE, ON);

    p_gen6->setAndCheckEngine(ON, CAN_USE);

    if (!p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}


// Блокировка по CAN при тревоге по датчику движения отсутствует
void AutoTestsModesP2::C172484_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Настройка: Блокировка по CAN включена
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитация срабатывания датчика движения
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);

    p_gen6->setMoveSensor();

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Блокировка по CAN при тревоге по датчику наклона отсутствует
void AutoTestsModesP2::C172485_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Настройка: Блокировка по CAN включена
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитация срабатывания датчика наклона
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);

    p_gen6->setTiltSensor();

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Блокировка по CAN при тревоге по датчику удара отсутствует
void AutoTestsModesP2::C172486_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Настройка: Блокировка по CAN включена
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитация срабатывания датчика удара
    */
    /*!
        Нет пакетов блокировки по CAN
        Тревога включена
    */
    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);

    p_gen6->setShockSensorHigh();

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");
}

// Блокировка по CAN при прерывании тревоги по двери отсутствует
void AutoTestsModesP2::C172487_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Дверь открыта
        Автомобиль в тревоге по двери
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->setDoor(OPEN,
                    CAN_USE,
                    TIME_DELAY::THREE_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по капоту отсутствует
void AutoTestsModesP2::C172488_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Капот открыт
        Автомобиль в тревоге по капоту
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->setHood(OPEN, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::TEN_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
    wait(TIME_DELAY::ONE_S);
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по багажнику отсутствует
void AutoTestsModesP2::C172489_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Багажник открыт
        Автомобиль в тревоге по багажнику
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->setTrunk(OPEN, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по зажиганию отсутствует
void AutoTestsModesP2::C172490_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Зажигание включено
        Автомобиль в тревоге по зажиганию.
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание включено\n");

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");

    p_gen6->setIgn(CAN_USE, OFF);
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по датчику движения отсутствует
void AutoTestsModesP2::C172491_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сработал датчик движения
        Автомобиль в тревоге по датчику движения.
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по датчику наклона отсутствует
void AutoTestsModesP2::C172492_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Сработал датчик наклона
        Автомобиль в тревоге по датчику наклона.
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);
    
    p_gen6->setTiltSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при прерывании тревоги по датчику удара отсутствует
void AutoTestsModesP2::C172493_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*! 
        Сработал датчик удара
        Автомобиль в тревоге по датчику удара.
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    wait(TIME_DELAY::UNMASK_ZONE_TIME_S);

    p_gen6->setTiltSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Начальные условия. Тревога выключена\n");
        return;
    }

    printf("PASS Начальные условия. Тревога включена\n");
   
    /*!
        Шаг 1. Прерываем тревогу (любым доступным способом)
    */
    /*!
        Нет пакетов блокировки по CAN
        Охрана включена
    */
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    printf("PASS Шаг 1. Охрана включена\n");

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при дистанционном запуске отсутствует
void AutoTestsModesP2::C172494_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        зажигание выключено (двигатель выключен)
        автомобиль в охране
    */
    if (!setAndCheckInitCanStateForRemoteRun())
    {
        printf("FAIL Начальные условия перед ДЗ не соблюдены\n");
        return;
    }

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Заводим двигатель с ДЗ (Брелок, GPRS, StarLine Master)
    */
    /*!
        Двигатель завелся
    */
    printf("INFO Шаг 1. Дистанционный запуск двигателя брелком\n");
    p_gen6->setRemoteRun(KEYRING);
    
    if (!p_gen6->checkEngine(IGNITION_LOCK,
                             TIME_DELAY::TWO_MINUTE,
                             ON, LOG_LABEL_FAIL,
                             CAN_USE))
    {
        printf("FAIL Шаг 1. Ошибка при запуске двигателя\n");
        return;        
    }

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Двигатель заглушен.\n");
        return;
    }

    printf("PASS Шаг 1. Двигатель работает.\n");
}

// Блокировка по CAN при дистанционном глушении отсутствует
void AutoTestsModesP2::C172495_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!  
        зажигание включено (двигатель включен по ДЗ)
        автомобиль в охране
    */
    if (!setAndCheckInitCanStateForRemoteRun())
    {
        printf("FAIL Начальные условия перед ДЗ не соблюдены\n");
        return;
    }

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    p_gen6->setRemoteRun(KEYRING);

    if (!p_gen6->checkEngine(IGNITION_LOCK,
                             TIME_DELAY::TWO_MINUTE,
                             ON, LOG_LABEL_FAIL,
                             CAN_USE))
    {
        printf("FAIL Шаг 1. Ошибка при запуске двигателя\n");
        return;        
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Начальные условия. Двигатель заглушен.\n");
        return;
    }

    printf("PASS Начальные условия. Двигатель работает.\n");
   
    /*!
        Шаг 1. Глушим двигатель любым способом (Брелок, GPRS, StarLine Master)
    */
    /*!
        Нет CAN пактов блокировки двигателя
        Двигатель заглушен
    */
    p_gen6->setRemoteStop(KEYRING);

    if (p_can1_act->waitBlockEnabled(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG, 
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE, 
                                DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Двигатель работает\n");
    }

    printf("PASS Шаг 1. Двигатель заглушен\n");
    return;
}

// Блокировка по CAN при тревоге при заведенном двигателе скорость 40 (30 разрешенная) отсутствует 
void AutoTestsModesP2::C172496_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");
    
    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
        Антиограбление включено
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ANTI_HIJACK))
    {
        printf("FAIL Шаг 1. Антиограбление выключено\n");
    }
    else
    {
        printf("PASS Шаг 1. Антиограбление включено\n");
    }
}

// Блокировка по CAN при тревоге при заведенном двигателе скорость была 40 стала 20 (30 разрешенная) (блокировка с тормозом выкл)
void AutoTestsModesP2::C172497_TestCase()
{   
    if (settings_check(p_c172480) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!  
        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч (30 разрешённая для блокировки)
        Блокировка по нажатию педали тормоза выключена
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");

    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 2. Понижаем скорость до 20км/ч
    */
    /*!
        Есть CAN пакты блокировки двигателя
    */
    p_can1_act->sendSpeed(20);

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты блокировки не двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты блокировки двигателя получены\n");
}

// Блокировка по CAN при тревога при заведенном двигателе скорость была 40 стала 20 (30 разрешенная) (блокировка с тормозом вкл) тормоз нажат
void AutoTestsModesP2::C172498_TestCase()
{   
    if (settings_check(p_c172498) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        

        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч (30 разрешённая для блокировки)
        Педаль тормоза в неактивном состоянии
        Блокировка по нажатию педали тормоза включена
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");

    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 2. Понижаем скорость до 20км/ч
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    p_can1_act->sendSpeed(20);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 3. Нажимаем педаль тормоза
    */
    /*!
        Есть CAN пакты блокировки двигателя
    */
    p_gen6->setBreak(ON, CAN_USE, TIME_DELAY::MIN_WIRE_EN_DELAY_S);

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя не получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя получены\n");
}

// Блокировка по CAN при тревога при заведенном двигателе скорость была 40 стала 5 (30 разрешенная) (блокировка с тормозом вкл) тормоз не нажат
void AutoTestsModesP2::C172499_TestCase()
{   
    if (settings_check(p_c172498) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        

        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч (30 разрешённая для блокировки)
        Педаль тормоза в неактивном состоянии
        Блокировка по нажатию педали тормоза включена
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");

    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 2. Понижаем скорость до 5км/ч (ниже 10)
    */
    /*!
        Есть CAN пакты блокировки двигателя
    */
    p_can1_act->sendSpeed(5);

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя не получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя получены\n");
}

// Нет блокировки по CAN при тревоге при заведенном двигателе скорость была 40 стала 15 (30 разрешенная) (блокировка с тормозом вкл) тормоз не нажат
void AutoTestsModesP2::C172500_TestCase()
{   
    if (settings_check(p_c172498) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч (30 разрешённая для блокировки)
        Педаль тормоза в неактивном состоянии
        Блокировка по нажатию педали тормоза включена
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");

    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 2. Понижаем скорость до 15км/ч (выше 10)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    p_can1_act->sendSpeed(15);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");
}

// Блокировка по CAN при тревоге при заведенном двигателе скорость была 40 стала 15 (30 разрешенная) (блокировка с тормозом вкл) тормоз нажат
void AutoTestsModesP2::C172501_TestCase()
{   
    if (settings_check(p_c172498) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!  
        Автомобиль не в охране
        Зажигание включено (двигатель включен)
        Парикинг выключен
        Ручник выключен
        Скорость 40км/ч (30 разрешённая для блокировки)
        Педаль тормоза в неактивном состоянии
        Блокировка по нажатию педали тормоза включена
    */
    if (!p_gen6->prepAhjTag(TAG,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE,
                            CAN_USE))
    {
        printf("FAIL Начальные условия. Устройство не подготовлено к антиограблению\n");
        return;
    }

    printf("PASS Начальные условия. Устройство подготовлено к антиограблению\n");

    p_can1_act->sendSpeed(40);
   
    /*!
        Шаг 1. Включаем АО любым способом (GPRS, по метке)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE ? p_gen6->setAnj(ON, NULL, NULL, ON)
                                                      : p_gen6->doAhj(CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 2. Понижаем скорость до 15км/ч (выше 10)
    */
    /*!
        Нет CAN пактов блокировки двигателя
    */
    p_can1_act->sendSpeed(15);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя не получены\n");

    /*!
        Шаг 3. Нажимаем педаль тормоза
    */
    /*!
        Есть CAN пакты блокировки двигателя
    */
    p_gen6->setBreak(ON, CAN_USE, TIME_DELAY::MIN_WIRE_EN_DELAY_S);

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1. CAN пакеты блокировки двигателя не получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты блокировки двигателя получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по двери
void AutoTestsModesP2::C172473_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Тревога
    */
    p_gen6->setDoor(OPEN, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по капоту
void AutoTestsModesP2::C172474_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть капот
    */
    /*!
        Тревога
    */
    p_gen6->setHood(OPEN, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по багажнику
void AutoTestsModesP2::C172475_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Тревога
    */
    p_gen6->setTrunk(OPEN, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по зажиганию
void AutoTestsModesP2::C172476_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Тревога
        Пакеты запрета запуска по CAN получены
    */
    p_gen6->setIgn(CAN_USE, ON);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по ДД
void AutoTestsModesP2::C172477_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитировать датчик движения
    */
    /*!
        Тревога
    */
    p_gen6->setAccelerometerAfterDelay(MOVE, TIME_DELAY::UNMASK_ZONE_TIME_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по ДН
void AutoTestsModesP2::C172478_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитировать датчик наклона
    */
    /*!
        Тревога
    */
    p_gen6->setAccelerometerAfterDelay(TILT, TIME_DELAY::UNMASK_ZONE_TIME_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка наличия пакетов запрета запуска по CAN при тревоге по ДУ
void AutoTestsModesP2::C172479_TestCase()
{   
    if (settings_check(p_c172473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено
        Автомобиль в охране
    */
    if (!p_gen6->setAndCheckIgn(OFF, CAN_USE))
    {
        printf("FAIL Начальные условия. Зажигание включено\n");
        return;
    }
    
    printf("PASS Начальные условия. Зажигание не включено\n");

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
   
    /*!
        Шаг 1. Имитировать датчик удара
    */
    /*!
        Тревога
    */
    p_gen6->setAccelerometerAfterDelay(SHOCK_H, TIME_DELAY::UNMASK_ZONE_TIME_S);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога выключена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Пакеты запрета запуска по CAN получены
    */
    if (!p_gen6->setAndCheckIgn(ON, CAN_USE))
    {
        printf("FAIL Шаг 2. Зажигание включено\n");
        return;
    }
    
    printf("PASS Шаг 2. Зажигание не включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n");
}

// Проверка отсутствия запирания ЦЗ при снятии сенсором  
void AutoTestsModesP2::C2405376_TestCase()
{   
    bool  cap_polarity = true;
    
    if (settings_check(p_c2405376) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Автомобиль в охране
        Настроен сенсор ручки (датчик ручки двери)
        Разрешить ввод ПИН кода через сенсор ручки двери: да
        Подключена сервисная кнопка
    */
    p_gen6->setCapSensor(!cap_polarity);
    
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
   
    /*!
        Шаг 1. Нажать сенсор ручки 3 раза
    */
    /*!
        Сигнал сирены
        Сигнал поворотников
        Импульс закрытия ЦЗ отсутствует
        Импульс открытия ЦЗ отсутствует
    */
    for (uint8_t i = 0; i < 3; i++)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->waitClockAndSignal(CAP_SENSOR_INDICATION, TIME_DELAY::MAX_WAIT_CL_SIGNALS_S))
    {
        printf("PASS Шаг 1. Сигналы сирены и поворотников получены, сигналы ЦЗ отсутствуют\n");
    }
    else
    {
        printf("FAIL Шаг 1. Ожидаемое количество сигналов поворотников/сирены не получено или присутствуют сигналы ЦЗ\n");
        return;
    }

    /*!
        Шаг 2. Ввести правильный пин-код сенсором
    */
    /*!
        Охрана выключена
    */
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                               p_gen6->getDevicePin());
    
    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не выключена\n");
    }
}

// Проверка отсутствия лишнего сигнала светодиода при снятии сенсором  
void AutoTestsModesP2::C2405377_TestCase()
{       
    bool cap_polarity = true;
    
    if (settings_check(p_c2405376) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Автомобиль в охране
        Настроен сенсор ручки (датчик ручки двери)
        Разрешить ввод ПИН кода через сенсор ручки двери: да
        Подключена сервисная кнопка
    */
    p_gen6->setCapSensor(!cap_polarity);
    
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана выключена\n");
        return;
    }
    
    /*!
        Шаг 1. Нажать сенсор ручки 3 раза
    */
    /*!
        Сигнал сирены
        Сигнал поворотников
    */
    for (uint8_t i = 0; i < 3; i++)
    {
        p_gen6->sendCapSensorPulse(cap_polarity, TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }
    
    if (p_gen6->waitClockAndSignal(CAP_SENSOR_INDICATION, TIME_DELAY::MAX_WAIT_CL_SIGNALS_S))
    {
        printf("PASS Шаг 1. Сигналы сирены и поворотников получены\n");
    }
    else
    {
        printf("FAIL Шаг 1. Ожидаемое количество сигналов поворотников/сирены не получено\n");
        return;
    }

    /*!
        Шаг 2. Ввести правильный пин-код сенсором
    */
    /*!
        Охрана выключена
        Подтверждение 2 сигналами световыми и 2 сигналом сирены
    */ 
    p_gen6->setDisarmBeachMode(cap_polarity,
                               TIME_DELAY::STD_CAP_SENSOR_PRESSED_TIME_S,
                               p_gen6->getDevicePin(),
                               4,                                         // Количество цифр пин-кода
                               false);                                    // Не ожидать последней индикации сервисной кнопки
    
    if (p_gen6->waitClockAndSignal(DISARM_INDICATION,
                                   TIME_DELAY::MAX_WAIT_CL_SIGNALS_S,
                                   TIME_DELAY::NO_ERROR_TIME_S,
                                   false))                                // Не проверять статус ЦЗ
    {
        printf("PASS Шаг 2. Подтверждение 2 сигналами световыми и 2 сигналами сирены\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сигналы не получены\n");
        return;
    }
    
    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не выключена\n");
        return;
    }
    
    /*!
        Шаг 3. Ожидать 10 сек
    */
    /*!
        Световой сигнал(ы) на сервисной кнопке отсутствует(ют)
    */
    if (   p_gen6->getDeviceName() == GEN6_X96
        || p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf("PASS Шаг 3. Световой сигнал на трансивере не проверяется\n");
        return;
    }
    
    if (!p_gen6->waitServicePulseAmount(1, TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Световой сигнал(ы) на сервисной кнопке отсутствует(ют)\n");
    }
    else
    {
        printf("FAIL Шаг 3. Световые сигналы на сервисной кнопке присутствуют\n");
    }
}

// Открыть багажник в охране с разрешением (с включением брелока через 15 сек и поиском 60 сек)
void AutoTestsModesP2::C2405378_TestCase()
{    
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c2405378) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Охрана включена
        Метка отсутствует
        Брелок выключен
        Багажник закрыт
        Разрешить в охране открытие багажника при наличии метки или брелока: ДА
        Время поиска метки и брелока при открытом багажнике, сек: 60
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }
    
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Багажник не закрыт\n");
        return;
    }
    
    if (p_gen6->setAndCheckTag(OFF))
    {
        printf("PASS Начальные условия. Метка выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Метка включена\n");
    }
    
    p_gen6->setLcdKeyringVcc(OFF);
    
    /*!
        Открыть багажник
    */
    /*!
        Багажник открыт
    */    
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return;
    }

    /*!
        Через 15 сек. включить брелок
    */
    /*!
        В течение 45 сек. после включения брелока система не в тревоге
        Система в охране с нарушенным периметром
    */ 
    wait(TIME_DELAY::FIFTEEN_S);
    p_gen6->setLcdKeyringVcc(ON);
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::FOURTY_FIVE_S,
                                 TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. Система в тревоге\n");
    }
    else
    {
        printf("PASS Шаг 2. Система не в тревоге\n");
    }
    
    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ARM_TRUNK))
    {
        printf("PASS Шаг 2. Система в охране с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 2. Система не в охране\n");
    }
}

// Открыть багажник в охране после CAN команды на открытие багажника
void AutoTestsModesP2::C2405379_TestCase()
{      
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (settings_check(p_c2405379) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!        
        Охрана включена
        Метка отсутствует
        Брелок выключен
        Багажник закрыт
        Разрешить в охране открытие багажника при наличии метки или брелока: ДА
        Время поиска метки и брелока при открытом багажнике, сек: 15
        Авторизация владельца: метка, брелок
        Управление штатной системой охраны (Slave при подключении к CAN): да 
        Ожидание аторизации, шаг 1 (поиск метки или брелока): 15 сек.
        Ожидание аторизации, шаг 2 : 0 сек.
        Ожидание аторизации, шаг 3 : 0 сек.
    */   
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }
    
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Багажник не закрыт\n");
        return;
    }
    
    if (p_gen6->setAndCheckTag(OFF))
    {
        printf("PASS Начальные условия. Метка выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Метка включена\n");
    }
    
    p_gen6->setLcdKeyringVcc(OFF);
        
    /*!
        Подать CAN команду "Открыть багажник"
    */
    /*!
        Переход в охрану с открытым багажником
    */
    
    if (p_gen6->setAndCheckTrunk(OPEN, CAN_USE))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник закрыт\n");
        return;
    }
    
    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Переход в охрану с открытым багажником\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не находится в охране\n");
        return;
    }
    
    /*!
        Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек. после открытия багажника переход в тревогу
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 2. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Багажник закрыт\n");
        return;
    }
    
    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 ON,
                                 TIME_DELAY::FIFTEEN_S,
                                 TIME_DELAY::FIVE_S))
    {
        printf("PASS Шаг 2. Через 15 сек. после открытия багажника переход в тревогу\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не наступила в положенное время\n");
    }
}

// Превышение пройденного расстояние
void AutoTestsModesP2::C2424871_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if (settings_check(p_c2424871) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния или превышению скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Настроить Выход из сервисного режима: Отключено
    */
    /*!
        Настройка сохранилась
    */
    if (settings_check(p_c2424871_2) != 0)
    {
        printf("PASS Шаг 1. Настройка сохранилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Настройка не сохранилась\n");
        return;
    }

    /*!
        Включить Сервис
    */
    /*!
        Переход в Сервисный режим
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Шаг 2. Переход в Сервисный режим\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в Сервисный режим не произошел\n");
        return;
    }

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 3. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 3. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 1 мин. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::ONE_MINUTE);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 4. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 4. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 4. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в ожидание авторизации произошел\n");
    }
}

// Превышение заданной скорости
void AutoTestsModesP2::C2424872_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 30;


    if (settings_check(p_c2424871) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния или превышению скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Настроить Выход из сервисного режима: Отключено
    */
    /*!
        Настройка сохранилась
    */
    if (settings_check(p_c2424871_2) != 0)
    {
        printf("PASS Шаг 1. Настройка сохранилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Настройка не сохранилась\n");
        return;
    }

    /*!
        Включить Сервис
    */
    /*!
        Переход в Сервисный режим
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Шаг 2. Переход в Сервисный режим\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в Сервисный режим не произошел\n");
        return;
    }

    /*!
        Включить скорость 30 км/ч
    */
    /*!
        Скорость: 30 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 3. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 3. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 4. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 4. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 4. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в ожидание авторизации произошел\n");
    }
}

// Превышение заданной скорости (выход По расстоянию)
void AutoTestsModesP2::C2424873_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 30;


    if (settings_check(p_c2424873) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Включить скорость 30 км/ч
    */
    /*!
        Скорость: 30 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
    }
}

// Сработал ДД до превышения пройденного расстояния
void AutoTestsModesP2::C2424874_TestCase()
{
    const int8_t start_speed_kmph = 0;


    if (settings_check(p_c2424873) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в ожидание авторизации произошел\n");
    }
}

// Выключение сервиса с СМС оповещением (мин. расстояние)
void AutoTestsModesP2::C2424875_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424875) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния
        Порог пройденного расстояния: 100 м
        Порог скорости: 20 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 10 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::TEN_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 2. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса без СМС оповещения (макс. расстояние)
void AutoTestsModesP2::C2424876_TestCase()
{
    const int8_t start_speed_kmph   = 0;
    const int8_t speed_kmph         = 90;

    Timer timer;
    float time_speed_on_s;     // Время включения скорости
    float step_three_delay_s;  // Время задержки на шаге 3


    timer.start();

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424876) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния
        Порог пройденного расстояния: 5000 м
        Порог скорости: 20 км/ч
        СМС оповещение о включении/выключении режима Сервис: выкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 90 км/ч
    */
    /*!
        Скорость: 90 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    time_speed_on_s = timer.read(); // Время включения скорости

    /*!
        Через 2 мин. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::TWO_MINUTE);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Через 2 мин. (4 мин. после включения скорости) вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса отсутствует
    */
    step_three_delay_s = TIME_DELAY::FOUR_MINUTE - (timer.read() - time_speed_on_s);

    if (step_three_delay_s > 0)
    {
        wait(step_three_delay_s);
    }

    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 3. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 3. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
    {
        printf("PASS Шаг 3. СМС оповещение о выходе из сервиса отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 3. СМС оповещение о выходе из сервиса не отсутствует\n");
    }
}

// Выключение сервиса с СМС оповещением с перерывами движения
void AutoTestsModesP2::C2438277_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2438277) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: по превышению пройденного расстояния
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 20 сек. Выключить скорость
    */
    /*!
        Скорость: 0 км/ч
    */
    wait(TIME_DELAY::TWENTY_S);
    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Шаг 2. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 2. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 3. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 3. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 4. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 4. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 30 сек вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::THIRTY_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 5. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 5. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 5. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 5. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 5. СМС оповещение о выходе из сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 5. Отсутствует СМС оповещение о выходе из сервиса\n");
    }
}

// Превышение пройденного расстояния (выход По скорости)
void AutoTestsModesP2::C2424877_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if (settings_check(p_c2424877) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении заданной скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 50 км/ч
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 1 мин. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::ONE_MINUTE);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
    }
}

// Сработал ДД до превышения скорости
void AutoTestsModesP2::C2424878_TestCase()
{
    const int8_t start_speed_kmph = 0;


    if (settings_check(p_c2424878) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении заданной скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в ожидание авторизации произошел\n");
    }
}

// Выключение сервиса с СМС оповещением (мин. скорость)
void AutoTestsModesP2::C2424879_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 16;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424879) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении заданной скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 15 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 16 км/ч
    */
    /*!
        Скорость: 16 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 2. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса без СМС оповещения (макс. скорость)
void AutoTestsModesP2::C2424880_TestCase()
{
    const int8_t start_speed_kmph      = 0;   // Значение скорости для начальных условий
    const int8_t speed_step_one_kmph   = 40;  // Значение скорости для шага 1
    const int8_t speed_step_three_kmph = 81;  // Значение скорости для шага 3


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424880) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении заданной скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 80 км/ч
        СМС оповещение о включении/выключении режима Сервис: выкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_step_one_kmph);

    if (p_gen6->checkSpeed(speed_step_one_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_step_one_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_step_one_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошло
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Включить скорость 81 км/ч
    */
    /*!
        Скорость: 81 км/ч
    */
    p_gen6->setSpeed(speed_step_three_kmph);

    if (p_gen6->checkSpeed(speed_step_three_kmph))
    {
        printf("PASS Шаг 3. Скорость %d км/ч \n", speed_step_three_kmph);
    }
    else
    {
        printf("FAIL Шаг 3. Скорость %d км/ч \n", speed_step_three_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса отсутствует
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 4. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 4. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 4. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
    {
        printf("PASS Шаг 4. СМС оповещение о выходе из сервиса отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 4. СМС оповещение о выходе из сервиса не отсутствует\n");
    }
}

// Сработал ДД до 5 секундного превышения скорости
void AutoTestsModesP2::C2424881_TestCase()
{
    const int8_t start_speed_kmph   = 0;
    const int8_t speed_kmph         = 40;

    Timer timer;
    float time_speed_on_s;     // Время включения скорости
    float step_three_delay_s;  // Время задержки на шаге 3


    timer.start();

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424881) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении заданной скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    time_speed_on_s = timer.read(); // Время включения скорости

    /*!
        Через 2 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошло
    */
    wait(TIME_DELAY::TWO_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::FOUR_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Через 4 сек (через 6 сек после включения скорости) Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    step_three_delay_s = TIME_DELAY::SIX_S - (timer.read() - time_speed_on_s);

    if (step_three_delay_s > 0)
    {
        wait(step_three_delay_s);
    }

    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 3. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 3. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 3. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 3. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Сработал ДД до превышения пройденного расстояния и до превышения скорости
void AutoTestsModesP2::C2424882_TestCase()
{
    const int8_t start_speed_kmph = 0;


    if (settings_check(p_c2424882) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 500 м
        Порог скорости: 20 км/ч
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    /*!
        Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 1. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в ожидание авторизации произошел\n");
    }
}

// Выключение сервиса по расстоянию с СМС оповещением (мин. расстояние)
void AutoTestsModesP2::C2424883_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424883) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 100 м
        Порог скорости: 60 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 10 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::TEN_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 2. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса по расстоянию без СМС оповещения (макс. расстояние)
void AutoTestsModesP2::C2424884_TestCase()
{
    const int8_t start_speed_kmph   = 0;
    const int8_t speed_kmph         = 45;

    Timer timer;
    float time_speed_on_s;     // Время включения скорости
    float step_three_delay_s;  // Время задержки на шаге 3


    timer.start();

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424884) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 5000 м
        Порог скорости: 80 км/ч
        СМС оповещение о включении/выключении режима Сервис: выкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 45 км/ч
    */
    /*!
        Скорость: 45 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    time_speed_on_s = timer.read(); // Время включения скорости

    /*!
        Через 4 мин. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
    */
    wait(TIME_DELAY::FOUR_MINUTE);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Через 4 мин. (8 мин. после включения скорости) вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса отсутствует
    */
    step_three_delay_s = TIME_DELAY::EIGHT_MINUTE - (timer.read() - time_speed_on_s);

    if (step_three_delay_s > 0)
    {
        wait(step_three_delay_s);
    }

    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 3. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 3. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
    {
        printf("PASS Шаг 3. СМС оповещение о выходе из сервиса отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 3. СМС оповещение о выходе из сервиса не отсутствует\n");
    }
}

// Выключение сервиса по скорости с СМС оповещением (мин. скорость)
void AutoTestsModesP2::C2424885_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 16;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424885) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 5000 м
        Порог скорости: 15 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 16 км/ч
    */
    /*!
        Скорость: 16 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 2. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса по скорости без СМС оповещения (макс. скорость)
void AutoTestsModesP2::C2424886_TestCase()
{
    const int8_t start_speed_kmph      = 0;  // Значение скорости для начальных условий
    const int8_t speed_step_one_kmph   = 40; // Значение скорости для шага 1
    const int8_t speed_step_three_kmph = 81; // Значение скорости для шага 3


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424886) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 5000 м
        Порог скорости: 80 км/ч
        СМС оповещение о включении/выключении режима Сервис: выкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_step_one_kmph);

    if (p_gen6->checkSpeed(speed_step_one_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_step_one_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_step_one_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошло
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Включить скорость 81 км/ч
    */
    /*!
        Скорость: 81 км/ч
    */
    p_gen6->setSpeed(speed_step_three_kmph);

    if (p_gen6->checkSpeed(speed_step_three_kmph))
    {
        printf("PASS Шаг 3. Скорость %d км/ч \n", speed_step_three_kmph);
    }
    else
    {
        printf("FAIL Шаг 3. Скорость %d км/ч \n", speed_step_three_kmph);
        return;
    }

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса отсутствует
    */
    wait(TIME_DELAY::SIX_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 4. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 4. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 4. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
    {
        printf("PASS Шаг 4. СМС оповещение о выходе из сервиса отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 4. СМС оповещение о выходе из сервиса не отсутствует\n");
    }
}

// Сработал ДД до 5 секундного превышения скорости
void AutoTestsModesP2::C2424887_TestCase()
{
    const int8_t start_speed_kmph   = 0;
    const int8_t speed_kmph         = 40;

    Timer timer;
    float time_speed_on_s;     // Время включения скорости
    float step_three_delay_s;  // Время задержки на шаге 3


    timer.start();

    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424887) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 5000 м
        Порог скорости: 20 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    time_speed_on_s = timer.read(); // Время включения скорости

    /*!
        Через 2 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошло
    */
    wait(TIME_DELAY::TWO_S);
    p_gen6->setMoveSensor();

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_SERVICE,
                                  OFF,
                                  TIME_DELAY::FOUR_S))
    {
        printf("PASS Шаг 2. Выключение сервиса не произошло\n");
    }
    else
    {
        printf("FAIL Шаг 2. Произошло выключение сервиса\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации произошел\n");
        return;
    }

    /*!
        Через 4 сек (через 6 сек после включения скорости) Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    step_three_delay_s = TIME_DELAY::SIX_S - (timer.read() - time_speed_on_s);

    if (step_three_delay_s > 0)
    {
        wait(step_three_delay_s);
    }

    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 3. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 3. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 3. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 3. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 3. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса по расстоянию и по скорости с СМС оповещением
void AutoTestsModesP2::C2424888_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424888) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 100 м
        Порог скорости: 15 км/ч
        СМС оповещение о включении/выключении режима Сервис: вкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 10 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса получено
    */
    wait(TIME_DELAY::TEN_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::MAX_WAITING_SMS_TIME_S) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 3. СМС оповещение о выходе из сервиса получено\n");
    }
    else
    {
        printf("FAIL Шаг 3. СМС оповещение о выходе из сервиса не получено\n");
    }
}

// Выключение сервиса по расстоянию и по скорости без СМС оповещения
void AutoTestsModesP2::C2424889_TestCase()
{
    const int8_t start_speed_kmph = 0;
    const int8_t speed_kmph       = 40;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424889) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим
        Настроен ДД
        Авторизация владельца: метка, брелок
        Настроен CAN-автомобиль Batmobile (Скорость автомобиля: вкл)
        Скорость: 0 км/ч
        Выход из сервисного режима: при привешении пройденного расстояния или превышении скорости
        Порог пройденного расстояния: 100 м
        Порог скорости: 15 км/ч
        СМС оповещение о включении/выключении режима Сервис: выкл
        Зажигание включено
    */
    if (p_gen6->setServiceModeTag(ON))
    {
        printf("PASS Начальные условия. Сервисный режим\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в сервисном режиме\n");
        return;
    }

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Начальные условия. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не включено\n");
        return;
    }

    p_gen6->setSpeed(start_speed_kmph);

    if (p_gen6->checkSpeed(start_speed_kmph))
    {
        printf("PASS Начальные условия. Скорость %d км/ч \n", start_speed_kmph);
    }
    else
    {
        printf("FAIL Начальные условия. Скорость не %d км/ч \n", start_speed_kmph);
        return;
    }

    // Фильтруем SMS о включении сервисного
    p_gen6->outputSms();

    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */
    p_gen6->setSpeed(speed_kmph);

    if (p_gen6->checkSpeed(speed_kmph))
    {
        printf("PASS Шаг 1. Скорость %d км/ч \n", speed_kmph);
    }
    else
    {
        printf("FAIL Шаг 1. Скорость %d км/ч \n", speed_kmph);
        return;
    }

    /*!
        Через 10 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
        СМС оповещение о выходе из сервиса отсутствует
    */
    wait(TIME_DELAY::TEN_S);
    p_gen6->setMoveSensor();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_SERVICE,
                                 OFF,
                                 TIME_DELAY::TEN_S))
    {
        printf("PASS Шаг 2. Выключение сервиса\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не произошло выключение сервиса\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 2. Переход в ожидание авторизации\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в ожидание авторизации не произошел\n");
        return;
    }

    if (p_gen6->getSim900()->waitCyrillicSmsFor(SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF, TIME_DELAY::STD_WAITING_SMS_TIME_S) == SIM900ACT_NOSMS)
    {
        printf("PASS Шаг 2. СМС оповещение о выходе из сервиса отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 2. СМС оповещение о выходе из сервиса не отсутствует\n");
    }
}

// Постановка в охрану через мобильное приложение по BLE
void AutoTestsModesP2::C2514487_TestCase()
{   
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (!p_gen6->checkMobile())
    {
        return;
    }
    
    if (settings_check(p_c2043655) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Охрана выкл.
    */    
    p_gen6->setSecure(OFF, KEYRING);
    
    /*!
        Поставить в охрану через мобильное приложение по BLE
    */
    /*!
        Система в охране
    */
    p_gen6->setSecure(ON, MOBILE);
    
    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не в охране\n");
    }
    
    /*!
        Проверка состояния охраны через мобильное приложение по BLE
    */
    /*!
        Система в охране
    */
    if (p_gen6->checkSecureMobile(ON))
    {
        printf("PASS Шаг 2. Система в охране\n");
    }
    else
    {
        printf("FAIL Шаг 2. Система не в охране\n");
    }
}

//Снятие с охраны через мобильное приложение по BLE 
void AutoTestsModesP2::C2514488_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }
    
    if (!p_gen6->checkMobile())
    {
        return;
    }
    
    if (settings_check(p_c2043655) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        Охрана вкл.
    */
    p_gen6->setSecure(ON, KEYRING);
    
    /*!
        Снять с охраны через мобильное приложение по BLE
    */
    /*!
        Система не в охране
    */
    p_gen6->setSecure(OFF, MOBILE);
    
    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Система не в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система в охране\n");
    }
    
    /*!
        Проверка состояния охраны через мобильное приложение по BLE
    */
    /*!
        Система не в охране
    */
    if (p_gen6->checkSecureMobile(OFF))
    {
        printf("PASS Шаг 2. Система не в охране\n");
    }
    else
    {
        printf("FAIL Шаг 2. Система в охране\n");
    }
}

// Перепостановка во время ДЗ
void AutoTestsModesP2::C2514489_TestCase()
{    
    /*!
        Начальные условия
    */
    /*!        
        Охрана вкл.
        ПН выполнена
        Типы КПП и Запуска: не важно
        Перепостановка в охрану: вкл
        Время до перепостановки: 5 сек
    */    
    
    /*!
        Выполнить ДЗ
    */
    /*!
        Двигатель заведен
    */
    /*!
        Выключить охрану
    */
    /*!
        Охрана отключена (снято, двигатель заведен)
        Через 5 сек охрана включена (сработала перепостановка
        Двигатель заведен
    */
}

// Проверка запрета запуска в состоянии "Охрана"
void AutoTestsModesP2::C2728677_TestCase()
{    
    if (settings_check(p_c2728677) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                         вкл.        
        ||Система запуска двигателя|                      Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|      Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях| Охрана: Да
        ||Запрещать запуск двигателя по CAN в состояниях| Ожидание авторизации: Да
        ||Запрещать запуск двигателя по CAN в состояниях| Запрет поездки: Да
        ||Автомобиль|                                     9999 - Batmobile (test) 2014-2017
        ||imitCAN
    */    
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");
      
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус включённого зажигания 0x031 в D0 = 0x03 или 0x04
        Включилась тревога
        Не позднее чем через 5 мс Основной блок отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
        Двигатель не заведен
    */   
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты запрета запуска получены\n");

    p_gen6->setEngine(OFF, CAN_USE); 

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель не запущен\n"); 
}

// Проверка запрета запуска в состоянии "Ожидание авторизации"
void AutoTestsModesP2::C2728678_TestCase()
{
    if (   ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
        || ((p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2728678) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                                                   вкл.        
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Да
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
        ||Авторизация владельца|                                                    Брелок: да
        ||Снятие запрета поездки|                                                   Метка: нет
        ||Требовать авторизацию владельца при снятии с охраны следующими способами| Метка
        ||Метка|                                                                    Включена
        ||Брелок|                                                                   Выключен
    */
    p_gen6->setLedKeyringVcc(OFF);
    p_gen6->setLcdKeyringVcc(OFF);

    if (!p_gen6->setAndCheckTag(ON))
    {
        printf("FAIL Начальные условия. Метка не включена\n");
        return;
    }

    printf("PASS Начальные условия. Метка включена\n"); 

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n"); 
    
    /*!
        Снять охрану по Slave
    */
    /*!
        Основной блок перешел в Ожидание авторизации
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1. Система не находится в ожидании авторизации\n");
        return;
    }

    printf("PASS Шаг 1. Система находится в ожидании авторизации\n");
    
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус включённого зажигания 0x031 в D0 = 0x03 или 0x04
        Не позднее чем через 5 мс Основной блок отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
        Двигатель не заведен
    */   
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);      

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }
 
    printf("PASS Шаг 2. Зажигание включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n"); 

    p_gen6->setEngine(OFF, CAN_USE); 

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 2. Статус в регионе: двигатель запущен\n");
        return;
    }

    printf("PASS Шаг 2. Статус в регионе: двигатель не запущен\n"); 
}

// Проверка запрета запуска в состоянии "Запрет поездки"
void AutoTestsModesP2::C2728679_TestCase()
{    
    if (   ((p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
        || ((p_gen6->getModules() & R868_MODULE) != R868_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2728679) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                                                   вкл.        
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Да
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
        ||Авторизация владельца|                                                    Брелок: да
        ||Снятие запрета поездки|                                                   Метка: да
        ||Условие активации запрета поездки|                                        При снятии с охраны
        ||Требовать авторизацию владельца при снятии с охраны следующими способами| Метка: да
        ||Метка|                                                                    Выключена
        ||Брелок|                                                                   Включен
    */    
    p_gen6->setAndCheckTag(OFF);
    p_gen6->setLcdKeyringVcc(ON);

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");    
    
    /*!
        Брелоком выключить охрану
    */
    /*!
        Основной блок перешел в Запрет поездки
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система не находится в запрете поездки\n");
        return;
    }

    printf("PASS Шаг 1. Система находится в запрете поездки\n");
    
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус выключённого зажигания  0x031 в D0 = 0x03 или 0x04
        Не позднее чем через 5 мс Основной блок отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
        Двигатель не заведен
    */
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);     

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }
 
    printf("PASS Шаг 2. Зажигание включено\n");

    if (!p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска не получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска получены\n"); 

    p_gen6->setEngine(OFF, CAN_USE); 

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 2. Статус в регионе: двигатель запущен\n");
        return;
    }

    printf("PASS Шаг 2. Статус в регионе: двигатель не запущен\n"); 
}

// Проверка отмены запрета запуска в ДЗ
void AutoTestsModesP2::C2728680_TestCase()
{
    float eng_wait_time_s; // Время ожидания запуска двигателя после ДЗ


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        eng_wait_time_s = TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        eng_wait_time_s = TIME_DELAY::BYPASS_AFTER_SMS_TIME_S;
    }
    else
    {
        printf(CASE_NOT_FOUND);
    }

    if (settings_check(p_c2728677) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Охрана|                                                                   вкл.
        ||Программная нейтраль|                                                     Выполнена
        ||Паркинг|                                                                  Включен
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Да
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Да
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
    */
    p_gen6->setIgn(CAN_USE,
                   ON,
                   TIME_DELAY::MAX_WIRE_EN_DELAY_S);
    p_gen6->setParking(ON,
                       CAN_USE,
                       TIME_DELAY::MAX_WIRE_EN_DELAY_S);
    p_gen6->setIgn(CAN_USE, OFF);

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    /*!
        Произвести ДЗ
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус зажигания 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек)
        Двигатель заведен с помощью imitCAN
    */
    p_gen6->setRemoteRun(KEYRING, TIME_DELAY::NULL_DELAY_S);

    if (!p_can1_act->waitStartEngine(eng_wait_time_s))
    {
        printf("FAIL Шаг 1. Пакеты CAN запуска двигателя отсутствуют\n");
        return;
    }

    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }

    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n");
}

// Проверка запуска двигателя в состоянии "Снято"
void AutoTestsModesP2::C2728681_TestCase()
{    
    if (settings_check(p_c2728677) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                         выкл. (снято)        
        ||Система запуска двигателя|                      Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|      Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях| Охрана: Да
        ||Запрещать запуск двигателя по CAN в состояниях| Ожидание авторизации: Да
        ||Запрещать запуск двигателя по CAN в состояниях| Запрет поездки: Да
        ||Автомобиль|                                     9999 - Batmobile (test) 2014-2017
        ||imitCAN
    */   
    if (!p_gen6->setAndCheckSecure(OFF,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");     
    
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус включённого зажигания 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек) 
        Двигатель заведен с помощью imitCAN
    */ 
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);    

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }
 
    printf("PASS Шаг 1. Зажигание включено\n");

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n"); 
}

// Проверка запрета запуска в состоянии "Охрана" (настройки выкл)
void AutoTestsModesP2::C2728682_TestCase()
{    
    if (settings_check(p_c2728682) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                         вкл.        
        ||Система запуска двигателя|                      Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|      Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях| Охрана: Нет
        ||Запрещать запуск двигателя по CAN в состояниях| Ожидание авторизации: Нет
        ||Запрещать запуск двигателя по CAN в состояниях| Запрет поездки: Нет
        ||Автомобиль|                                     9999 - Batmobile (test) 2014-2017
        ||imitCAN
    */  
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");    
    
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус включённого зажигания 0x031 в D0 = 0x03 или 0x04
        Включилась тревога
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек) 
        Двигатель заведен с помощью imitCAN
    */   
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);    

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }
 
    printf("PASS Шаг 1. Зажигание включено\n"); 

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                  SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                  DIAG_GUARD_STATE_ALERT_MAIN,
                                  ON,
                                  TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    printf("PASS Шаг 1. Тревога включена\n");

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n"); 
}

// Проверка запрета запуска в состоянии "Ожидание авторизации" (настройки выкл)
void AutoTestsModesP2::C2728683_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2728683) == 0)
    {
        return;
    }
  
    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                                                   вкл.        
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Нет
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
        ||Авторизация владельца|                                                    Брелок: да
        ||Снятие запрета поездки|                                                   Метка: нет
        ||Требовать авторизацию владельца при снятии с охраны следующими способами| Метка
        ||Метка|                                                                    Включена
        ||Брелок|                                                                   Выключен
    */ 
    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");  

    p_gen6->setLedKeyringVcc(OFF);
    p_gen6->setLcdKeyringVcc(OFF);   
    
    /*!
        Выключить охрану по SLAVE
    */
    /*!
        Основной блок перешел в Ожидание авторизации
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1. Система не находится в ожидании авторизации\n");
        return;
    }

    printf("PASS Шаг 1. Система находится в ожидании авторизации\n");

    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус зажигания 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек) 
        Двигатель заведен с помощью imitCAN
    */    
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);   

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n"); 
}

// Проверка запрета запуска в состоянии "Запрет поездки" (настройки выкл)
void AutoTestsModesP2::C2728684_TestCase()
{    
    if (   ((p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
        || ((p_gen6->getModules() & R868_MODULE) != R868_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2728684) == 0)
    {
        return;
    }
  
    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                                                   вкл.        
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Нет
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
        ||Авторизация владельца|                                                    Брелок: да
        ||Снятие запрета поездки|                                                   Метка: да
        ||Условие активации запрета поездки|                                        При снятии с охраны
        ||Требовать авторизацию владельца при снятии с охраны следующими способами| Метка: да
        ||Метка|                                                                    Выключена
        ||Брелок|                                                                   Включен
    */ 
    if (!p_gen6->setAndCheckTag(OFF))
    {
        printf("FAIL Начальные условия. Метка не выключена\n");
        return;
    }

    printf("PASS Начальные условия. Метка выключена\n");   

    p_gen6->setLcdKeyringVcc(ON);

    if (!p_gen6->setAndCheckSecure(ON,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");    
    
    /*!
        Брелоком выключить охрану
    */
    /*!
        Основной блок перешел в Запрет поездки
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   CAN_USE,
                                   DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Система не находится в запрете поездки\n");
        return;
    }

    printf("PASS Шаг 1. Система находится в запрете поездки\n");

    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус включённого зажигания 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек) 
        Двигатель заведен с помощью imitCAN
    */
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);      

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_IGN))
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }
 
    printf("PASS Шаг 2. Зажигание включено\n");

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 2. CAN пакеты запрета запуска получены\n");
        return;
    }
    
    printf("PASS Шаг 2. CAN пакеты запрета запуска не получены\n"); 

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 2. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 2. Статус в регионе: двигатель запущен\n"); 
}

// Проверка отмены запрета запуска в ДЗ (настройки выкл)
void AutoTestsModesP2::C2728685_TestCase()
{
    float eng_wait_time_s; // Время ожидания запуска двигателя после ДЗ


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        eng_wait_time_s = TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        eng_wait_time_s = TIME_DELAY::BYPASS_AFTER_SMS_TIME_S;
    }
    else
    {
        printf(CASE_NOT_FOUND);
    }

    if (settings_check(p_c2728682) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Охрана|                                                                   вкл.
        ||Программная нейтраль|                                                     Выполнена
        ||Ручник|                                                                   Включен
        ||Система запуска двигателя|                                                Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|                                Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях|                           Охрана: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Ожидание авторизации: Нет
        ||Запрещать запуск двигателя по CAN в состояниях|                           Запрет поездки: Нет
        ||Автомобиль|                                                               9999 - Batmobile (test) 2014-2017
        ||imitCAN|
    */
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setParking(ON, CAN_USE);
    p_gen6->setIgn(CAN_USE, OFF);

    if (!p_gen6->setAndCheckSecure(ON,
                                   KEYRING,
                                   DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана включена\n");

    /*!
        Произвести ДЗ
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус запрета запуска 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек)
        Двигатель заведен с помощью imitCAN
    */
    p_gen6->setRemoteRun(KEYRING, TIME_DELAY::NULL_DELAY_S);

    if (!p_gen6->waitInspector(eng_wait_time_s, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("FAIL Шаг 1. Обходчик не включился\n");
        return;
    }

    printf("PASS Шаг 1. Включился обходчик\n");

    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE);

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }

    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n");
}

// Проверка запуска двигателя в состоянии "Снято" (настройки выкл)
void AutoTestsModesP2::C2728686_TestCase()
{
    if (settings_check(p_c2728682) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||Охрана|                                         выкл. (снято)        
        ||Система запуска двигателя|                      Управление запуском по CAN-LIN
        ||Управление обходом штатного иммобилайзера|      Обход по CAN/LIN
        ||Запрещать запуск двигателя по CAN в состояниях| Охрана: Нет
        ||Запрещать запуск двигателя по CAN в состояниях| Ожидание авторизации: Нет
        ||Запрещать запуск двигателя по CAN в состояниях| Запрет поездки: Нет
        ||Автомобиль|                                     9999 - Batmobile (test) 2014-2017
        ||imitCAN
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    printf("PASS Начальные условия. Охрана выключена\n");  
    
    /*!
        С помощью imitCan запустить двигатель (запуск двигателя штатными средствами без ОБ)
    */
    /*!
        Включилось зажигание
        Основной блок получил через CAN статус зажигания 0x031 в D0 = 0x03 или 0x04
        Основной блок НЕ отправил в CAN 0x151 - команда запрета запуска { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } (в течение 10 сек) 
        Двигатель заведен с помощью imitCAN
    */    
    p_gen6->setIgn(CAN_USE, ON);
    p_gen6->setEngine(ON, CAN_USE); 

    if (p_gen6->waitEngineBlockCan(TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1. CAN пакеты запрета запуска получены\n");
        return;
    }
    
    printf("PASS Шаг 1. CAN пакеты запрета запуска не получены\n");

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING))
    {
        printf("FAIL Шаг 1. Статус в регионе: двигатель не запущен\n");
        return;
    }

    printf("PASS Шаг 1. Статус в регионе: двигатель запущен\n"); 
}

// Тревога по питанию (сирена R6)
void AutoTestsModesP2::C2799849_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799849) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Охрана                          | включена
        ||Не настроен выход               | сирена (отключена в каналах)
        ||Подключен                       | R6
        ||Управление выходом на сирену R6 | Сирена
    */
    p_gen6->setR6Vcc();

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Отключить питание основного блока
    */
    /*!
        Питание отключено
        Блок выключен
    */
    p_gen6->off();

    /*!
        Включить питание основного блока
    */
    /*!
        Питание включено
        Блок включен
        Тревога включена
        Включена сирена R6
        Сирена основного блока не включилась
    */
    wait(TIME_DELAY::DEVICE_VCC_RESET_WAIT_TIME_S);
    p_gen6->on();

    if (p_gen6->waitSirenType(SIREN_TYPE_R6,
                              TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S + TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Включена сирена R6, сирена основного блока не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сирена R6 не включилась или сработала сирена основного блока\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
    }
}

// Тревога по питанию (сирена штатная)
void AutoTestsModesP2::C2799850_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799850) == 0)
    {
        return;
    }
    
    /*!
        Начальные условия
    */
    /*!
        ||Охрана                          | включена
        ||Настроен выход                  | сирена
        ||Подключен                       | R6
        ||Управление выходом на сирену R6 | Не управлять
    */
    p_gen6->setR6Vcc();

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Отключить питание основного блока
    */
    /*!
        Питание отключено
        Блок выключен
    */
    p_gen6->off();

    /*!
        Включить питание основного блока
    */
    /*!
        Питание включено
        Блок включен
        Тревога включена
        Сирена R6 не включилась
        Включена сирена основного блока
    */
    wait(TIME_DELAY::DEVICE_VCC_RESET_WAIT_TIME_S);
    p_gen6->on();

    if (p_gen6->waitSirenType(SIREN_TYPE_BASE,
                              TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S + TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Включена штатная сирена, сирена R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Штатная сирена не включилась или сработала сирена R6\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
    }
}

// Тревога по питанию (сирена R6+штатная)
void AutoTestsModesP2::C2799851_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Охрана                          | включена
        ||Настроен выход                  | сирена
        ||Подключен                       | R6
        ||Управление выходом на сирену R6 | Сирена
    */
    p_gen6->setR6Vcc();

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Отключить питание основного блока
    */
    /*!
        Питание отключено
        Блок выключен
    */
    p_gen6->off();

    /*!
        Включить питание основного блока
    */
    /*!
        Питание включено
        Блок включен
        Тревога включена
        Включена сирена R6
        Включена сирена основного блока
    */
    wait(TIME_DELAY::DEVICE_VCC_RESET_WAIT_TIME_S);
    p_gen6->on();

    if (p_gen6->waitSirenType(SIREN_TYPE_BASE_AND_R6,
                              TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S + TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Сирена включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Сирена не включена (штатная/R6 или обе)\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
    }
}

// Тревога во время ДЗ (старт-стоп 1 импульс)
void AutoTestsModesP2::C2799852_TestCase()
{
    if (settings_check(p_c2799852) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||ручник:                              | включен
        ||программная нейтраль:                | выполнена
        ||автомобиль:                          | в охране
        ||КПП:                                 | МКПП
        ||Система запуска двигателя:           | Старт-Стоп
        ||Управление обходом:                  | Аналоговый
        ||Алгоритм работы модуля обхода:       | Активен все время (и при ТТ и ПН)
        ||Кол-во попыток запуска:              | 1
        ||Количество импульсов Старт-Стоп:     | один
        ||Задержка включения 1ого импульса СС: | 5
        ||Задержка вкл последнего импульса СС: | 5
        ||Длительность последнего импульса СС: | 5
        ||Время ожидания запуска:              | 5
        ||Настроен выход:                      | Запуск двигателя: имитация педали тормоза или сцепления
    */
    p_gen6->setProgramNeutral(KEYRING,
                              NEUTRAL_DETECT_TYPE_DOOR,
                              IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING,
                              START_STOP_ONE_IMPULSE);

    if (p_gen6->checkProgramNeutral(ON))
    {
        printf("PASS Начальные условия. Программная нейтраль выполнена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Программная нейтраль не выполнена\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    /*!
        Произвести дистанционный запуск двигателя
    */
    /*!
        Подача потенциала на модуль обхода (аналоговый)
    */
    p_gen6->setRemoteRun(KEYRING);

    if (p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Подача потенциала на модуль обхода\n");
    }
    else
    {
        printf("FAIL Шаг 1. Отсутствует потенциал на модуле обхода\n");
        return;
    }

    /*!
        До Подачи потенциала на имитацию педали тормоза - открыть дверь
    */
    /*!
        Дверь открыта
        Включилась тревога
        Включилась блокировка
        Включилась сирена
        Включились звуковые сигналы
        ПН сброшена
        ДЗ прекратился: неудачный запуск двигателя
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    if (p_gen6->waitBlock(TIME_DELAY::ALARM_BLOCK_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка не включена\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_NEUTRAL,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. ПН сброшена\n");
    }
    else
    {
        printf("FAIL Шаг 2. ПН не сброшена\n");
        return;
    }

    if (   !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_STARTING)
        && !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_RUNNING))
    {
        printf("PASS Шаг 2. ДЗ прекратился\n");
    }
    else
    {
        printf("FAIL Шаг 2. ДЗ не прекратился или двигатель запустился\n");
        return;
    }
}

// Тревога во время ДЗ (старт-стоп 2 импульса)
void AutoTestsModesP2::C2799853_TestCase()
{
    if (settings_check(p_c2799853) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||ручник:                              | включен
        ||программная нейтраль:                | выполнена
        ||автомобиль:                          | в охране
        ||КПП:                                 | МКПП
        ||Система запуска двигателя:           | Старт-Стоп
        ||Управление обходом:                  | Аналоговый
        ||Алгоритм работы модуля обхода:       | Активен все время (и при ТТ и ПН)
        ||Кол-во попыток запуска:              | 1
        ||Количество импульсов Старт-Стоп:     | 2
        ||Задержка включения 1ого импульса СС: | 5
        ||Задержка вкл последнего импульса СС: | 5
        ||Длительность последнего импульса СС: | 5
        ||Время ожидания запуска:              | 5
        ||Настроен выход:                      | Запуск двигателя: имитация педали тормоза или сцепления
    */
    p_gen6->setProgramNeutral(KEYRING,
                              NEUTRAL_DETECT_TYPE_DOOR,
                              IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING,
                              START_STOP_TWO_IMPULSE);

    if (p_gen6->checkProgramNeutral(ON))
    {
        printf("PASS Начальные условия. Программная нейтраль выполнена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Программная нейтраль не выполнена\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    /*!
        Произвести дистанционный запуск двигателя
    */
    /*!
        Подача потенциала на модуль обхода (аналоговый)
        Через 5с подача потенциала на старт-стоп (1ый импульс)
        Через 1с снятие потенциала с старт-стоп (1ый импульс)
    */
    p_gen6->setRemoteRun(KEYRING);

    if (p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Подача потенциала на модуль обхода\n");
    }
    else
    {
        printf("FAIL Шаг 1. Отсутствует потенциал на модуле обхода\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(DELAY_FIRST_IMPULSE_SS + TIME_DELAY::STD_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Подача потенциала на старт-стоп (1ый импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не подан потенциал на старт-стоп (1ый импульс)\n");
        return;
    }
    
    if (p_gen6->waitStartStopBtn(TIME_DELAY::ONE_S, !p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Снятие потенциала с старт-стоп (1ый импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не снят потенциал с старт-стоп (1ый импульс)\n");
        return;
    }

    /*!
        До Подачи потенциала на имитацию педали тормоза - открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
        Включилась блокировка
        Включилась сирена
        Включились звуковые сигналы
        ДЗ прекратился: неудачный запуск двигателя
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 2. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Багажник не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    if (p_gen6->getBlock(PIN))
    {
        printf("PASS Шаг 2. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка не включена\n");
        return;
    }

    if (   !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_STARTING)
        && !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_RUNNING))
    {
        printf("PASS Шаг 2. ДЗ прекратился\n");
    }
    else
    {
        printf("FAIL Шаг 2. ДЗ не прекратился или двигатель запустился\n");
        return;
    }
}

// Тревога во время ДЗ (старт-стоп 3 импульса)
void AutoTestsModesP2::C2799854_TestCase()
{
    if (settings_check(p_c2799854) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||ручник:                              | включен
        ||программная нейтраль:                | выполнена
        ||автомобиль:                          | в охране
        ||КПП:                                 | МКПП
        ||Система запуска двигателя:           | Старт-Стоп
        ||Управление обходом:                  | Аналоговый
        ||Алгоритм работы модуля обхода:       | Активен все время (и при ТТ и ПН)
        ||Кол-во попыток запуска:              | 1
        ||Количество импульсов Старт-Стоп:     | 3
        ||Задержка включения 1ого импульса СС: | 5
        ||Задержка вкл последнего импульса СС: | 5
        ||Длительность последнего импульса СС: | 5
        ||Время ожидания запуска:              | 5
        ||Настроен выход:                      | Запуск двигателя: имитация педали тормоза или сцепления
    */
    p_gen6->setProgramNeutral(KEYRING,
                              NEUTRAL_DETECT_TYPE_DOOR,
                              IGN_SUPP_TYPE_HAND_BRAKE_OR_PARKING,
                              START_STOP_THREE_IMPULSE);

    if (p_gen6->checkProgramNeutral(ON))
    {
        printf("PASS Начальные условия. Программная нейтраль выполнена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Программная нейтраль не выполнена\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    /*!
        Произвести дистанционный запуск двигателя
    */
    /*!
        Подача потенциала на модуль обхода (аналоговый)
        Через 5с подача потенциала на старт-стоп (1ый импульс)
        Через 1с снятие потенциала с старт-стоп (1ый импульс)
        Через 1с подача потенциала на старт-стоп (2ой импульс)
        Через 1с снятие потенциала с старт-стоп (2ой импульс)
    */
    p_gen6->setRemoteRun(KEYRING);

    if (p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Подача потенциала на модуль обхода\n");
    }
    else
    {
        printf("FAIL Шаг 1. Отсутствует потенциал на модуле обхода\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(DELAY_FIRST_IMPULSE_SS + TIME_DELAY::STD_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Подача потенциала на старт-стоп (1ый импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не подан потенциал на старт-стоп (1ый импульс)\n");
        return;
    }
    
    if (p_gen6->waitStartStopBtn(TIME_DELAY::ONE_S, !p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Снятие потенциала с старт-стоп (1ый импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не снят потенциал с старт-стоп (1ый импульс)\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(TIME_DELAY::ONE_S + TIME_DELAY::STD_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Подача потенциала на старт-стоп (2ой импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не подан потенциал на старт-стоп (2ой импульс)\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(TIME_DELAY::ONE_S, !p_gen6->getPolarity(ID_OUT_START_STOP_BTN)))
    {
        printf("PASS Шаг 1. Снятие потенциала с старт-стоп (2ой импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не снят потенциал с старт-стоп (2ой импульс)\n");
        return;
    }

    /*!
        До Подачи потенциала на имитацию педали тормоза - открыть капот
    */
    /*!
        Капот открыт
        Включилась тревога
        Включилась блокировка
        Включилась сирена
        Включились звуковые сигналы
        ДЗ прекратился: неудачный запуск двигателя
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 2. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    if (p_gen6->getBlock(PIN))
    {
        printf("PASS Шаг 2. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка не включена\n");
        return;
    }

    if (   !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_STARTING)
        && !p_gen6->getSlpCmdStatus(DIAG_DATA_ENG_STATE,
                                    SLP_STATUSES_SIZES::DIAG_DATA_ENG_STATE_SIZE,
                                    DIAG_ENG_STATE_RUNNING))
    {
        printf("PASS Шаг 2. ДЗ прекратился\n");
    }
    else
    {
        printf("FAIL Шаг 2. ДЗ не прекратился или двигатель запустился\n");
        return;
    }
}

// Выключение АО из АО
void AutoTestsModesP2::C2874561_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Антиограблении
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAnj(ON))
    {
        printf("PASS Начальные условия. Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Антиограбление не включено\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Антиограбление включено (статус в регионе)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Антиограбление не включено (статус в регионе отсутствует)\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с правильным кодом экстренного выключения охраны (30 xxxx)
    */
    /*!
        Антиограбление отключено
        Переход в Снято
        Получено СМС-уведомление: "Антиограбление откл. Был введен код экстренного выключения охраны. Охрана откл."
    */
    if (p_gen6->setAnj(OFF))
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Антиограбление отключено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление не отключено\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произведен\n");
    }
}

// Выключение АО из АО с неверным кодом
void AutoTestsModesP2::C2874562_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Антиограблении
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAnj(ON))
    {
        printf("PASS Начальные условия. Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Антиограбление не включено\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Антиограбление включено (статус в регионе)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Антиограбление не включено (статус в регионе отсутствует)\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с неправильным кодом экстренного выключения охраны (АНТИ- xxxx)
    */
    /*!
        Антиограбление не отключено (активно)
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Охрана вкл. Антиограбление вкл."
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_RUS::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_ALERT_MAIN, // "Охрана вкл." или "Тревога осн." - зависит от этапа АО. Пока ждем СМС этап может измениться
                                                                                                                  // Но Антиограбление мы включаем командой, поэтому у нас всегда будет сообщение "Тревога осн."
                                                                      SMS_MSG_STR::SMS_ANSW_STR_AHJ_ON).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                  SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                  DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK,
                                  OFF,
                                  TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Антиограбление не отключено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление отключилось\n");
    }
}

// Выключение АО из Снято
void AutoTestsModesP2::C2874563_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Снято
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с правильным кодом экстренного выключения охраны (А- xxxx)
    */
    /*!
        Система осталась в Снято
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Охрана откл."
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_ALT_RUS::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошел переход из Снято\n");
    }
}

// Выключение АО из Снято с неверным кодом
void AutoTestsModesP2::C2874564_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Снято
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с неправильным кодом экстренного выключения охраны (AHJ- xxxx)
    */
    /*!
        Система осталась в Снято
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Охрана откл."
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_EN::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Снято\n");
    }
}

// Выключение АО из Охраны
void AutoTestsModesP2::C2874565_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Охране
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с правильным кодом экстренного выключения охраны (30 xxxx)
    */
    /*!
        Система перешла в Снято
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Охрана вкл."
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_ARM).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система перешла в Снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в Снято\n");
    }
}

// Выключение АО из Охраны с неверным кодом
void AutoTestsModesP2::C2874566_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Охране
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Отправить SMS-команду отключения антиограбления с неправильным кодом экстренного выключения охраны (АНТИ- xxxx)
    */
    /*!
        Система осталась в Охране
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Охрана вкл."
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_RUS::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_ARM).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Охране\n");
    }
}

// Выключение АО из Сервиса
void AutoTestsModesP2::C2874567_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Сервисе
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);
    p_gen6->setServiceMode(ON);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_SERVICE))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    p_gen6->outputSms(); // Пропускаем СМС о входе в сервис

    /*!
        Отправить SMS-команду отключения антиограбления с правильным кодом экстренного выключения охраны (А- xxxx)
    */
    /*!
        Система осталась в Сервисе
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Сервисный режим"
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_ALT_EN::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_SERVICE).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Сервисе\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Сервисе\n");
    }
}

// Выключение АО из Сервиса с неверным кодом
void AutoTestsModesP2::C2874568_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Сервисе
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);
    p_gen6->setServiceMode(ON);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_SERVICE))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    p_gen6->outputSms(); // Пропускаем СМС о входе в сервис

    /*!
        Отправить SMS-команду отключения антиограбления с неправильным кодом экстренного выключения охраны (AHJ- xxxx)
    */
    /*!
        Система осталась в Сервисе
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Сервисный режим"
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_EN::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_SERVICE).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Сервисе\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Сервисе\n");
    }
}

// Выключение АО из Регистрации
void AutoTestsModesP2::C2874569_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Регистрации
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);
    p_gen6->registrationMode(ON);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_REG))
    {
        printf("PASS Начальные условия. Режим регистрации включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Режим регистрации не включен\n");
        return;
    }

    p_gen6->outputSms(); // Пропускаем СМС о входе в регистрацию

    /*!
        Отправить SMS-команду отключения антиограбления с правильным кодом экстренного выключения охраны (30 xxxx)
    */
    /*!
        Система осталась в Регистрации
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Режим регистрации"
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_NUMERIC::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_REG).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_REG,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Регистрации\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Регистрации\n");
    }
}

// Выключение АО из Регистрации с неверным кодом
void AutoTestsModesP2::C2874570_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2874561) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в Регистрации
        ||антиограбление:                      | включено
    */
    setAhjTestsStartConditions(IGN_OFF);
    p_gen6->registrationMode(ON);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_REG))
    {
        printf("PASS Начальные условия. Режим регистрации включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Режим регистрации не включен\n");
        return;
    }

    p_gen6->outputSms(); // Пропускаем СМС о входе в регистрацию

    /*!
        Отправить SMS-команду отключения антиограбления с неправильным кодом экстренного выключения охраны (АНТИ- xxxx)
    */
    /*!
        Система осталась в Регистрации
        Получено СМС-уведомление: "Команда "Отключить антиограбление" не выполнена. Режим регистрации"
    */
    if (p_gen6->getSim900()->inspectionCyrillicSms(p_gen6->getDevicePhones()[DEVICE_PHONE_NO_1],
                                                   Sim900::combineStr("%s %s",
                                                                      SMS_CMD_TOKENS_RUS::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      p_gen6->getWrongDevicePin()).c_str(),
                                                   Sim900::combineStr("%s %s %s\n%s",
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD,
                                                                      SMS_MSG_STR::SMS_PARSE_CMD_ANTIROBBERY_OFF,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_CMD_NOT_EXECUTE,
                                                                      SMS_MSG_STR::SMS_ANSW_STR_GUARD_REG).c_str()) == SIM900ACT_TRUESMS)
    {
        printf("PASS Шаг 1. Получено СМС-уведомление\n");
    }
    else
    {
        printf("FAIL Шаг 1. СМС-уведомление не получено или неверно\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_REG,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система осталась в Регистрации\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в Регистрации\n");
    }
}

// Переход в запрет поездки из охраны через мобильное приложение (сервер)
void AutoTestsModesP2::C2874875_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c2874875) == 0)
    {
        return;
    }

    if (!p_gen6->authStarlineOnline())
    {
        printf("FAIL Не удалось выполнить авторизацию на SL-online\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние автомобиля:
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в охране
        ||Настройки:
        ||CAN Автомобиль:                      | 9999 (Batmobile)
        ||Настройка CAN штатные кнопки:        | включена (галочка стоит)
        ||Штатные кнопки:                      | прописаны (зарегистрированы)
        ||снятие запрета поездки:              | штатные кнопки
        ||активация запрета поездки:           | при снятии с охраны
        ||подключено:                          | мобильное приложение (через сервер)
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Выключить охрану с помощью мобильного приложения (через сервер)
    */
    /*!
        Система перешла в запрет поездки
        Приложение (сервер) не сообщает об ошибке
    */
    if (!p_gen6->setStarlineOnlineParam(StarlineOnline::ARM, OFF))
    {
        printf("FAIL Шаг 1. Ошибка при снятии с охраны через SL-online\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Система перешла в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в запрет поездки\n");
    }
}

// Переход в запрет поездки из охраны через мобильное приложение (BLE)
void AutoTestsModesP2::C2874876_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c2874875) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние автомобиля:
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в охране
        ||Настройки:
        ||CAN Автомобиль:                      | 9999 (Batmobile)
        ||Настройка CAN штатные кнопки:        | включена (галочка стоит)
        ||Штатные кнопки:                      | прописаны (зарегистрированы)
        ||снятие запрета поездки:              | штатные кнопки
        ||активация запрета поездки:           | при снятии с охраны
        ||подключено:                          | мобильное приложение (через BLE)
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Выключить охрану с помощью мобильного приложения (через BLE)
    */
    /*!
        Система перешла в запрет поездки
        Приложение (сервер) не сообщает об ошибке
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  MOBILE,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Система перешла в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в запрет поездки\n");
    }
}

// Переход в авторизацию владельца из охраны через мобильное приложение (сервер)
void AutoTestsModesP2::C2874877_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        ||зажигание:                           | выключено
        ||обороты:                             | выключены
        ||автомобиль:                          | в охране
        ||метка:                               | выключена
        ||авторизация владельца:               | метка
        ||требовать авторизацию при снятии:    | starline-online.ru или мобильное приложение
        ||подключено:                          | мобильное приложение (через сервер)
    */

    /*!
        Выключить охрану с помощью мобильного приложения (через сервер)
    */
    /*!
        Система перешла в авторизацию владельца
        Приложение (сервер) не сообщает об ошибке
    */
}

// Тревога с окончанием по Штатной тревоге (тревога штатки)
void AutoTestsModesP2::C2898585_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные условия\n");
        result = false;
    }

    /*!
        Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */

    /*!
        Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */
    if (result)
    {
        if (!setAndCheckStdAlarm(ALARM_CHECK_TYPE_START))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Тревога по Штатной тревоге (тревога штатки)
void AutoTestsModesP2::C2898586_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные условия\n");
        result = false;
    }

    /*!
        Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        через 5 сек:
        включена сирена
        включены периодические световые сигналы
        через 30 сек:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        включена охрана
    */
    if (result)
    {
        if (!setAndCheckStdAlarm(ALARM_CHECK_TYPE_FULL))
        {
            // В тесте всего 1 шаг, но метод содержит проверки на 2 шага
            // Первый шаг: все согласно описанию (задано параметром ALARM_CHECK_TYPE_FULL)
            // Второй шаг: посылаем пакет на выключение штатной тревоги и проверяем, что тревога не возобновилась
            printf("FAIL Шаг 1-2\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Цикл тревоги с окончанием по Штатной тревоге (тревога штатки)
void AutoTestsModesP2::C2898587_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные услвоия\n");
        result = false;
    }

    /*!
        Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        через 5 сек:
        включена сирена
        включены периодические световые сигналы
    */

    /*!
        Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после второго включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */
    if (result)
    {
        if (!setAndCheckStdAlarm(ALARM_CHECK_TYPE_HALF))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Игнорирование тревоги по Штатной тревоге (тревога штатки) после 8 срабатываний и сброс игнорирования перепостановкой в охрану
void AutoTestsModesP2::C2898588_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные условия\n");
        result = false;
    }

    /*!
        Шаг 1. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */

    /*!
        Шаг 2. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */

    /*!
        Шаг 3. Повторить 7 раз шаги 1,2 
    */
    /*!
        Результаты те же, что и в шагах 1,2
    */

    /*!
        Шаг 4. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включена блокировка
    */

    /*!
        Шаг 5. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения блокировка выключается
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Охрана включена
    */

    /*!
        Шаг 8. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */
    if (result)
    {
        if (!setAndCheckStdAlarmFull(ALARM_CHECK_TYPE_START))
        {
            printf("FAIL Шаг 1-8\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Игнорирование тревоги по Штатной тревоге (тревога штатки) после 8 срабатываний цикла и сброс игнорирования перепостановкой в охрану
void AutoTestsModesP2::C2898589_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные условия\n");
        result = false;
    }

    /*!
        Шаг 1. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        через 5 сек:
        включена сирена
        включены периодические световые сигналы
    */

    /*!
        Шаг 2. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после второго включения Тревоги:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        охрана включена
    */

    /*!
        Шаг 3. Повторить 7 раз шаги 1,2 
    */
    /*!
        Результаты те же, что и в шагах 1,2
    */

    /*!
        Шаг 4. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включена блокировка
    */

    /*!
        Шаг 5. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения блокировка выключается
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Охрана включена
    */

    /*!
        Шаг 8. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */
    if (result)
    {
        if (!setAndCheckStdAlarmFull(ALARM_CHECK_TYPE_HALF))
        {
            printf("FAIL Шаг 1-8\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Игнорирование тревоги по Штатной тревоге (тревога штатки) после 8 срабатываний полного цикла и сброс игнорирования перепостановкой в охрану
void AutoTestsModesP2::C2907768_TestCase()
{
    bool result = true; // Результат прохождения теста


    if (!p_gen6->loadCanFirmware("3732"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c2898585) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!        
        ||автомобиль:                                     | в охране
        ||зоны охраны:                                    | не нарушены
        ||CAN-автомобиль:                                 | 3732/3733 - Mercedes CLA C117
        ||Скорость передачи данных по CAN:                | 125
        ||Сигналы состояния CAN: Тревога штатной системы  | вкл
        ||Оповещение по тревоге:                          | М1 - звонок и СМС
    */
    if (!setCarMercedesClaAndSecure())
    {
        printf("FAIL Начальные условия\n");
        result = false;
    }

    /*!
        Шаг 1. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
        через 30 сек после включения Тревоги:
        выключение сирены
        выключение световых сигналов
        через 5 сек:
        включена сирена
        включены периодические световые сигналы
        через 30 сек:
        выключение сирены
        выключение световых сигналов
        выключение блокировки
        включена охрана
    */

    /*!
        Шаг 2. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        нет изменений
    */

    /*!
        Шаг 3. Повторить 7 раз шаги 1,2 
    */
    /*!
        Результаты те же, что и в шагах 1,2
    */

    /*!
        Шаг 4. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включена блокировка
    */

    /*!
        Шаг 5. Отправить по CAN пакет "C SFF 141 8 00 00 00 00 00 00 00 00" соответствующий выключению штатной тревоги
    */
    /*!
        через 30 сек после включения блокировка выключается
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Охрана включена
    */

    /*!
        Шаг 8. Отправить по CAN пакет "C SFF 141 8 00 02 00 00 00 00 00 00" соответствующий включению штатной тревоги
    */
    /*!
        включилась тревога
        включена сирена
        включены периодические световые сигналы
        включена блокировка
        СМС-оповещение и звонок на телефон о тревоге
    */
    if (result)
    {
        if (!setAndCheckStdAlarmFull(ALARM_CHECK_TYPE_FULL))
        {
            printf("FAIL Шаг 1-8\n");
        }
    }

    // Сброс настроек CAN и ACK-лки и выключение штатной тревоги
    setStdAlertOffAndCarBatmobile();
}

// Удачный запуск двигателя после АО по метке
void AutoTestsModesP2::C2907769_TestCase()
{
    // Для кейсов нужна метка или брелок
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        && (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c2907769)
        ||  settings_check(p_c2907769) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||зажигание:                              | выключено
        ||обороты:                                | выключены
        ||автомобиль:                             | в снято
        ||метка:                                  | включена
        ||Настройки стенда:
        ||антиограбление при пропадении метки:    | включено
        ||Паркинг:                                | отключен
        ||КПП:                                    | МКПП
        ||система запуска:                        | замок зажигания
        ||обходчик:                               | CAN/LIN
        ||поддержка зажигания:                    | по ручнику
        ||детектирование ПН:                      | по постановке в охрану
        ||Запрещать запуск двигателя по CAN:      | охрана, авторизация, запрет поездки
        ||АО1: время до поиска метки:             | 10 сек
        ||АО2: время поиска метки:                | 5 сек
        ||АО3: предупреждение звукоизвещателем:   | 5 сек
        ||АО4: предупреждение сиреной:            | 5 сек
    */
    p_gen6->setRpm(RPM_OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    p_gen6->setSecure(ON, KEYRING); // Постановка перед снятием, т.к. перед тестом могло быть экстренное снятие кодом
                                    // Из-за чего отключаются защитные функции на 1 цикл охраны

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }
    else
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Включить зажигание и обороты
    */
    /*!
        Зажигание включено
        Двигатель заведен
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }

    p_gen6->setRpm(RPM_ON, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Двигатель не заведен\n");
        return;
    }

    /*!
        Шаг 2. Выключить зажигание и обороты
    */
    /*!
        Зажигание выключено
        Двигатель заглушен
    */
    p_gen6->wait_s(TIME_DELAY::AFTER_RUN_ENGINE_TIME_S); // Чтобы не сразу глушить двигатель после включения
    p_gen6->setRpm(RPM_OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 2. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Двигатель не заглушен\n");
        return;
    }

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */
    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_STOP_ENGINE_TIME_S); // Чтобы не включать зажигание сразу после выключения

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 3. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 3. Зажигание не включено\n");
        return;
    }

    /*!
        Шаг 4. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 4. Дверь открыта\n");
    }
    else
    {
        printf("PASS Шаг 4. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 5. Выключить метку
    */
    /*!
        Метка потеряна
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }
    else
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 6. Вызвать срабатывание датчика движения
    */
    /*!
        Сработал датчик движения
        Через 15 сек включилось АО по метке
        Включился звукоизвещатель
        Через 5 сек выключился звукоизвещатель
        Включилась сирена
        Через 5 сек включилась тревога
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 6\n");
        return;
    }

    /*!
        Шаг 7. Включить метку
    */
    /*!
        Метка найдена
        Антиограбление выключено
        Тревога выключена
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->setTagVcc();
    }
    else if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(ON);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               OFF,
                               TIME_DELAY::MAX_AHJ_DIS_TIME_S))
    {
        printf("PASS Шаг 7. Тревога выключена\n");
    }
    else
    {
        printf("FAIL Шаг 7. Тревога не выключена\n");
        return;
    }

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Шаг 7. Антиограбление выключено\n");
    }
    else
    {
        printf("FAIL Шаг 7. Антиограбление не выключено\n");
        return;
    }

    /*!
        Шаг 8. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 8. Зажигание отключено\n");
    }
    else
    {
        printf("FAIL Шаг 8. Зажигание не отключено\n");
        return;
    }

    /*!
        Шаг 9. Включить зажигание и обороты (!)
    */
    /*!
        Зажигание включено
        Двигатель заведен (!)
    */
    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_STOP_ENGINE_TIME_S); // Чтобы не включать зажигание сразу после выключения

    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 9. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 9. Зажигание не включено\n");
        return;
    }

    p_gen6->setRpm(RPM_ON, PIN);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 9. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 9. Двигатель не заведен\n");
        return;
    }

    /*!
        Шаг 10. Включить ручник
    */
    /*!
        Ручник включен
        ПЗ включена
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 10. Ручник включен\n");
    }
    else
    {
        printf("FAIL Шаг 10. Ручник не включен\n");
        return;
    }

    p_gen6->checkSupIgn(IGN_NOT_OFF, ON);

    /*!
        Шаг 11. Выключить зажигание
    */
    /*!
        Двигатель работает
        ПЗ активна
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 11. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 11. Зажигание не выключено\n");
        return;
    }

    p_gen6->checkSupIgn(IGN_NOT_OFF, ON);

    /*!
        Шаг 12. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 12. Дверь открыта\n");
    }
    else
    {
        printf("PASS Шаг 12. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 13. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 13. Дверь закрыта\n");
    }
    else
    {
        printf("PASS Шаг 13. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 14. Включить охрану
    */
    /*!
        Охрана включена
        ПЗ выключена
        Двигатель заглушен
        ПН выполнена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 14. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Шаг 14. Автомобиль не в охране\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 14. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 14. Двигатель не заглушен\n");
        return;
    }

    p_gen6->setRpm(RPM_OFF, PIN); // Чтобы выполнить ДЗ, иначе будет неудачное из-за наличия оборотов до включения стартера
    p_gen6->checkSupIgn(IGN_NOT_OFF, OFF);
    p_gen6->checkProgramNeutral(ON);
    p_gen6->wait_s(TIME_DELAY::MAX_DELAY_AFTER_PROGRAM_NEUTRAL_S);

    /*!
        Шаг 15. Произвести ДЗ (!)
    */
    /*!
        Двигатель начал заводится (!)
        Подача потенциала на модуль обхода (!)
        Включение CAN-обходчика (пакеты) (!)
        Подача потенциала на АСС
        Подача потенциала на зажигание
        Подача потенциала на стартер
    */
    p_gen6->setRemoteRun(KEYRING, TIME_DELAY::NULL_DELAY_S);

    if (!waitImmoAnalogAndCan())
    {
        printf("FAIL Шаг 15\n");
        return;
    }

    /*!
        Шаг 16. Включить обороты
    */
    /*!
        Двигатель заведен
        Стартер отключен
    */
    p_gen6->checkEngine(m_engine_start_system, TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 16. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 16. Двигатель не заведен\n");
    }
}

// Постановка в охрану без нарушения периметра
void AutoTestsModesP2::C172464_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану любым способом без нарушения периметра
    */
    /*!
        Система встала в охрану
        Замок капота закрылся
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Постановка в охрану с нарушенным периметром (не капот)
void AutoTestsModesP2::C172466_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану любым способом с нарушением периметра (не капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замок капота закрылся
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
}

// Постановка в охрану с нарушенным периметром (капот)
void AutoTestsModesP2::C172467_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану любым способом с нарушением периметра (капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замком не управляем
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замком не управляем\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
}

// Закрыли капот (в охране с нарушенным периметром по капоту)
void AutoTestsModesP2::C172468_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Капот открыт
        Автомобиль в охране с нарушенным периметром
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Начальные условия. Капот открыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не открыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Закрыли капот (охрана с нарушением периметра)
    */
    /*!
        Система осталась в охране
        Замок капота закрылся
    */
    p_gen6->setHood(CLOSE, PIN);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD))
    {
        printf("PASS Шаг 1. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не закрыт\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система осталась в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в охране\n");
    }
}

// Снятие с охраны
void AutoTestsModesP2::C172469_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))    
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снятие с охраны
    */
    /*!
        Система снялась с охраны
        Замок капота открывается
    */
    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открывается\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Система снялась с охраны\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не снялась с охраны\n");
    }
}

// Тревога (не по капоту)
void AutoTestsModesP2::C172470_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))    
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Тревога (не по капоту)
    */
    /*!
        После окончания тревоги:
        - Система в охране
        - Замок капота НЕ закрылся.
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    wait(TIME_DELAY::ONE_MINUTE);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота НЕ закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 OFF,
                                 TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 1. Система вышла из тревоги (таймаут)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не вышла из тревоги\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не в охране\n");
    }
}

// Тревога (по капоту, капот остался открыт)
void AutoTestsModesP2::C172471_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))    
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Тревога (по капоту, капот остался открыт)
    */
    /*!
        После окончания тревоги:
        - Система встала в охрану с нарушенным периметром.
        - Замком не управляем.
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    wait(TIME_DELAY::ONE_MINUTE);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замком капота не управляем\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло управление замком капота\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN,
                                 OFF,
                                 TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 1. Система вышла из тревоги (таймаут)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не вышла из тревоги\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// 8. Тревога (по капоту, капот закрылся)
void AutoTestsModesP2::C172472_TestCase()
{
    Timer          alert_timer;                                                         // Таймер, отсчитывает время с момента начала тревоги

    const float    no_lock_signal_wait_time_s =   TIME_DELAY::R6_HOOD_DIS_TIME_S        // Время для проверки, что сигнал закрытия капота отсутствует
                                                - TIME_DELAY::R6_HOOD_ERROR_TIME_S;

    const float    lock_signal_wait_time_s    =   TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S // Время для проверки, что сигнал закрытия капота появился
                                                - no_lock_signal_wait_time_s;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Открыть капот
    */
    /*!
        Капот открыт
        Включилась тревога
    */
    p_gen6->setHood(OPEN,
                    PIN,
                    TIME_DELAY::NULL_DELAY_S);  
    alert_timer.start();

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD,
                                 ON,
                                 TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 1. Включилась тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включилась\n");
        return;
    }

    /*!
        Закрыть капот
    */
    /*!
        Капот закрыт
        Через 5 сек замок капота закрылся
        После окончания тревоги:
        - Система встала в охрану
    */
    p_gen6->setHood(CLOSE,
                    PIN,
                    TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE,
                                    RELAY_NULL_PULSE,
                                    no_lock_signal_wait_time_s))
    {
        printf("PASS Шаг 2. Замок капота не закрылся раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 2. Замок капота закрылся раньше времени или получен сигнал открытия\n");
        return;
    }

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE,
                                    RELAY_NULL_PULSE,
                                    lock_signal_wait_time_s))
    {
        printf("PASS Шаг 2. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 2. Замок капота не закрылся или получен сигнал открытия\n");
        return;
    }

    alert_timer.stop();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::ALARM_DIS_TIME_S - TIME_DELAY::ALARM_DIS_ERROR_TIME_S - alert_timer.read()))
    {
        printf("PASS Шаг 2. Тревога не выключена раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога выключилась раньше времени\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::ALARM_DIS_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Система встала в охрану после окончания тревоги\n");
    }
    else
    {
        printf("FAIL Шаг 2. Система не встала в охрану после окончания тревоги\n");
    }
}

// Постановка в охрану (охрана уже включена)
void AutoTestsModesP2::C1662249_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))    
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану любым способом без нарушения периметра
    */
    /*!
        Система остается в охране
        Импульс на закрытие Замка капота отсутствует
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Импульс на закрытие Замка капота отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Автомобиль не в охране\n");
    }
}

// Постановка в охрану без нарушения периметра
void AutoTestsModesP2::C1662256_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662256) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен аналоговый Slave
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (аналоговый Slave) без нарушения периметра
    */
    /*!
        Система встала в охрану
        Замок капота закрылся
    */
    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Постановка в охрану с нарушенным периметром (не капот)
void AutoTestsModesP2::C1662257_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662256) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен аналоговый Slave
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (аналоговый Slave) с нарушением периметра (не капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замок капота закрылся
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Постановка в охрану с нарушенным периметром (капот)
void AutoTestsModesP2::C1662258_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662256) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен аналоговый Slave
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (аналоговый Slave) с нарушением периметра (капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замком не управляем
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замком не управляем\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло управление замком капота\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Снятие с охраны
void AutoTestsModesP2::C1662259_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662256) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен аналоговый Slave
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))     
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снятие с охраны штаткой (аналоговый Slave)
    */
    /*!
        Система снялась с охраны
        Замок капота открывается
    */
    p_gen6->sendAnalogSlaveStatus(OFF,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открывается\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Система снялась с охраны\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не снялась с охраны\n");
    }
}

// Постановка в охрану (охрана уже включена)
void AutoTestsModesP2::C1662260_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662256) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен аналоговый Slave
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))     
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (аналоговый Slave) без нарушения периметра
    */
    /*!
        Система остается в охране
        Импульс на закрытие Замка капота отсутствует
    */
    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Импульс на закрытие Замка капота отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Присутствует импульс на закрытие Замка капота\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система остается в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не осталась в охране\n");
    }
}

// Постановка в охрану без нарушения периметра
void AutoTestsModesP2::C1662261_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662261) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен Slave по CAN
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (Slave по CAN) без нарушения периметра
    */
    /*!
        Система встала в охрану
        Замок капота закрылся
    */
    p_gen6->setSecure(ON,
                      STD,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Замок капота не закрылся\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Постановка в охрану с нарушенным периметром (не капот)
void AutoTestsModesP2::C1662262_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662261) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен Slave по CAN
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (Slave по CAN) с нарушением периметра (не капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замок капота закрылся
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    p_gen6->setSecure(ON,
                      STD,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Постановка в охрану с нарушенным периметром (капот)
void AutoTestsModesP2::C1662263_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662261) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен Slave по CAN
        Зажигание выключено (двигатель выключен)
        Автомобиль не в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль в охране\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (Slave по CAN) с нарушением периметра (капот)
    */
    /*!
        Система встала в охрану с нарушенным периметром
        Замком не управляем
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->setSecure(ON,
                      STD,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замком не управляем\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошло управление замком капота\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система встала в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не встала в охрану\n");
    }
}

// Снятие с охраны
void AutoTestsModesP2::C1662264_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662261) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен Slave по CAN
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снятие с охраны штаткой (Slave по CAN)
    */
    /*!
        Система снялась с охраны
        Замок капота открывается
    */
    p_gen6->setSecure(OFF,
                      STD,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открывается\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Система снялась с охраны\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не снялась с охраны\n");
    }
}

// Постановка в охрану (охрана уже включена)
void AutoTestsModesP2::C1662265_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c1662261) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Настроен Slave по CAN
        Зажигание выключено (двигатель выключен)
        Автомобиль в охране
        Капот закрыт
    */
    p_gen6->setEngine(OFF, PIN);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено (двигатель выключен)\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Постановка в охрану штаткой (Slave по CAN) без нарушения периметра
    */
    /*!
        Система остается в охране
        Импульс на закрытие Замка капота отсутствует
    */
    p_gen6->setSecure(ON,
                      STD,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Импульс на закрытие Замка капота отсутствует\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Система остается в охране\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система снята с охраны\n");
    }
}

// Закрывание капота в Снято
void AutoTestsModesP2::C169588_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169588) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:       не настроен
        Передавать статус концевика капота в R6: галочка не стоит
        Охрана выключена
        Капот открыт
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Начальные условия. Капот открыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не открыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Закрыть капот
    */
    /*!
        Капот закрыт
        Замок капота не закрылся
    */
    p_gen6->setHood(CLOSE, PIN);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота не закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD))
    {
        printf("PASS Шаг 1. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не закрыт\n");
    }
}

// Закрывание капота в Охране
void AutoTestsModesP2::C169589_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169588) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:       не настроен
        Передавать статус концевика капота в R6: галочка не стоит
        Капот открыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Начальные условия. Капот открыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не открыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Закрыть капот
    */
    /*!
        Капот закрыт
        Замок капота закрылся
    */
    p_gen6->setHood(CLOSE, PIN);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD))
    {
        printf("PASS Шаг 1. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не закрыт\n");
    }
}

// Включение блокировки при тревоге
void AutoTestsModesP2::C169590_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169588) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:       не настроен
        Передавать статус концевика капота в R6: галочка не стоит
        Капот закрыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Открыть капот
    */
    /*!
        Капот открыт
        Тревога
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON, TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    /*!
        Закрыть капот
    */
    /*!
        Капот закрыт
        Замок капота закрылся
    */
    p_gen6->setHood(CLOSE, PIN);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                 SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                 DIAG_PERIM_BIT_HOOD))
    {
        printf("PASS Шаг 1. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не закрыт\n");
    }
}

// Выключная сирена
void AutoTestsModesP2::C169591_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169591) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:                  не настроен
        Передавать статус концевика капота в R6:            галочка не стоит
        Управление выходом на сирену подкапотного блока R6: Не управлять
        Капот закрыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Открыть капот
    */
    /*!
        Тревога
        Выход сирены R6 не активировался
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON, TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (!p_gen6->waitR6Alarm())
    {
        printf("PASS Шаг 1. Выход сирены R6 не активировался\n");
    }
    else
    {
        printf("FAIL Шаг 1. Выход сирены R6 активировался\n");
    }
}

// Включение Сирены
void AutoTestsModesP2::C169592_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169592) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:                  не настроен
        Передавать статус концевика капота в R6:            галочка не стоит
        Управление выходом на сирену подкапотного блока R6: Сирена
        Капот закрыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Открыть капот
    */
    /*!
        Тревога
        Выход сирены R6 активировался
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON, TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (p_gen6->waitR6Alarm())
    {
        printf("PASS Шаг 1. Выход сирены R6 активировался\n");
    }
    else
    {
        printf("FAIL Шаг 1. Выход сирены R6 не активировался\n");
    }
}

// Включение Клаксона
void AutoTestsModesP2::C169593_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169593) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота:                  не настроен
        Передавать статус концевика капота в R6:            галочка не стоит
        Управление выходом на сирену подкапотного блока R6: Клаксон
        Капот закрыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Открыть капот
    */
    /*!
        Тревога
        Выход сирены R6 активировался
    */
    if (p_gen6->setAndCheckHood(OPEN, PIN))
    {
        printf("PASS Шаг 1. Капот открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Капот не открыт\n");
        return;
    }

    p_gen6->checkAlarm(ON, TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S);

    if (p_gen6->waitR6Alarm(R6_KLAXON))
    {
        printf("PASS Шаг 1. Выход сирены R6 активировался\n");
    }
    else
    {
        printf("FAIL Шаг 1. Выход сирены R6 не активировался\n");
    }
}

// Включение охраны без концевика капота
void AutoTestsModesP2::C169594_TestCase()
{
    // Потерял актуальность: FB-1482

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169594) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: не настроен
        Передавать статус капота в R6:     галочка стоит
        Охрана выключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Поставить в охрану
    */
    /*!
        Охрана включена
        Замок капота не закрылся
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);


    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота не закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
    }
}

// Включение охраны с концевиком подключенным к R6
void AutoTestsModesP2::C169595_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169588) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: не настроен
        Передавать статус капота в R6:     галочка не стоит
        Охрана выключена
        Капот закрыт
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Поставить в охрану
    */
    /*!
        Охрана включена
        Замок капота закрылся
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
    }
}

// Включение охраны с концевиком подключенным к основному блоку
void AutoTestsModesP2::C169596_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: настроен
        Передавать статус капота в R6:     галочка стоит
        Охрана выключена
        Капот закрыт
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Поставить в охрану
    */
    /*!
        Охрана включена
        Замок капота закрылся
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_ONE_PULSE, RELAY_NULL_PULSE))
    {
        printf("PASS Шаг 1. Замок капота закрылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Замок капота не закрылся\n");
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
    }
}

// Выключение охраны без концевика капота
void AutoTestsModesP2::C169597_TestCase()
{
    // Потерял актуальность: FB-1482

    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169594) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: не настроен
        Передавать статус капота в R6:     галочка стоит
        Охрана включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снять с охраны
    */
    /*!
        Охрана выключена
        Замок капота открылся
    */
    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не выключена\n");
    }
}

// Выключение охраны с концевиком подключенным к R6
void AutoTestsModesP2::C169598_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c169588) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: не настроен
        Передавать статус капота в R6:     галочка не стоит
        Капот закрыт
        Охрана включена
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снять с охраны
    */
    /*!
        Охрана выключена
        Замок капота открылся
    */
    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не выключена\n");
    }
}

// Выключение охраны с концевиком подключенным к основному блоку
void AutoTestsModesP2::C169599_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c172464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Канал Концевой выключатель капота: настроен
        Передавать статус капота в R6:     галочка стоит
        Охрана выключена
        Капот закрыт
    */
    if (p_gen6->setAndCheckHood(CLOSE, PIN))
    {
        printf("PASS Начальные условия. Капот закрыт\n");
    }
    else
    {
        printf("FAIL Начальные условия. Капот не закрыт\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))   
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Задержка нужна чтобы не поймать импульс R6
                                                 // из-за охраны в начальных условиях

    /*!
        Снять с охраны
    */
    /*!
        Охрана выключена
        Замок капота открылся
    */
    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (p_gen6->waitR6LockAndUnlock(RELAY_NULL_PULSE, RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. Замок капота открылся\n");
    }
    else
    {
        printf("FAIL Шаг 1. Несоответствие количества импульсов открытия/закрытия замка капота ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не выключена\n");
    }
}

// Неудачное включение опасной парковки из-за не прописанных кнопок
void AutoTestsModesP2::C3052200_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        
        ||Код штатных кнопок автомобиля  | не задан
        ||Охрана                         | выключена
    */

    /*!
        2 раза нажать сервисную кнопку
    */
    /*!
        Подтверждения нажатий вспышками светодиода
    */

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Индикация ошибки светодиодом (длительная вспышка)
        Индикация ошибки поворотниками (длительная вспышка одновременно с светодиодом)
        Опасная парковка не включена
    */
}

// Включение опасной парковки
void AutoTestsModesP2::C3052201_TestCase()
{
    bool is_fail = false;


    if (settings_check(p_c3052203) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        
        ||Код штатных кнопок автомобиля  | задан
        ||Охрана                         | выключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        wait(TIME_DELAY::MAX_WAIT_CL_SIGNALS_S); // Ожидание, пока пройдут сигналы света/сирены от постановки в охрану
    }

    /*!
        2 раза нажать сервисную кнопку
    */
    /*!
        Подтверждения нажатий вспышками светодиода
    */
    if (!is_fail)
    {
        p_gen6->clickServiceBtn(COUNT_STRUCT::BTN_MODE_DANGER_PARKING_CLICKS_COUNT);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Подтверждение выполнения команды вспышками светодиода (2 вспышки)
        Подтверждение выполнения сиреной (2 сигнала одновременно со светодиодом)
        Опасная парковка включена
        Подтверждение включения вспышкой сирены и поворотников (одновременно)
        Подтверждение включения вспышкой светодиода (1 вспышки)
    */
    if (!is_fail)
    {
        p_gen6->setIgn(PIN,
                       ON,
                       TIME_DELAY::NULL_DELAY_S);

        if (p_gen6->checkDangerParkingSignals(ON))
        {
            printf("PASS Шаг 2. Подтверждение включения режима \"Опасная парковка\" получено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Подтверждение включения режима \"Опасная парковка\" не получено\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_ON);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек\n");
    }
}

// Выключение опасной парковки
void AutoTestsModesP2::C3052202_TestCase()
{
    bool is_fail = false;


    if (settings_check(p_c3052203) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
    */
    if (p_gen6->setAndCheckDangerParking(ON))
    {
        printf("PASS Начальные условия. \"Опасная парковка\" включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. \"Опасная парковка\" не включена\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        wait(TIME_DELAY::MAX_WAIT_CL_SIGNALS_S); // Ожидание, пока пройдут сигналы света/сирены от включения ОП
    }

    /*!
        2 раза нажать сервисную кнопку
    */
    /*!
        Подтверждения нажатий вспышками светодиода
    */
    if (!is_fail)
    {
        p_gen6->clickServiceBtn(COUNT_STRUCT::BTN_MODE_DANGER_PARKING_CLICKS_COUNT);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Подтверждение выполнения вспышками светодиода (2 вспышки)
        Подтверждение выполнения сиреной (2 сигнала одновременно со светодиодом)
        Опасная парковка выключена
        Подтверждение выключения 2мя вспышками сирены и поворотников (по 2 вспышки на сирену и поворотники)
        Подтверждение выключения 2мя вспышками светодиода (2 вспышки одновременно с сиреной и поворотниками)
    */
    if (!is_fail)
    {
        p_gen6->setIgn(PIN,
                       ON,
                       TIME_DELAY::NULL_DELAY_S);

        if (p_gen6->checkDangerParkingSignals(OFF))
        {
            printf("PASS Шаг 2. Подтверждение выключения режима \"Опасная парковка\" получено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Подтверждение выключения режима \"Опасная парковка\" не получено\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_ON);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек\n");
    }
}

// Выключение запрета поездки (по охране) кодом штатных кнопок в опасной парковке
void AutoTestsModesP2::C3052203_TestCase()
{
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }
    else
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052203) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | включена
        ||Настройки стенда
        ||Запрет поездки                 | при снятии с охраны
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
    }

    if (p_gen6->setAndCheckDangerParking(ON))
    {
        printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  execution_method,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Система в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в охране\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в запрет поездки\n");
        return;
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }

    /*!
        Ввести код штатными кнопками автомобиля
    */
    /*!
        Запрет поездки отключен
    */
    p_gen6->sendValidatorCode();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 3. Запрет поездки отключен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Запрет поездки не отключен\n");
    }
}

// Неудачное выключение запрета поездки (по охране) меткой в опасной парковке
void AutoTestsModesP2::C3052204_TestCase()
{
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
        {
            execution_method = KEYRING;
        }
        else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
        {
            execution_method = SMS;
        }
    }

    if (execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052203) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | включена
        ||Настройки стенда
        ||Запрет поездки                 | при снятии с охраны
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    p_gen6->resetTagVcc();

    if (p_gen6->setAndCheckDangerParking(ON))
    {
        printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  execution_method,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Система в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в охране\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в запрет поездки\n");
        return;
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }

    /*!
        Включить метку
    */
    /*!
        Метка включилась
        Запрет поездки не отключился
    */
    p_gen6->setTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                OFF,
                                TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 3. Запрет поездки не отключился\n");
    }
    else
    {
        printf("FAIL Шаг 3. Запрет поездки отключился\n");
    }
}

// Неудачное выключение опасной парковки в запрете поездки (по охране)
void AutoTestsModesP2::C3052205_TestCase()
{
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }
    else
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052203) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | включена
        ||Настройки стенда
        ||Запрет поездки                 | при снятии с охраны
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
    }

    if (p_gen6->setAndCheckDangerParking(ON))
    {
        printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  execution_method,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Система в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система не в охране\n");
        return;
    }

    /*!
        Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Система не перешла в запрет поездки\n");
        return;
    }

    /*!
        2 раза нажать сервисную кнопку
    */
    /*!
        Подтверждения нажатий вспышками светодиода
    */
    for (uint8_t i = 0; i < 2; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Опасная парковка не отключена
        Запрет поездки не отключился
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 3. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 3. Зажигание не включено\n");
        return;
    }

    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                  SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                  DIAG_EEFLAG_SYSDATA::ID_FLAG_DANGER_PARKING,
                                  OFF,
                                  TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 3. Опасная парковка не отключена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Опасная парковка отключилась\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 3. Запрет поездки не отключился\n");
    }
    else
    {
        printf("FAIL Шаг 3. Запрет поездки отключился\n");
    }
}

// Выключение запрета поездки (по зажиганию) кодом штатных кнопок в опасной парковке
void AutoTestsModesP2::C3052206_TestCase()
{
    bool           is_fail          = false;
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }
    else
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052206) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | выключена
        ||Зажигание                      | включено
        ||Настройки стенда
        ||Запрет поездки                 | при выключении зажигания
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Система не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система в охране\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        if (p_gen6->setAndCheckDangerParking(ON))
        {
            printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
        }
        else
        {
            printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Начальные условия. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Начальные условия. Зажигание не включено\n");
            is_fail = true;;
        }
    }

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Включен запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 1. Включен запрет поездки\n");
        }
        else
        {
            printf("FAIL Шаг 1. Не включен запрет поездки\n");
            is_fail = true;
        }
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 2. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не включено\n");
            is_fail = true;
        }
    }

    /*!
        Ввести код штатными кнопками автомобиля
    */
    /*!
        Запрет поездки отключен
    */
    if (!is_fail)
    {
        p_gen6->sendValidatorCode();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 3. Запрет поездки отключен\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки не отключен\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Неудачное выключение запрета поездки (по зажиганию) меткой в опасной парковке
void AutoTestsModesP2::C3052207_TestCase()
{
    bool           is_fail          = false;
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
        {
            execution_method = KEYRING;
        }
        else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
        {
            execution_method = SMS;
        }
    }

    if (execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052206) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | выключена
        ||Зажигание                      | включено
        ||Настройки стенда
        ||Запрет поездки                 | при выключении зажигания
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    p_gen6->resetTagVcc();

    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Система не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система в охране\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        if (p_gen6->setAndCheckDangerParking(ON))
        {
            printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
        }
        else
        {
            printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Начальные условия. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Начальные условия. Зажигание не включено\n");
            is_fail = true;
        }
    }

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Включен запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 1. Включен запрет поездки\n");
        }
        else
        {
            printf("FAIL Шаг 1. Не включен запрет поездки\n");
            is_fail = true;
        }
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 2. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не включено\n");
            is_fail = true;
        }
    }

    /*!
        Включить метку
    */
    /*!
        Метка включилась
        Запрет поездки не отключился
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                    ON,
                                    TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 3. Запрет поездки не отключился\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки отключился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Неудачное выключение опасной парковки в запрете поездки (по зажиганию)
void AutoTestsModesP2::C3052208_TestCase()
{
    bool           is_fail          = false;
    command_type_t execution_method = ERROR_TYPE; // Способ управления охраной (если управлять меткой, то запрет поездки снимется)


    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }
    else
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3052206) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда
        ||Код штатных кнопок автомобиля  | задан
        ||Опасная парковка               | включена (комплекс находится в режиме ОП)
        ||Метка                          | выключена
        ||Охрана                         | выключена
        ||Зажигание                      | включено
        ||Настройки стенда
        ||Запрет поездки                 | при выключении зажигания
        ||Снятие запрета поездки         | метка и штатные кнопки
    */
    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  execution_method,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Система не в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Система в охране\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        // система не успевает среагировать сразу после снятия с охраны
        wait(TIME_DELAY::BEFORE_DANGER_PARKING_EN_DELAY_S);

        if (p_gen6->setAndCheckDangerParking(ON))
        {
            printf("PASS Начальные условия. Система в режиме \"Опасная парковка\"\n");
        }
        else
        {
            printf("FAIL Начальные условия. Система не в режиме \"Опасная парковка\"\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Начальные условия. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Начальные условия. Зажигание не включено\n");
            is_fail = true;
        }
    }

    /*!
        Выключить зажигание
    */
    /*!
        Зажигание выключено
        Включен запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 1. Включен запрет поездки\n");
        }
        else
        {
            printf("FAIL Шаг 1. Не включен запрет поездки\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        // Ожидание выключения меню сервисной кнопки
        wait(TIME_DELAY::BTN_CMD_OFF_AFTER_IMMO_DELAY_S);
    }

    /*!
        2 раза нажать сервисную кнопку
    */
    /*!
        Подтверждения нажатий вспышками светодиода
    */
    if (!is_fail)
    {
        p_gen6->clickServiceBtn(COUNT_STRUCT::BTN_MODE_DANGER_PARKING_CLICKS_COUNT);
        wait(TIME_DELAY::STD_WIRE_EN_DELAY_S);
    }

    /*!
        Включить зажигание
    */
    /*!
        Зажигание включено
        Опасная парковка не отключена
        Запрет поездки не отключился
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 3. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не включено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                      SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                      DIAG_EEFLAG_SYSDATA::ID_FLAG_DANGER_PARKING,
                                      OFF,
                                      TIME_DELAY::DANGER_PARKING_EN_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Опасная парковка не отключена\n");
        }
        else
        {
            printf("FAIL Шаг 3. Опасная парковка отключена\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                    ON,
                                    TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 3. Запрет поездки не отключился\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки отключился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Проверка с настройкой "отмена свободных рук двойной командой снятия" (быстрое нажатие)
void AutoTestsModesP2::C2889927_TestCase()
{
    Timer timer;
    float disarm_start_s, // Время, потраченное на снятие с охраны
          disarm_stop_s;
    bool  is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2889927) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        вкл/выкл режима свободные руки: да
        снятие по появлению метки: да
        постановка по пропаданию метки: да
        отключение постановки в охрану до включения зажигания или до командыпостановки в охрану: двойной командой снятия: да
        авторизация: брелк: да
        автомобиль CAN: BatMobile
        управление штатной системой охраны (Slave): да
        зарегистрированный брелок (брелок выключен)
        зарегистрированная метка
        охрана включена
    */
    p_gen6->setLcdKeyringVcc(OFF);

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Началные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        is_fail = true;
    }

    /*!
        Снять систему с охраны Slave'ом (CAN - imitcan)
    */
    /*!
        Сирена издаст два коротких сигнала (без длинного)
        Система перешла в состояние "Ожидание авторизации"
    */
    if (!is_fail)
    {
        p_gen6->setSecure(OFF,
                          CAN_USE,
                          TIME_DELAY::NULL_DELAY_S);

        if (p_gen6->getAlarmSignal(TIME_DELAY::MAX_DISARM_SIGNAL_WAIT_TIME_S) == PULSED)
        {
            printf("PASS Шаг 1. Первый сигнал сирены получен\n");
        }
        else
        {
            printf("FAIL Шаг 1. Первый сигнал сирены не получен после снятия с охраны\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->getAlarmSignal(TIME_DELAY::ONE_S) == PULSED)
        {
            printf("PASS Шаг 1. Второй сигнал сирены получен\n");
        }
        else
        {
            printf("FAIL Шаг 1. Второй сигнал сирены не получен после снятия с охраны\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_WAITING_AUTH,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 1. Система перешла в состояние \"Ожидание авторизации\"\n");
        }
        else
        {
            printf("FAIL Шаг 1. Система не перешла в состояние \"Ожидание авторизации\"\n");
            is_fail = true;
        }
    }

    /*!
        Включить брелок
        Открыть дверь
    */
    /*!
        Сирена звуков не издаст (нет сигналов)
        Переход в состояние "Снято с охраны"
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->setDoor(OPEN, PIN);

        if (p_gen6->getAlarmSignal(TIME_DELAY::TEN_S) == NOSIGNAL)
        {
            printf("PASS Шаг 2. Сигнал сирены не получен\n");
        }
        else
        {
            printf("FAIL Шаг 2. Получен сигнал сирены\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->checkSecure(OFF))
        {
            printf("PASS Шаг 2. Система в \"Снято с охраны\"\n");
        }
        else
        {
            printf("FAIL Шаг 2. Система не в \"Снято с охраны\"\n");
            is_fail = true;
        }
    }

    /*!
        Закрыть дверь
        Включить охрану
    */
    /*!
        Охрана включена
    */
    if (!is_fail)
    {
        p_gen6->setDoor(CLOSE, PIN);

        if (p_gen6->setAndCheckSecure(ON,
                                      KEYRING,
                                      DIAG_GUARD_STATE_ARM))
        {
            printf("PASS Шаг 3. Охрана включена\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана не включена\n");
            is_fail = true;
        }
    }

    /*!
        Выключить брелок
    */
    /*!
        Без изменений
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    OFF,
                                    TIME_DELAY::TEN_S))
        {
            printf("PASS Шаг 4. Система осталась в охране\n");
        }
        else
        {
            printf("FAIL Шаг 4. Система вышла из охраны\n");
            is_fail = true;
        }
    }

    /*!
        Снять систему с охраны Slave'ом (CAN - imitcan)
    */
    /*!
        Сирена издаст два коротких сигнала (без длинного)
        Система перешла в состояние "Ожидание авторизации"
    */
    timer.start();

    if (!is_fail)
    {
        disarm_start_s = timer.read();

        p_gen6->setSecure(OFF,
                          CAN_USE,
                          TIME_DELAY::NULL_DELAY_S);

        if (p_gen6->getAlarmSignal(TIME_DELAY::MAX_DISARM_SIGNAL_WAIT_TIME_S) == PULSED)
        {
            printf("PASS Шаг 5. Первый сигнал сирены получен\n");
        }
        else
        {
            printf("FAIL Шаг 5. Первый сигнал сирены не получен после снятия с охраны\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->getAlarmSignal(TIME_DELAY::ONE_S) == PULSED)
        {
            printf("PASS Шаг 5. Второй сигнал сирены получен\n");
        }
        else
        {
            printf("FAIL Шаг 5. Второй сигнал сирены не получен после снятия с охраны\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_WAITING_AUTH,
                                   ON,
                                   TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
        {
            printf("PASS Шаг 5. Система перешла в состояние \"Ожидание авторизации\"\n");
        }
        else
        {
            printf("FAIL Шаг 5. Система не перешла в состояние \"Ожидание авторизации\"\n");
            is_fail = true;
        }

        disarm_stop_s = timer.read();
    }

    timer.stop();

    /*!
        В течение 4 секунд (не позже, чем через 4 секундs) еще раз дать команду снятия Slave'ом
    */
    /*!
        Сирена издаст один длинный сигнал
    */
    if (!is_fail)
    {
        if (disarm_stop_s - disarm_start_s < TIME_DELAY::FOUR_S)
        {
            p_gen6->setSecure(OFF,
                              CAN_USE,
                              TIME_DELAY::NULL_DELAY_S);
            printf("PASS Шаг 6. Подача команды снятия в течение 4 секунд\n");
        }
        else
        {
            printf("FAIL Шаг 6. Прошло больше 4 секунд\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->getAlarmSignal(TIME_DELAY::MAX_DISARM_SIGNAL_WAIT_TIME_S) == NOSIGNAL)
        {
            printf("PASS Шаг 6. Сигнал сирены не получен\n");
        }
        else
        {
            printf("FAIL Шаг 6. Получен сигнал сирены\n");
            is_fail = true;
        }
    }

    /*!
        Включить брелок
        Открыть дверь
    */
    /*!
        Сирена звуков не издаст (нет сигналов)
        Переход в состояние "Снято с охраны"
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->setDoor(OPEN, PIN);

        if (p_gen6->getAlarmSignal(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S) == NOSIGNAL)
        {
            printf("PASS Шаг 7. Сигнал сирены не получен\n");
        }
        else
        {
            printf("FAIL Шаг 7. Получен сигнал сирены\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->checkSecure(OFF))
        {
            printf("PASS Шаг 7. Система в \"Снято с охраны\"\n");
        }
        else
        {
            printf("FAIL Шаг 7. Система не в \"Снято с охраны\"\n");
        }
    }

    if (p_gen6->checkSecure())
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_c2889927_no_hf) == 0)
    {
        printf("INFO Ошибка при загрузке настроек через StarLine master\n");
    }
}

// Запрет поездки/ При каждом выключении зажигания
// Появление метки до включения зажигания
void AutoTestsModesP2::C3136858_TestCase()
{
    bool           is_fail = false;
    command_type_t execution_method; // Метод постановки/снятия охраны (не используя метку)


    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Метка нужна для тестов
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE  // Нужен брелок или gsm модуль для управления охраной без метки
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | выключено
        ||Обороты:                                      | выключены
        ||Автомобиль:                                   | в охране
        ||Метка:                                        | выключена
        ||Настройки:
        ||Снятие запрета поездки:                       | метка
        ||Условие активации запрета поездки:            | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(execution_method,
                                     TAG_OFF))
    {
        printf("FAIL Шаг 1\n");
        is_fail = true;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из Запрет поездки в Снято
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 3. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не включено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 3. Переход из Запрет поездки в Снято\n");
        }
        else
        {
            printf("FAIL Шаг 3. Не выполнен переход из Запрет поездки в Снято\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Появление метки после включения зажигания
void AutoTestsModesP2::C3136859_TestCase()
{
    bool           is_fail = false;
    command_type_t execution_method; // Метод постановки/снятия охраны (не используя метку)


    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Метка нужна для тестов
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE  // Нужен брелок или gsm модуль для управления охраной без метки
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | выключено
        ||Обороты:                                      | выключены
        ||Автомобиль:                                   | в охране
        ||Метка:                                        | выключена
        ||Настройки:
        ||Снятие запрета поездки:                       | метка
        ||Условие активации запрета поездки:            | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(execution_method,
                                     TAG_OFF))
    {
        printf("FAIL Шаг 1\n");
        is_fail = true;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 2. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не включено\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку через 30 сек
    */
    /*!
        Метка найдена
        Переход из Запрет поездки в Снято
    */
    if (!is_fail)
    {
        wait(TIME_DELAY::THIRTY_S);
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из Запрет поездки в Снято\n");
        }
        else
        {
            printf("FAIL Шаг 3. Не выполнен переход из Запрет поездки в Снято\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Появление метки до выключения охраны
void AutoTestsModesP2::C3136860_TestCase()
{
    bool           is_fail = false;
    command_type_t execution_method; // Метод постановки/снятия охраны (не используя метку)


    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Метка нужна для тестов
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE  // Нужен брелок или gsm модуль для управления охраной без метки
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        execution_method = KEYRING;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        execution_method = SMS;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | выключено
        ||Обороты:                                      | выключены
        ||Автомобиль:                                   | в охране
        ||Метка:                                        | включена
        ||Настройки:
        ||Снятие запрета поездки:                       | метка
        ||Условие активации запрета поездки:            | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(execution_method,
                                     TAG_ON))
    {
        printf("FAIL Шаг 1\n");
        is_fail = true;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из Запрет поездки в Снято
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 2. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не включено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 2. Переход из Запрет поездки в Снято\n");
        }
        else
        {
            printf("FAIL Шаг 2. Не выполнен переход из Запрет поездки в Снято\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Сирена на R6 при включении и выключении охраны
void AutoTestsModesP2::C3136861_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль:                                   | в снято
        ||Подключен:                                    | R6
        ||Настройки:
        ||Управление выходом на сирену R6:              | Сирена
    */
    p_gen6->setR6Vcc();

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Автомобиль в \"Снято с охраны\"\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в \"Снято с охраны\"\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Чтобы не поймать импульс R6 из-за начальных условий

    /*!
        Шаг 1. Включить охрану
    */
    /*!
        Охрана включена
        На выход сирены R6 подан однократный импульс (1 импульс)
    */
    p_gen6->setSecure(ON,
                      KEYRING,
                      TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitR6SirenSignals(RELAY_ONE_PULSE))
    {
        printf("PASS Шаг 1. На выход сирены R6 подан однократный импульс (1 импульс)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Количество полученных сигналов сирены R6 не соответствует ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не включена\n");
        return;
    }

    /*!
        Шаг 2. Выключить охрану
    */
    /*!
        Охрана выключена
        На выход сирены R6 подан двукратный импульс (2 импульса)
    */
    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitR6SirenSignals(RELAY_TWO_PULSE))
    {
        printf("PASS Шаг 2. На выход сирены R6 подан двукратный импульс (2 импульса)\n");
    }
    else
    {
        printf("FAIL Шаг 2. Количество полученных сигналов сирены R6 не соответствует ожидаемому\n");
        return;
    }

    if (p_gen6->checkSecure(OFF))
    {
        printf("PASS Шаг 2. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не выключена\n");
    }
}

// Сирена на R6 во время тревоги
void AutoTestsModesP2::C3136862_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль:                                   | в охране
        ||Подключен:                                    | R6
        ||Настройки:
        ||Управление выходом на сирену R6:              | Сирена
    */
    p_gen6->setR6Vcc();

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Автомобиль в охране\n");
    }
    else
    {
        printf("FAIL Начальные условия. Автомобиль не в охране\n");
        return;
    }

    wait(TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S); // Чтобы не поймать импульс R6 из-за начальных условий

    /*!
        Шаг 1. Вызвать тревогу открыв дверь
    */
    /*!
        Дверь открыта
        Включена тревога
        На выход сирены R6 подан потенциал
    */
    p_gen6->setDoor(OPEN,
                    PIN,
                    TIME_DELAY::NULL_DELAY_S);

    if (p_gen6->waitR6SirenPotential(R6_SIREN_ACTIVE))
    {
        printf("PASS Шаг 1. На выход сирены R6 подан потенциал\n");
    }
    else
    {
        printf("FAIL Шаг 1. На выход сирены R6 не подан потенциал\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_DOORS))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    /*!
        Шаг 2. Выключить тревогу однократным нажатием кнопки 2 брелока (или метки если брелок не поддерживается)
    */
    /*!
        Тревога отключена
        Включена охрана с нарушенным периметром
        Потенциал с выхода сирены R6 снят
        На выход сирены R6 подан четырехкратный импульс (4 импульса)
    */
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->pushLedKeyringBut2(KEYRING_SHORT);
    }
    else
    {
        p_gen6->setTagVcc();
        wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        p_gen6->pushTagBtn(TAG_SHORT);
    }

    if (p_gen6->waitR6SirenPotential(R6_SIREN_PASSIVE))
    {
        printf("PASS Шаг 2. Потенциал с выхода сирены R6 снят\n");
    }
    else
    {
        printf("FAIL Шаг 2. Потенциал с выхода сирены R6 не снят\n");
        return;
    }

    if (p_gen6->waitR6SirenSignals(RELAY_FOUR_PULSE))
    {
        printf("PASS Шаг 2. На выход сирены R6 подан четырехкратный импульс (4 импульса)\n");
    }
    else
    {
        printf("FAIL Шаг 2. Количество полученных сигналов сирены R6 не соответствует ожидаемому\n");
        return;
    }

    if (!p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                 SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                 DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога отключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не отключена\n");
        return;
    }

    if (p_gen6->checkSecure(ON))
    {
        printf("PASS Шаг 2. Охрана с нарушенным периметром включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Охрана не включена\n");
    }
}

// Выход из сервиса по расстоянию с включенной меткой и авторизация
void AutoTestsModesP2::C3136863_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136863) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | включено
        ||Обороты:                                      | выключены
        ||Автомобиль в:                                 | Сервисный режим
        ||Метка:                                        | включена
        ||Настройки:
        ||ДД:                                           | Настроен ДД
        ||Авторизация владельца:                        | метка
        ||Настроен CAN-автомобиль:                      | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                     | 0 км/ч
        ||Выход из сервисного режима:                   | по превышению пройденного расстояния
        ||Порог пройденного расстояния:                 | 100 м
        ||Порог скорости:                               | 20 км/ч       
    */
   
    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */

    /*!
        Через 10 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Снято (прошла авторизация по метке)
    */
    if (!setServiceAndSpeedAndSensor(TAG_ON,
                                     40,
                                     TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Выход из сервиса по скорости с включенной меткой и авторизация
void AutoTestsModesP2::C3136864_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136864) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | включено
        ||Обороты:                                      | выключены
        ||Автомобиль в:                                 | Сервисный режим
        ||Метка:                                        | включена
        ||Настройки:
        ||ДД:                                           | Настроен ДД
        ||Авторизация владельца:                        | метка
        ||Настроен CAN-автомобиль:                      | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                     | 0 км/ч
        ||Выход из сервисного режима:                   | по превышению заданной скорости
        ||Порог пройденного расстояния:                 | 500 м
        ||Порог скорости:                               | 15 км/ч       
    */

    /*!
        Включить скорость 16 км/ч
    */
    /*!
        Скорость: 16 км/ч
    */

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Снято (прошла авторизация по метке)
    */
    if (!setServiceAndSpeedAndSensor(TAG_ON,
                                     16,
                                     TIME_DELAY::SIX_S))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Выход из сервиса по расстоянию с выключенной меткой и авторизация
void AutoTestsModesP2::C3136865_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136863) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | включено
        ||Обороты:                                      | выключены
        ||Автомобиль в:                                 | Сервисный режим
        ||Метка:                                        | выключена
        ||Настройки:
        ||ДД:                                           | Настроен ДД
        ||Авторизация владельца:                        | метка
        ||Настроен CAN-автомобиль:                      | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                     | 0 км/ч
        ||Выход из сервисного режима:                   | по превышению пройденного расстояния
        ||Порог пройденного расстояния:                 | 100 м
        ||Порог скорости:                               | 20 км/ч       
    */
   
    /*!
        Включить скорость 40 км/ч
    */
    /*!
        Скорость: 40 км/ч
    */

    /*!
        Через 10 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
    */

    /*!
        Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Ожидания авторизации в Снято (прошла авторизация по метке)
    */
    if (!setServiceAndSpeedAndSensor(TAG_OFF,
                                     40,
                                     TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1-3\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Выход из сервиса по скорости с выключенной меткой и авторизация 
void AutoTestsModesP2::C3136866_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136864) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                    | включено
        ||Обороты:                                      | выключены
        ||Автомобиль в:                                 | Сервисный режим
        ||Метка:                                        | выключена
        ||Настройки:
        ||ДД:                                           | Настроен ДД
        ||Авторизация владельца:                        | метка
        ||Настроен CAN-автомобиль:                      | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                     | 0 км/ч
        ||Выход из сервисного режима:                   | по превышению заданной скорости
        ||Порог пройденного расстояния:                 | 500 м
        ||Порог скорости:                               | 15 км/ч       
    */

    /*!
        Включить скорость 16 км/ч
    */
    /*!
        Скорость: 16 км/ч
    */

    /*!
        Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации
    */

    /*!
        Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Ожидания авторизации в Снято (прошла авторизация по метке)
    */
    if (!setServiceAndSpeedAndSensor(TAG_OFF,
                                     40,
                                     TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1-3\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Отсутствие АО по метке при включенном паркинге
void AutoTestsModesP2::C3186729_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                                              | включено
        ||Обороты:                                                                | выключены
        ||Автомобиль в:                                                           | Снято
        ||Метка:                                                                  | включена
        ||Дверь:                                                                  | закрыта
        ||Паркинг:                                                                | включен
        ||Настройки:
        ||Антиограбление при пропадании метки:                                    | да
        ||Антиограбление, шаг 1: Время до начала поиска метки, сек:               | 10
        ||Антиограбление, шаг 2: Время поиска метки, сек:                         | 5
        ||Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: | 5
        ||Антиограбление, шаг 4: Предупреждение сиреной, сек:                     | 5
        ||ДД:                                                                     | Настроен ДД
    */

    /*!
        Выключить метку
    */
    /*!
        Метка пропала из зоны действия
    */

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
        Не Включен режим "Антиограбление по метке"
    */
}

// Отсутствие АО по брелоку при включенном паркинге
void AutoTestsModesP2::C3186730_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                                              | включено
        ||Обороты:                                                                | выключены
        ||Автомобиль в:                                                           | Снято
        ||Брелок:                                                                 | включен
        ||Дверь:                                                                  | закрыта
        ||Паркинг:                                                                | включен
        ||Настройки:
        ||Антиограбление при пропадании брелока:                                  | да
        ||Антиограбление, шаг 1: Время до начала поиска брелока, сек:             | 10
        ||Антиограбление, шаг 2: Время поиска брелока, сек:                       | 5
        ||Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: | 5
        ||Антиограбление, шаг 4: Предупреждение сиреной, сек:                     | 5
        ||ДД:                                                                     | Настроен ДД
    */

    /*!
        Выключить брелок
    */
    /*!
        Брелок пропал из зоны действия
    */

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
        Не Включен режим "Антиограбление по брелоку"
    */
}

// Включение настройки по BLE и выключение кнопкой
void AutoTestsModesP2::C3202904_TestCase()
{
    bool check_btn_lights = p_gen6->getDeviceName() != GEN6_X96V2; // На X96v2 не проверяется светодиод серв. кнопки


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3202904) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Slave по CAN:         | включен
        ||Slave аналоговый:     | включен
    */

    /*!
        Шаг 1. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Вход в режим настройки по BLE
        Сервисный светодиод начал постоянно моргать
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
    */
    if (!setAndCheckBleSettingsModeOn(check_btn_lights, IGN_OFF))
    {
        printf("FAIL Включение режима настройки по BLE\n");
        return;
    }

    /*!
        Шаг 4. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом
    */
    for (uint8_t i = 0; i < COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT; ++i)
    {
        p_gen6->clickServiceBtn();
        wait(TIME_DELAY::MIN_BTN_BETWEEN_CLICK_S);
    }

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
        9-кратное подтверждение сервисным светодиодом выхода из режима настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Выход из режима настройки по BLE
        Сервисный светодиод перестал постоянно моргать
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 5. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не включено\n");
        return;
    }

    if (check_btn_lights)
    {
        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT,
                                           TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Шаг 5. 9-кратное подтверждение сервисным светодиодом выхода из режима настройки по BLE\n");
        }
        else
        {
            printf("FAIL Шаг 5. Нет 9-кратного подтверждения сервисным светодиодом\n");
            return;
        }

        if (p_gen6->waitServicePulseAmount(COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                           TIME_DELAY::BTN_CMD_SUCCESS_LIGHTS_WAIT_TIME_S))
        {
            printf("PASS Шаг 5. 2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки\n");
        }
        else
        {
            printf("FAIL Шаг 5. Нет 2-кратного подтверждения сервисным светодиодом\n");
            return;
        }
    }
    else
    {
        wait(TIME_DELAY::BTN_MODE_EN_AND_LIGHTS_WAIT_TIME_S);
    }

    if (!checkBleSettingsTestsModeOff(check_btn_lights))
    {
        printf("FAIL Шаг 5\n");
        return;
    }

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание выключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 6. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 6. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 7. Включить охрану с помощью аналогового Slave
    */
    /*!
        Охрана включена
    */
    p_gen6->sendAnalogSlaveStatus(ON,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::ONE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  TIME_DELAY::STD_LOCK_SLAVE_PULSE_S,
                                  SLAVE_LIGHT_LR);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MAX_GUARD_STATE_EN_TIME_S))
    {
        printf("PASS Шаг 7. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 7. Охрана не включена\n");
    }
}

// Включение настройки по BLE и выключение по времени
void AutoTestsModesP2::C3202905_TestCase()
{
    bool  check_btn_lights = p_gen6->getDeviceName() != GEN6_X96V2;                      // На X96v2 не проверяется светодиод серв. кнопки
    float err_time_s       = TIME_DELAY::BLE_MODE_DIS_ERR_TIME_S;                        // Погрешность при ожидании выкл. режима настройки по BLE
    float wait_time_s      = TIME_DELAY::MAX_WAITING_REGION_STATE_S + 2.0f * err_time_s; // Ожидание выкл. режима настройки по BLE (с учетом погрешности после ожидания)


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3202904) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Slave по CAN:         | включен
        ||Slave аналоговый:     | включен
    */

    /*!
        Шаг 1. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Вход в режим настройки по BLE
        Сервисный светодиод начал постоянно моргать
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
    */
    if (!setAndCheckBleSettingsModeOn(check_btn_lights, IGN_OFF))
    {
        printf("FAIL Включение режима настройки по BLE\n");
        return;
    }

    /*!
        Шаг 4. Ожидать 5 мин
    */
    /*!
        Через 5 мин после включения Выход из режима настройки по BLE
        Сервисный светодиод перестал постоянно моргать
    */
    if (!p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                  SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                  DIAG_EEFLAG_SYSDATA::ID_FLAG_BLE_UPDATER,
                                  OFF,
                                  TIME_DELAY::BLE_MODE_DIS_WAIT_TIME_S - err_time_s))
    {
        printf("PASS Шаг 4. В течение 5 минут нет выхода из режима настройки по BLE\n");
    }
    else
    {
        printf("FAIL Шаг 4. Выход из режима настройки по BLE произошел раньше времени\n");
        return;
    }

    if (!checkBleSettingsTestsModeOff(check_btn_lights, wait_time_s))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание выключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 5. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 6. Включить охрану с помощью Slave по CAN
    */
    /*!
        Охрана включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  CAN_USE,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 6. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 6. Охрана не включена\n");
    }
}

// Отсутствие АО по метке при включенной ПЗ
void AutoTestsModesP2::C3357809_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c3357809)
        ||  settings_check(p_c3357809) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                                              | включено
        ||Обороты:                                                                | включены
        ||Автомобиль в:                                                           | Снято
        ||Метка:                                                                  | включена
        ||Дверь:                                                                  | закрыта
        ||Паркинг:                                                                | выключен
        ||Ручник:                                                                 | выключен
        ||Настройки:
        ||КПП:                                                                    | МКПП
        ||Обороты:                                                                | не подтверждены
        ||Время работы ТТ:                                                        | 1 мин
        ||Антиограбление при пропадании метки:                                    | да
        ||Антиограбление, шаг 1: Время до начала поиска метки, сек:               | 10
        ||Антиограбление, шаг 2: Время поиска метки, сек:                         | 5
        ||Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: | 5
        ||Антиограбление, шаг 4: Предупреждение сиреной, сек:                     | 5
        ||ДД:                                                                     | Настроен ДД
    */
    p_gen6->setTagVcc();
    setAhjTestsStartConditions(IGN_ON);
    p_gen6->setEngine(ON, PIN);

    /*!
        Затянуть ручник
    */
    /*!
        Ручник включен
        Включена ПЗ:ТТ
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 1. Ручник включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Ручник не включен\n");
        is_fail = true;
    }

    if (!is_fail)
    {
        p_gen6->wait_s(TIME_DELAY::MIN_WAITING_REGION_STATE_S); // Ожидание ПЗ в регионе
        p_gen6->checkSupportIgn(ON);
        p_gen6->checkTurboTimer(ON);
    }

    /*!
        Выключить метку
    */
    /*!
        Метка пропала из зоны действия
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckDoor(ON, PIN))
        {
            printf("PASS Шаг 3. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 3. Дверь не открыта\n");
            is_fail = true;;
        }
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
        Не Включен режим "Антиограбление по метке"
    */
    if (!is_fail)
    {
        p_gen6->setMoveSensor();

        if (!p_gen6->waitLightAndAlarm(TimeoutCalculator::calcTimeWithError(m_ahj_steps_one_and_two_time_s + m_ahj_step_three_time_s)))
        {
            printf("PASS Шаг 4. Предупредительные сигналы не получены\n");
        }
        else
        {
            printf("FAIL Шаг 4. Предупредительные сигналы получены\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        p_gen6->checkAlarm(OFF, TimeoutCalculator::calcTimeWithError(m_ahj_step_four_time_s));

        if (!p_gen6->getSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                     SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                     DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK))
        {
            printf("PASS Шаг 4. Не включен режим \"Антиограбление по метке\"\n");
        }
        else
        {
            printf("FAIL Шаг 4. Включен режим \"Антиограбление по метке\"\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }
}

// Отсутствие АО по брелоку включенной ПЗ
void AutoTestsModesP2::C3357810_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c3357810)
        ||  settings_check(p_c3357810) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Зажигание:                                                              | включено
        ||Обороты:                                                                | включены
        ||Автомобиль в:                                                           | Снято
        ||Брелок:                                                                 | включен
        ||Дверь:                                                                  | закрыта
        ||Паркинг:                                                                | выключен
        ||Ручник:                                                                 | выключен
        ||Настройки:
        ||КПП:                                                                    | МКПП
        ||Обороты:                                                                | не подтверждены
        ||Время работы ТТ:                                                        | 1 мин
        ||Антиограбление при пропадании брелока:                                  | да
        ||Антиограбление, шаг 1: Время до начала поиска брелока, сек:             | 10
        ||Антиограбление, шаг 2: Время поиска брелока, сек:                       | 5
        ||Антиограбление, шаг 3: Предупреждение встроенным звукоизлучателем, сек: | 5
        ||Антиограбление, шаг 4: Предупреждение сиреной, сек:                     | 5
        ||ДД:                                                                     | Настроен ДД
    */
    setAhjTestsStartConditions(IGN_ON);
    p_gen6->setEngine(ON, PIN);

    /*!
        Затянуть ручник
    */
    /*!
        Ручник включен
        Включена ПЗ:ТТ
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckHandBreak(ON, PIN))
        {
            printf("PASS Шаг 1. Ручник включен\n");
        }
        else
        {
            printf("FAIL Шаг 1. Ручник не включен\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        p_gen6->wait_s(TIME_DELAY::MIN_WAITING_REGION_STATE_S); // Ожидание ПЗ в регионе
        p_gen6->checkSupportIgn(ON);
        p_gen6->checkTurboTimer(ON);
    }

    /*!
        Выключить брелок
    */
    /*!
        Брелок пропал из зоны действия
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckDoor(ON, PIN))
        {
            printf("PASS Шаг 3. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 3. Дверь не открыта\n");
            is_fail = true;
        }
    }

    /*!
        Переместить блок
    */
    /*!
        Сработал датчик движения
        через 15 сек:
        не включен внутренний звукоизлучатель
        через 5 сек:
        не включено предупреждение световыми сигналами
        через 5 сек:
        не включена тревога (звуковые и световые сигналы)
        Не Включен режим "Антиограбление по брелоку"
    */
    if (!is_fail)
    {
        p_gen6->setMoveSensor();

        if (!p_gen6->waitLightAndAlarm(TimeoutCalculator::calcTimeWithError(m_ahj_steps_one_and_two_time_s + m_ahj_step_three_time_s)))
        {
            printf("PASS Шаг 4. Предупредительные сигналы не получены\n");
        }
        else
        {
            printf("FAIL Шаг 4. Предупредительные сигналы получены\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        p_gen6->checkAlarm(OFF, TimeoutCalculator::calcTimeWithError(m_ahj_step_four_time_s));

        if (!p_gen6->getSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                     SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                     DIAG_EEFLAG_SYSDATA::ID_FLAG_ANTI_HIJACK))
        {
            printf("PASS Шаг 4. Не включен режим \"Антиограбление по брелоку\"\n");
        }
        else
        {
            printf("FAIL Шаг 4. Включен режим \"Антиограбление по брелоку\"\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }
}

// Постановка в охрану по свободным рукам по таймеру после открытия двери
void AutoTestsModesP2::C3407086_TestCase()
{
    Timer timer;           // Таймер, отсчитывает время с момента снятия с охраны/открытия двери
    bool  is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3407086) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_open_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после открытия двери или багажника\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Дверь:                                               | закрыта
        ||Настройки:
        ||Авторизация:                                         | отключена
        ||Свободные руки:                                      | включены
        ||Снятие/постановка:                                   | по появлению/пропаданию метки
        ||Остальные настройки Свободных рук:                   | отключены
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 10
    */
    if (!setArmAndRemoteAndResetTag(PERIM_NOT_DISTURBED))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Охрана отключена
        В течение 15 сек после выключения - охрана не включилась
    */
    if (!is_fail)
    {
        if (!setAndCheckDisarmNoDelayNoTag())
        {
            printf("FAIL Шаг 1\n");
            is_fail = true;
        }

        timer.start();
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    TIME_DELAY::HANDS_FREE_ARM_CHECK_TIME_S - timer.read()))
        {
            printf("PASS Шаг 1. Охрана не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана включилась\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Через 20 сек после выключения охраны открыть дверь
    */
    /*!
        Дверь открыта
        Через 5 (Постановка после открытия двери или багажника) сек включилась охрана
    */
    if (!is_fail)
    {
        timer.stop();
        p_gen6->wait_s(TIME_DELAY::HANDS_FREE_ZONE_AFTER_DISARM_DELAY_S - timer.read());

        p_gen6->setDoor(OPEN,
                        PIN,
                        TIME_DELAY::NULL_DELAY_S);
        timer.reset();
        timer.start();

        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_DOORS,
                                     ON,
                                     TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 2. Дверь не открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                   ON,
                                   m_hf_arm_after_zone_open_delay_s - timer.read(),
                                   TimeoutCalculator::calcToutError(m_hf_arm_after_zone_open_delay_s, PERCENT::TWENTY_PERCENT))) // Большой процент погрешности из-за чтения по SLP
        {
            printf("PASS Шаг 2. Охрана включилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана не включилась в ожидаемое время\n");
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Постановка в охрану по свободным рукам по таймеру после закрытия двери
void AutoTestsModesP2::C3407087_TestCase()
{
    Timer timer;           // Таймер, отсчитывает время с момента снятия с охраны/закрытия двери
    bool  is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3407087) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_close_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после закрытия двери или багажника\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Дверь:                                               | закрыта
        ||Настройки:
        ||Авторизация:                                         | отключена
        ||Свободные руки:                                      | включены
        ||Снятие/постановка:                                   | по появлению/пропаданию метки
        ||Остальные настройки Свободных рук:                   | отключены
        ||Постановка после открытия двери или багажника, сек:  | 15
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setArmAndRemoteAndResetTag(PERIM_NOT_DISTURBED))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Охрана отключена
        В течение 15 сек после выключения - охрана не включилась
    */
    if (!is_fail)
    {
        if (!setAndCheckDisarmNoDelayNoTag())
        {
            printf("FAIL Шаг 1\n");
            is_fail = true;
        }

        timer.start();
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    TIME_DELAY::HANDS_FREE_ARM_CHECK_TIME_S - timer.read()))
        {
            printf("PASS Шаг 1. Охрана не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана включилась\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Через 20 сек после выключения охраны открыть дверь
    */
    /*!
        Дверь открыта
        Охрана не включилась
    */
    if (!is_fail)
    {
        timer.stop();
        p_gen6->wait_s(TIME_DELAY::HANDS_FREE_ZONE_AFTER_DISARM_DELAY_S - timer.read());

        if (p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("PASS Шаг 2. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 2. Дверь не открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    m_hf_arm_after_zone_close_delay_s + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана включилась по таймеру закрытия двери\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
        Через 5 сек (Постановка после закрытия двери или багажника) Охрана включилась
    */
    if (!is_fail)
    {
        p_gen6->setDoor(CLOSE,
                        PIN,
                        TIME_DELAY::NULL_DELAY_S);
        timer.reset();
        timer.start();

        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_DOORS,
                                     OFF,
                                     TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Дверь закрыта\n");
        }
        else
        {
            printf("FAIL Шаг 3. Дверь не закрыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                   ON,
                                   m_hf_arm_after_zone_close_delay_s,
                                   TimeoutCalculator::calcToutError(m_hf_arm_after_zone_close_delay_s, PERCENT::TWENTY_PERCENT))) // Большой процент погрешности из-за чтения по SLP
        {
            printf("PASS Шаг 3. Охрана включилась\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана не включилась в ожидаемое время\n");
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Выключение охраны с нарушенным периметром с включенными свободными руками
void AutoTestsModesP2::C3413361_TestCase()
{
    Timer disarm_timer;    // Таймер, отсчитывает время с момента снятия с охраны
    bool  is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3407087) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_open_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после открытия двери или багажника\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана (с нарушенным периметром)
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Дверь:                                               | открыта
        ||Настройки:
        ||Авторизация:                                         | отключена
        ||Свободные руки:                                      | включены
        ||Снятие/постановка:                                   | по появлению/пропаданию метки
        ||Остальные настройки Свободных рук:                   | отключены
        ||Постановка после открытия двери или багажника, сек:  | 15
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setArmAndRemoteAndResetTag(PERIM_DOOR_OPEN))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Охрана отключена
        Через 15 сек (Постановка после открытия двери или багажника) Охрана включилась
    */
    if (!is_fail)
    {
        if (!setAndCheckDisarmNoDelayNoTag())
        {
            printf("FAIL Шаг 1\n");
            is_fail = true;
        }

        disarm_timer.start();
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                   ON,
                                   m_hf_arm_after_zone_open_delay_s - disarm_timer.read(),
                                   TimeoutCalculator::calcToutError(m_hf_arm_after_zone_open_delay_s, PERCENT::TWENTY_PERCENT))) // Большой процент погрешности из-за чтения по SLP
        {
            printf("PASS Шаг 1. Охрана включилась\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана не включилась\n");
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Нарушение и восстановление периметра вне охраны с включенными свободными руками
void AutoTestsModesP2::C3413362_TestCase()
{
    Timer timer;           // Таймер, отсчитывает время с момента снятия с охраны/закрытия двери
    bool  is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3407086) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_close_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после закрытия двери или багажника\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Дверь:                                               | закрыта
        ||Настройки:
        ||Авторизация:                                         | отключена
        ||Свободные руки:                                      | включены
        ||Снятие/постановка:                                   | по появлению/пропаданию метки
        ||Остальные настройки Свободных рук:                   | отключены
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 10
    */
    if (!setArmAndRemoteAndResetTag(PERIM_NOT_DISTURBED))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Охрана отключена
        В течение 15 сек после выключения - охрана не включилась
    */
    if (!is_fail)
    {
        if (!setAndCheckDisarmNoDelayNoTag())
        {
            printf("FAIL Шаг 1\n");
            is_fail = true;
        }

        timer.start();
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    TIME_DELAY::HANDS_FREE_ARM_CHECK_TIME_S - timer.read()))
        {
            printf("PASS Шаг 1. Охрана не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана включилась\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Через 20 сек после выключения охраны открыть дверь
    */
    /*!
        Дверь открыта
        Охрана не включилась
    */
    if (!is_fail)
    {
        timer.stop();
        p_gen6->wait_s(TIME_DELAY::HANDS_FREE_ZONE_AFTER_DISARM_DELAY_S - timer.read());

        if (p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("PASS Шаг 2. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 2. Дверь не открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана включилась\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Закрыть дверь (не позднее чем через 5 сек после открытия)
    */
    /*!
        Дверь закрыта
        Через 5 сек после открытия двери Охрана не включилась
        Через 10 сек после закрытия двери Охрана включилась
    */
    if (!is_fail)
    {
        p_gen6->setDoor(CLOSE,
                        PIN,
                        TIME_DELAY::NULL_DELAY_S);
        timer.reset();
        timer.start();

        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_DOORS,
                                     OFF,
                                     TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Дверь закрыта\n");
        }
        else
        {
            printf("FAIL Шаг 3. Дверь не закрыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        timer.stop();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                   ON,
                                   m_hf_arm_after_zone_close_delay_s - timer.read(),
                                   TimeoutCalculator::calcToutError(m_hf_arm_after_zone_close_delay_s, PERCENT::TWENTY_PERCENT))) // Большой процент погрешности из-за чтения по SLP
        {
            printf("PASS Шаг 3. Охрана включилась\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана не включилась в ожидаемое время\n");
        }
    }

    if (p_gen6->checkSecure(ON))
    {
        p_gen6->emergencyDisarming();
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 19. Выключение охраны приложением с выключенным запретом снятия
void AutoTestsModesP2::C20445_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_auth_no_tag_needed) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Выключен запрет снятия
        Охрана включена
    */

    /*!
        Выключить охрану приложением
    */
    /*!
        Охрана выключена
    */
    setAndCheckArmAndDisarm();
}

// 30. Выключение охраны приложением с включенным запретом снятия брелоком с активной меткой
void AutoTestsModesP2::C20461_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c20461) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Включен запрет снятия брелоком без метки
        Охрана включена
        Метка включена
    */

    /*!
        Выключить охрану приложением
    */
    /*!
        Охрана выключена
    */
    setAndCheckArmAndDisarm();
}

// 31. Выключение охраны приложением с включенным запретом снятия звонком/смс с активной меткой
void AutoTestsModesP2::C20462_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c20462) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Включен запрет снятия звонком/смс без метки
        Охрана включена
        Метка включена
    */

    /*!
        Выключить охрану приложением
    */
    /*!
        Охрана выключена
    */
    setAndCheckArmAndDisarm();
}

// 32. Выключение охраны приложением с включенным запретом снятия приложением/SLO с активной меткой
void AutoTestsModesP2::C20463_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c20463) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Включен запрет снятия приложением/SLO без метки
        Охрана включена
        Метка включена
    */

    /*!
        Выключить охрану приложением
    */
    /*!
        Охрана выключена
    */
    setAndCheckArmAndDisarm();
}

// Открылась дверь во время имитации двери после ДЗ
void AutoTestsModesP2::C3688075_TestCase()
{
    Timer eng_stop_timer;                                        // Таймер времени, прошедшего с момента глушения двигателя
    float doors_imit_end_wait_time_s = TIME_DELAY::NULL_DELAY_S; // Полное время ожидания импульса с момента глушения двигателя
    bool  is_fail                    = false;                    // Статус прохождения теста


    if (settings_check(p_c3688075) == 0)
    {
        return;
    }

    if (   m_rearm_delay_s      == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_doors_imit_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_doors_imit_time_s  == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все необходимые настройки были заданы\n");
        is_fail = true;
    }

    doors_imit_end_wait_time_s =   m_doors_imit_time_s           
                                 + m_doors_imit_delay_s
                                 + TIME_DELAY::STD_ERROR_TIME_S;

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                                                | Охрана
        ||Дверь:                                                                                       | закрыта
        ||ПН:                                                                                          | выполнена
        ||Настройки:
        ||Система запуска:                                                                             | Старт-стоп
        ||Кол-во импульсов:                                                                            | 1
        ||КПП:                                                                                         | МКПП
        ||Перепостановка в охрану:                                                                     | включена
        ||Время до перепостановки:                                                                     | 20
        ||Выполнять имитацию открытия двери:                                                           | Всегда
        ||Задержка перед началом имитации и игнорированием открытия дверей после остановки двигателя:  | 5
        ||Время имитации и игнорирования открытия дверей после остановки двигателя:                    | 10
        ||Настроен выход:                                                                              | Имитация открытия двери
    */

    /*!
        Шаг 1. Произвести ДЗ двигателя (командой с брелока)
    */
    /*!
        Начался ДЗ:
        Подан потенциал на выход обходчика
        Подан потенциал на имитацию педали тормоза
        Подан потенциал на кнопку старт-стоп
    */

    /*!
        Шаг 2. Включить двигатель (зажигание+обороты) в момент активной кнопки старт-стоп
    */
    /*!
        Выполниен ДЗ
        Двигатель работает
        Охрана включена
    */

    /*!
        Шаг 3. Произвести дистанционное глушение двигателя (командой с брелока)
    */
    /*!
        Выполнены попытки глушения двигателя кнопкой старт-стоп (3 импульса старт-стоп)
    */

    /*!
        Шаг 4. В течение 3х импульсов заглушить двигатель (выключить зажигание)
    */
    /*!
        Двигатель заглушен
        Через 5 сек после глушения двигателя на выход Имитации открытия двери подан потенциал
    */

    /*!
        Шаг 5. Через 5 сек после начала имитации открытия двери выключить охрану
    */
    /*!
        Охрана отключена
    */
    if (!setRemoteRunAndStopAndDisarm(eng_stop_timer,
                                      TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1-5\n");
        is_fail = true;
    }

    /*!
        Шаг 6. Открыть дверь
    */
    /*!
        Дверь НЕ открыта
        Через время, указанное в 'Время имитации и игнорирования открытия дверей после остановки двигателя', после начала имитации открытия двери с выход Имитации открытия двери снят потенциал
        Дверь открыта
        Через время, указанное в 'Время до перепостановки', после глушения двигателя охрана не включена (перепостановка не сработала) 
    */
    if (!is_fail)
    {
        if (!p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("PASS Шаг 6. Дверь не открыта\n");
        }
        else
        {
            printf("FAIL Шаг 6. Дверь открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->checkPulseWidth(ID_OUT_DOORS_IMIT,
                                    m_doors_imit_time_s,                                // Длина импульса
                                    doors_imit_end_wait_time_s - eng_stop_timer.read(), // Полное время ожидания импульса
                                    TIME_DELAY::STD_ERROR_TIME_S))                      // Погрешность импульса
        {
            printf("PASS Шаг 6. Снят потенциал с выхода Имитация открытия двери\n");
        }
        else
        {
            printf("FAIL Шаг 6. Не снят потенциал с выхода Имитация открытия двери или снят вне времени ожидания\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_DOORS,
                                     ON,
                                     TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 6. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 6. Дверь не открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    m_rearm_delay_s - eng_stop_timer.read() - TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Шаг 6. Перепостановка не сработала\n");
        }
        else
        {
            printf("FAIL Шаг 6. Перепостановка сработала\n");
        }
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// Открылся багажник во время охраны с открытым багажником
void AutoTestsModesP2::C3688076_TestCase()
{
    bool is_fail = false; // Статус прохождения теста


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3688076) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:             | Охрана
        ||Дверь:                    | закрыта
        ||Багажник:                 | закрыт
        ||Настройки:
        ||Перепостановка в охрану:  | включена
        ||Время до перепостановки:  | 10
        ||Настроен выход:           | Отпирание багажника
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отпереть багажник брелоком (команда 2,2)
    */
    /*!
        На выход отпирания багажника подан импульс
        Включена охрана с открытым багажником
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING, TIME_DELAY::STD_WIRE_EN_DELAY_S);

        if (   p_gen6->waitTrunk(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S,  p_gen6->getPolarity(ID_OUT_TRUNK))
            && p_gen6->waitTrunk(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S, !p_gen6->getPolarity(ID_OUT_TRUNK)))
        {
            printf("PASS Шаг 1. На выход отпирания багажника подан импульс\n");
        }
        else
        {
            printf("FAIL Шаг 1. На выход отпирания багажника не подан импульс\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Включена охрана с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 1. Не включена охрана с открытым багажником\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Тревога не включилась
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(ON, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 2. Тревога не включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Выключить охрану
    */
    /*!
        Охрана отключена
        Через 10 сек охрана не включена (перепостановка не сработала)
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckSecure(OFF,
                                      KEYRING,
                                      DIAG_GUARD_STATE_DISARM))
        {
            printf("PASS Шаг 3. Охрана отключена\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана не отключена\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    m_rearm_delay_s))
        {
            printf("PASS Шаг 3. Перепостановка не сработала\n");
        }
        else
        {
            printf("FAIL Шаг 3. Перепостановка сработала\n");
        }
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// ДД не влияет на перепостановку
void AutoTestsModesP2::C3688077_TestCase()
{
    if (settings_check(p_c3688077) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:             | Охрана
        ||Дверь:                    | закрыта
        ||Багажник:                 | закрыт
        ||Настройки:
        ||Перепостановка в охрану:  | включена
        ||Время до перепостановки:  | 10
        ||Настроен ДД:              | Настроен ДД
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через время, указанное в настройке 'Время до перепостановки', после отключения охраны - охрана включена (перепостановка сработала)
    */
    if (!setSensorAndCheckRearm(DIAG_SENSOR_BIT_MOVE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// ДН не влияет на перепостановку
void AutoTestsModesP2::C3688078_TestCase()
{
    if (settings_check(p_c3688077) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:             | Охрана
        ||Дверь:                    | закрыта
        ||Багажник:                 | закрыт
        ||Настройки:
        ||Перепостановка в охрану:  | включена
        ||Время до перепостановки:  | 10
        ||Настроен ДН:              | Настроен ДН
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 2. Вызвать срабатывание ДН
    */
    /*!
        Сработал ДН
        Через время, указанное в настройке 'Время до перепостановки', после отключения охраны - охрана включена (перепостановка сработала)
    */
    if (!setSensorAndCheckRearm(DIAG_SENSOR_BIT_TILT))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// ДУ не влияет на перепостановку
void AutoTestsModesP2::C3688079_TestCase()
{
    if (settings_check(p_c3688077) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:             | Охрана
        ||Дверь:                    | закрыта
        ||Багажник:                 | закрыт
        ||Настройки:
        ||Перепостановка в охрану:  | включена
        ||Время до перепостановки:  | 10
        ||Настроен ДУ:              | Настроен ДУ
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Охрана отключена
    */

    /*!
        Шаг 2. Вызвать срабатывание ДУ
    */
    /*!
        Сработал ДУ
        Через время, указанное в настройке 'Время до перепостановки', после отключения охраны - охрана включена (перепостановка сработала)
    */
    if (!setSensorAndCheckRearm(DIAG_SENSOR_BIT_SHOCK_HIGH))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// Перепостановка срабатывает во время имитации двери после ДЗ
void AutoTestsModesP2::C3697245_TestCase()
{
    Timer eng_stop_timer;                                        // Таймер времени, прошедшего с момента глушения двигателя
    float doors_imit_end_wait_time_s = TIME_DELAY::NULL_DELAY_S; // Полное время ожидания импульса с момента глушения двигателя
    bool  is_fail                    = false;                    // Статус прохождения теста


    if (settings_check(p_c3697245) == 0)
    {
        return;
    }

    if (   m_doors_imit_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_doors_imit_time_s  == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки времени имитации открытия двери были заданы\n");
        is_fail = true;
    }

    doors_imit_end_wait_time_s =   m_doors_imit_time_s           
                                 + m_doors_imit_delay_s
                                 + TIME_DELAY::STD_ERROR_TIME_S;

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                                                | Охрана
        ||Дверь:                                                                                       | закрыта
        ||ПН:                                                                                          | выполнена
        ||Настройки:
        ||Система запуска:                                                                             | Старт-стоп
        ||Кол-во импульсов:                                                                            | 1
        ||КПП:                                                                                         | МКПП
        ||Перепостановка в охрану:                                                                     | включена
        ||Время до перепостановки:                                                                     | 5
        ||Выполнять имитацию открытия двери:                                                           | Всегда
        ||Задержка перед началом имитации и игнорированием открытия дверей после остановки двигателя:  | 5
        ||Время имитации и игнорирования открытия дверей после остановки двигателя:                    | 20
        ||Настроен выход:                                                                              | Имитация открытия двери
    */

    /*!
        Шаг 1. Произвести ДЗ двигателя (командой с брелока)
    */
    /*!
        Начался ДЗ:
        Подан потенциал на выход обходчика
        Подан потенциал на имитацию педали тормоза
        Подан потенциал на кнопку старт-стоп
    */

    /*!
        Шаг 2. Включить двигатель (зажигание+обороты) в момент активной кнопки старт-стоп
    */
    /*!
        Выполниен ДЗ
        Двигатель работает
        Охрана включена
    */

    /*!
        Шаг 3. Произвести дистанционное глушение двигателя (командой с брелока)
    */
    /*!
        Выполнены попытки глушения двигателя кнопкой старт-стоп (3 импульса старт-стоп)
    */

    /*!
        Шаг 4. В течение 3х импульсов заглушить двигатель (выключить зажигание)
    */
    /*!
        Двигатель заглушен
        Через 5 сек после глушения двигателя на выход Имитации открытия двери подан потенциал
    */

    /*!
        Шаг 5. Через 5 сек после начала имитации открытия двери - выключить охрану
    */
    /*!
        Охрана отключена
    */
    if (!setRemoteRunAndStopAndDisarm(eng_stop_timer,
                                      TIME_DELAY::FIVE_S))
    {
        printf("FAIL Шаг 1-5\n");
        is_fail = true;
    }

    /*!
        Шаг 6. Открыть дверь
    */
    /*!
        Дверь НЕ открыта
        Через время, указанное в 'Время до перепостановки', после выключения охраны охрана включена (перепостановка сработала)
        Через время, указанное в 'Время имитации и игнорирования открытия дверей после остановки двигателя', после начала имитации открытия двери с выход Имитации открытия двери снят потенциал
        Дверь открыта
        Включена тревога
    */
    if (!is_fail)
    {
        if (!p_gen6->setAndCheckDoor(OPEN, PIN))
        {
            printf("PASS Шаг 6. Дверь не открыта\n");
        }
        else
        {
            printf("FAIL Шаг 6. Дверь открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                    ON,
                                    m_rearm_delay_s - eng_stop_timer.read() - TIME_DELAY::STD_ERROR_TIME_S))
        {
            printf("PASS Шаг 6. Перепостановка не сработала раньше времени\n");
        }
        else
        {
            printf("FAIL Шаг 6. Перепостановка сработала раньше времени\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 6. Перепостановка сработала\n");
        }
        else
        {
            printf("FAIL Шаг 6. Перепостановка не сработала\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->checkPulseWidth(ID_OUT_DOORS_IMIT,
                                    m_doors_imit_time_s,                                // Длина импульса
                                    doors_imit_end_wait_time_s - eng_stop_timer.read(), // Полное время ожидания импульса
                                    TIME_DELAY::STD_ERROR_TIME_S))                      // Погрешность импульса
        {
            printf("PASS Шаг 6. Снят потенциал с выхода Имитация открытия двери\n");
        }
        else
        {
            printf("FAIL Шаг 6. Не снят потенциал с выхода Имитация открытия двери или снят вне времени ожидания\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitSlpCmdStatus(DIAG_DATA_PERIM,
                                     SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                     DIAG_PERIM_BIT_DOORS,
                                     ON,
                                     TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 6. Дверь открыта\n");
        }
        else
        {
            printf("FAIL Шаг 6. Дверь не открыта\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 6. Тревога включена\n");
        }
        else
        {
            printf("FAIL Шаг 6. Тревога не включена\n");
        }
    }

    p_gen6->setSecure(OFF,
                      KEYRING,
                      TIME_DELAY::STD_WIRE_EN_DELAY_S);

    if (settings_check(p_no_rearm) == 0)
    {
        printf("FAIL При сбросе настроек Мастера\n");
    }
}

// Закрытие ЦЗ (по скорости) после автоматического выхода из сервиса
void AutoTestsModesP2::C3752984_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3752984) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Сервис
        ||Дверь:                             | закрыта
        ||ПН:                                | не выполнена
        ||Метка:                             | включена
        ||Брелок:                            | включен
        ||Скорость:                          | 0
        ||Ручник:                            | выключен
        ||Зажигание:                         | включено
        ||Двигатель:                         | заведен
        ||Настройки:
        ||Система запуска:                   | Старт-стоп
        ||Кол-во импульсов:                  | 1
        ||КПП:                               | МКПП
        ||Настроен:                          | ДД
        ||Запирание ЦЗ в поездке:            | По превышению порога скорости
        ||Скорость запирания ЦЗ:             | 50
        ||Авторизация:                       | Метка (брелок если комплекс без метки)
        ||Выход из сервисного режима:        | По превышению заданной скорости
        ||Порог скорости:                    | 30
        ||Настроен CAN:                      | Batmobile
        ||Настроен выход:                    | ЦЗ закрыть
    */

    /*!
        Шаг 1. Повысить скорость до 35 км/ч
    */
    /*!
        Скорость повысилась с 0 до 35 км/ч
        Сервис активен
    */

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Сервис отключен
        Переход в снято (Пройдена авторизация по метке)
    */
    if (!setAndResetServiceModeBySpeed(35))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Повысить скорость до 55 км/ч
    */
    /*!
        Скорость повысилась с 35 до 55 км/ч
        !На выход "ЦЗ закрыть" подан импульс (замки закрылись)!
    */
    p_gen6->setSpeed(55);

    if (   p_gen6->waitCLockClose(TIME_DELAY::LOCK_EN_TIME_S,  p_gen6->getPolarity(ID_OUT_LOCK_B))  // Ожидание фронта импульса
        && p_gen6->waitCLockClose(TIME_DELAY::LOCK_EN_TIME_S, !p_gen6->getPolarity(ID_OUT_LOCK_B))) // Ожидание спада импульса
    {
        printf("PASS Шаг 3. На выход \"ЦЗ закрыть\" подан импульс (замки закрылись)\n");
    }
    else
    {
        printf("FAIL Шаг 3. На выход \"ЦЗ закрыть\" не подан импульс\n");
    }
}

// ПН (по ручнику) после автоматического выхода из сервиса
void AutoTestsModesP2::C3752985_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3752985) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Сервис
        ||Дверь:                             | закрыта
        ||ПН:                                | не выполнена
        ||Условие включения ПЗ:              | при затягивании стояночного тормоза
        ||Метка:                             | включена
        ||Брелок:                            | включен
        ||Скорость:                          | 0
        ||Ручник:                            | выключен
        ||Зажигание:                         | включено
        ||Двигатель:                         | заведен
        ||Настройки:
        ||Система запуска:                   | Замок зажигания
        ||Кол-во импульсов:                  | 1
        ||КПП:                               | МКПП
        ||Настроен:                          | ДД
        ||Авторизация:                       | Метка (брелок если комплекс без метки)
        ||Выход из сервисного режима:        | По превышению заданной скорости
        ||Порог скорости:                    | 30
        ||Настроен CAN:                      | Batmobile
    */

    /*!
        Шаг 1. Повысить скорость до 35 км/ч
    */
    /*!
        Скорость повысилась с 0 до 35 км/ч
        Сервис активен
    */

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Сервис отключен
        Переход в снято (Пройдена авторизация по метке)
    */
    if (!setAndResetServiceModeBySpeed(35))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Затянуть ручник
    */
    /*!
        Ручник затянут
        !Включена ПЗ!
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 3. Ручник затянут\n");
    }
    else
    {
        printf("FAIL Шаг 3. Ручник не затянут\n");
        return;
    }

    p_gen6->checkSupportIgn(ON);
}

// ПН (автоматически) после автоматического выхода из сервиса
void AutoTestsModesP2::C3752986_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3752986) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Сервис
        ||Дверь:                             | закрыта
        ||ПН:                                | не выполнена
        ||Условие включения ПЗ:              | автоматически
        ||Метка:                             | включена
        ||Брелок:                            | включен
        ||Скорость:                          | 0
        ||Ручник:                            | выключен
        ||Зажигание:                         | включено
        ||Двигатель:                         | заведен
        ||Настройки:
        ||Система запуска:                   | Замок зажигания
        ||Кол-во импульсов:                  | 1
        ||КПП:                               | МКПП
        ||Настроен:                          | ДД
        ||Авторизация:                       | Метка (брелок если комплекс без метки)
        ||Выход из сервисного режима:        | По превышению заданной скорости
        ||Порог скорости:                    | 30
        ||Настроен CAN:                      | Batmobile
    */

    /*!
        Шаг 1. Повысить скорость до 35 км/ч
    */
    /*!
        Скорость повысилась с 0 до 35 км/ч
        Сервис активен
    */

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Сервис отключен
        Переход в снято (Пройдена авторизация по метке)
    */
    if (!setAndResetServiceModeBySpeed(35))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Затянуть ручник
    */
    /*!
        Ручник затянут
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 3. Ручник затянут\n");
    }
    else
    {
        printf("FAIL Шаг 3. Ручник не затянут\n");
        return;
    }

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        !Включена ПЗ!
        Двигатель работает
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 3. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 3. Зажигание не выключено\n");
        return;
    }

    p_gen6->checkSupportIgn(ON);

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Двигатель работает\n");
    }
    else
    {
        printf("FAIL Шаг 3. Двигатель не работает\n");
    }
}

// Закрытие ЦЗ (по ручнику) после автоматического выхода из сервиса
void AutoTestsModesP2::C3752987_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3752987) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Сервис
        ||Дверь:                             | закрыта
        ||ПН:                                | не выполнена
        ||Метка:                             | включена
        ||Брелок:                            | включен
        ||Скорость:                          | 0
        ||Ручник:                            | выключен
        ||Зажигание:                         | включено
        ||Двигатель:                         | заведен
        ||Настройки:
        ||Система запуска:                   | Старт-стоп
        ||Кол-во импульсов:                  | 1
        ||КПП:                               | МКПП
        ||Настроен:                          | ДД
        ||Запирание ЦЗ в поездке:            | При отпускании ручного тормоза
        ||Авторизация:                       | Метка (брелок если комплекс без метки)
        ||Выход из сервисного режима:        | По превышению заданной скорости
        ||Порог скорости:                    | 30
        ||Настроен CAN:                      | Batmobile
        ||Настроен выход:                    | ЦЗ закрыть
    */

    /*!
        Шаг 1. Повысить скорость до 35 км/ч
    */
    /*!
        Скорость повысилась с 0 до 35 км/ч
        Сервис активен
    */

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Сервис отключен
        Переход в снято (Пройдена авторизация по метке)
    */
    if (!setAndResetServiceModeBySpeed(35))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Затянуть ручник
    */
    /*!
        Ручник затянут
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 3. Ручник затянут\n");
    }
    else
    {
        printf("FAIL Шаг 3. Ручник не затянут\n");
        return;
    }

    /*!
        Шаг 3. Опустить ручник
    */
    /*!
        Ручник выключен
        !На выход "ЦЗ закрыть" подан импульс (замки закрылись)!
    */
    p_gen6->setHandBreak(OFF, PIN);

    if (   p_gen6->waitCLockClose(TIME_DELAY::LOCK_EN_TIME_S,  p_gen6->getPolarity(ID_OUT_LOCK_B))  // Ожидание фронта импульса
        && p_gen6->waitCLockClose(TIME_DELAY::LOCK_EN_TIME_S, !p_gen6->getPolarity(ID_OUT_LOCK_B))) // Ожидание спада импульса
    {
        printf("PASS Шаг 3. На выход \"ЦЗ закрыть\" подан импульс (замки закрылись)\n");
    }
    else
    {
        printf("FAIL Шаг 3. На выход \"ЦЗ закрыть\" не подан импульс\n");
    }
}

// 1. Выключение блокировки при выключении охраны
void AutoTestsModesP2::C187473_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                     | Охрана
        ||R6:                                               | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                   | НР (Нормально разомкнутая)
        ||Снятие блокировки (только для НР):                | При снятии с охраны
        ||Задержка блокировки, с:                           | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Снять с охраны
    */
    /*!
        Охрана выключена
        Блокировка R6 выключена
    */
    if (!setSecureAndCheckR6Block(SECURE_CMD_OFF,
                                  BLOCK_OFF))
    {
        printf("FAIL Шаг 1.\n");
    }
}

// 2. Включение блокировки при включении охраны
void AutoTestsModesP2::C187474_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187473) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                     | Снято с охраны
        ||R6:                                               | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                   | НР (Нормально разомкнутая)
        ||Снятие блокировки (только для НР):                | При снятии с охраны
        ||Задержка блокировки, с:                           | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Поставить в охрану
    */
    /*!
        Охрана включена
        Блокировка R6 включена
    */
    if (!setSecureAndCheckR6Block(SECURE_CMD_ON,
                                  BLOCK_ON))
    {
        printf("FAIL Шаг 1.\n");
    }
}

// 3. Отсутствие выключения блокировки при выключении охраны
void AutoTestsModesP2::C187475_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187475) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                     | Охрана
        ||Зажигание:                                        | выключено
        ||R6:                                               | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                   | НР (Нормально разомкнутая)
        ||Снятие блокировки (только для НР):                | При включении зажигания в снято с охраны
        ||Задержка блокировки, с:                           | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Снять с охраны
    */
    /*!
        Охрана выключена
        Блокировка R6 не выключилась
    */
    if (!setSecureAndCheckR6Block(SECURE_CMD_OFF,
                                  BLOCK_NOT_OFF))
    {
        printf("FAIL Шаг 1.\n");
    }
}

// 4. Выключение блокировки при включении зажигания
void AutoTestsModesP2::C187476_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187475) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                     | Снято с охраны
        ||Зажигание:                                        | выключено
        ||R6:                                               | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                   | НР (Нормально разомкнутая)
        ||Снятие блокировки (только для НР):                | При включении зажигания в снято с охраны
        ||Задержка блокировки, с:                           | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 выключена
    */
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);

    if (waitR6Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 1. Блокировка R6 выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка R6 не выключена\n");
    }
}

// 5. Включение блокировки при выключении зажигания
void AutoTestsModesP2::C187477_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187475) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                     | Снято с охраны
        ||Зажигание:                                        | выключено
        ||R6:                                               | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                   | НР (Нормально разомкнутая)
        ||Снятие блокировки (только для НР):                | При включении зажигания в снято с охраны
        ||Задержка блокировки, с:                           | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 выключена
    */
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);

    if (waitR6Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 1. Блокировка R6 выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка R6 не включена\n");
        return;
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Блокировка R6 включена
    */
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S); // Нельзя сразу включать/выключать зажигание, система не успевает среагировать
    p_gen6->setIgn(PIN,
                   OFF,
                   TIME_DELAY::NULL_DELAY_S);

    if (waitR6Block(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не включена\n");
    }
}

// 1. Блокировка заглушенного двигателя (блок. только заведенного двиг. откл.)
void AutoTestsModesP2::C187457_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187457) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// 2. Блокировка заглушенного двигателя (блок. с педалью тормоза вкл.)
void AutoTestsModesP2::C187458_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187458) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Обороты:                                                      | выключены (не поданы/мин. значение)
        ||Скорость по CAN:                                              | 20 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(20);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Повысить скорость до 40 км/ч (сделать выше, чем в настройке 'Скорость, ниже которой разрешена блокировка, км/ч')
    */
    /*!
        Скорость 40 км/ч
        Блокировка R6 активна
    */
    p_gen6->setSpeed(40);

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 активна\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не активна (выключилась)\n");
        return;
    }

    /*!
        Шаг 3. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка R6 активна
    */
    if (p_gen6->setAndCheckBreak(ON, PIN))
    {
        printf("PASS Шаг 3. Педаль тормоза нажата\n");
    }
    else
    {
        printf("FAIL Шаг 3. Педаль тормоза не нажата\n");
        return;
    }

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 активна\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не активна (выключилась)\n");
        return;
    }

    /*!
        Шаг 4. Отпустить педаль тормоза
    */
    /*!
        Педаль тормоза отпущена (не нажата)
    */
    if (p_gen6->setAndCheckBreak(OFF, PIN))
    {
        printf("PASS Шаг 4. Педаль тормоза отпущена (не нажата)\n");
    }
    else
    {
        printf("FAIL Шаг 4. Педаль тормоза не отпущена (нажата)\n");
        return;
    }

    /*!
        Шаг 5. Понизить скорость до 20 км/ч (сделать ниже, чем в настройке 'Скорость, ниже которой разрешена блокировка, км/ч')
    */
    /*!
        Скорость 20 км/ч
        Блокировка R6 активна
    */
    p_gen6->setSpeed(20);

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 5. Блокировка R6 активна\n");
    }
    else
    {
        printf("FAIL Шаг 5. Блокировка R6 не активна (выключилась)\n");
        return;
    }

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Нажата педаль тормоза
        Блокировка R6 активна
    */
    p_gen6->setBreak(ON,
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 6. Блокировка R6 активна\n");
    }
    else
    {
        printf("FAIL Шаг 6. Блокировка R6 не активна (выключилась)\n");
    }
}

// 3. Отсутствие блокировки заглушенного двигателя (блок. только заведенного двиг. вкл.)
void AutoTestsModesP2::C187459_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187459) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                            | Охрана
        ||Зажигание:                                               | выключено
        ||Обороты:                                                 | выключены (не поданы/мин. значение)
        ||R6:                                                      | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                          | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):         | Включено (галочка стоит)
        ||Длительность блокировки:                                 | 3 сек
        ||Задержка блокировки, с:                                  | 0 секунд (без задержки)
    */
    p_gen6->setEngine(OFF, PIN);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// 4. Блокировка заведенного двигателя (блок. только заведенного двиг. откл.)
void AutoTestsModesP2::C187460_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187457) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                            | Охрана
        ||Зажигание:                                               | выключено
        ||Обороты:                                                 | выключены (не поданы/мин. значение)
        ||R6:                                                      | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                          | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):         | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                  | 0 секунд (без задержки)
    */
    p_gen6->setEngine(OFF, PIN);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Завести двигатель (подать зажигание + обороты)
    */
    /*!
        Двигатель заведен
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Сработал ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 активна
    */
    p_gen6->setMoveSensor();

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 активна\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не активна (выключилась)\n");
    }
}

// 5. Блокировка заведенного двигателя (блок. только заведенного двиг. вкл.)
void AutoTestsModesP2::C187461_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187459) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                            | Охрана
        ||Зажигание:                                               | выключено
        ||Обороты:                                                 | выключены (не поданы/мин. значение)
        ||R6:                                                      | включен
        ||Настройки:
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                          | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):         | Включено (галочка стоит)
        ||Длительность блокировки:                                 | 3 сек
        ||Задержка блокировки, с:                                  | 0 секунд (без задержки)
    */
    p_gen6->setEngine(OFF, PIN);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Подать обороты
    */
    /*!
        Двигатель заведен
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 включилась
        Через 3 сек. (длительность блокировки) блокировка отключилась
    */
    p_gen6->setMoveSensor();

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включилась\n");
        return;
    }

    if (waitR6Block(OFF,
                    m_eng_block_local0_block_s,
                    TimeoutCalculator::calcToutError(m_eng_block_local0_block_s)))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась\n");
    }
}

// 6. Включение блокировки в тревоге на заведенном двигателе
void AutoTestsModesP2::C187462_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187462) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Обороты:                                                      | выключены (не поданы/мин. значение)
        ||Скорость по CAN:                                              | 15 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Включено (галочка стоит)
        ||Длительность блокировки:                                      | 3 сек
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(15);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Завести двигатель (подать зажигание + обороты)
    */
    /*!
        Двигатель заведен
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка R6 не включилась
    */
    p_gen6->setBreak(ON,
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    if (!waitR6Block(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 включилась
        Через 3 сек. (длительность блокировки) блокировка отключилась
    */
    p_gen6->setMoveSensor();

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включилась\n");
        return;
    }

    if (waitR6Block(OFF,
                    m_eng_block_local0_block_s,
                    TimeoutCalculator::calcToutError(m_eng_block_local0_block_s)))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась\n");
    }
}

// 7. Отсутствие блокировки при скорости выше разрешенной
void AutoTestsModesP2::C187463_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187463) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Обороты:                                                      | выключены (не поданы/мин. значение)
        ||Скорость по CAN:                                              | 40 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Включено (галочка стоит)
        ||Длительность блокировки:                                      | 3 сек
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(40);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Блокировка R6 не включилась
    */
    p_gen6->setMoveSensor();

    if (!waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась)\n");
    }
}

// 8. Блокировка с не нажатой педалью тормоза со скоростью меньше 10 км/ч
void AutoTestsModesP2::C187464_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187464) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Обороты:                                                      | выключены (не поданы/мин. значение)
        ||Скорость по CAN:                                              | 5 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(5);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включена
    */
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);

    if (waitR6Block(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 1. Блокировка R6 включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка R6 не включена\n");
    }
}

// 9. Блокировка с нажатой педалью тормоза (скорость 10 - разрешенная)
void AutoTestsModesP2::C187465_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187462) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Обороты:                                                      | выключены (не поданы/мин. значение)
        ||Скорость по CAN:                                              | 11 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Включено (галочка стоит)
        ||Длительность блокировки:                                      | 3 сек
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(11);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка R6 не включилась
    */
    p_gen6->setBreak(ON,
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    if (!waitR6Block(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 включилась
        Через 3 сек. (длительность блокировки) блокировка отключилась
    */
    p_gen6->setMoveSensor();

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включилась\n");
        return;
    }

    if (waitR6Block(OFF,
                    m_eng_block_local0_block_s,
                    TimeoutCalculator::calcToutError(m_eng_block_local0_block_s)))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась\n");
    }
}

// 10. Отсутствие блокировки с не нажатой педалью тормоза с последующим нажатием
void AutoTestsModesP2::C187466_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187462) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Скорость по CAN:                                              | 25 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Включено (галочка стоит)
        ||Длительность блокировки:                                      | 3 сек
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(25);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Завести двигатель (подать зажигание + обороты)
    */
    /*!
        Двигатель заведен
        Блокировка R6 не включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка R6 не включилась
    */
    p_gen6->setBreak(ON,
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    if (!waitR6Block(ON, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 включилась
        Через 3 сек. (длительность блокировки) блокировка отключилась
    */
    p_gen6->setMoveSensor();

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включилась\n");
        return;
    }

    if (waitR6Block(OFF,
                    m_eng_block_local0_block_s,
                    TimeoutCalculator::calcToutError(m_eng_block_local0_block_s)))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась\n");
    }
}

// 11. Глушение двигателя в тревоге с выключением блокировки
void AutoTestsModesP2::C187467_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187459) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Включено (галочка стоит)
        ||Длительность блокировки:                                      | 3 сек
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Завести двигатель (подать зажигание + обороты)
    */
    /*!
        Двигатель заведен
        Включилась тревога
        Блокировка R6 не включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включилась тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не включилась тревога\n");
        return;
    }

    /*!
        Шаг 2. Выключить обороты (заглушить двигатель)
    */
    /*!
        Обороты выключены
        Блокировка R6 не включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_OFF))
    {
        printf("FAIL Шаг 2\n");
    }

    if (!waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включена\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 включилась
        Через 3 сек. (длительность блокировки) блокировка отключилась
    */
    p_gen6->setMoveSensor();

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включилась\n");
        return;
    }

    if (waitR6Block(OFF,
                    m_eng_block_local0_block_s,
                    TimeoutCalculator::calcToutError(m_eng_block_local0_block_s)))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась\n");
    }
}

// 12. Глушение двигателя в тревоге без выключения блокировки
void AutoTestsModesP2::C187468_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187457) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Завести двигатель (подать зажигание + обороты)
    */
    /*!
        Двигатель заведен
        Включилась тревога
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включилась тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не включилась тревога\n");
        return;
    }

    /*!
        Шаг 2. Выключить обороты (заглушить двигатель)
    */
    /*!
        Обороты выключены
        Блокировка R6 не выключилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_NOT_OFF))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка R6 не отключилась пока не закончилась тревога
    */
    p_gen6->setMoveSensor();
    p_gen6->setIgn(PIN,                       // Если не выключить зажигание, то тревога никогда не выключился
                   OFF,
                   TIME_DELAY::NULL_DELAY_S);

    if (waitR6Block(OFF,
                    TIME_DELAY::ALARM_DIS_TIME_S,
                    TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 отключилась по окончанию тревоги\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не отключилась по окончанию тревоги\n");
    }
}

// 13. Выключение педали тормоза в тревоге без выключения блокировки 
void AutoTestsModesP2::C187469_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187458) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Скорость по CAN:                                              | 25 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(25);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Тревога включена
        Блокировка R6 включилась
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_ON,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включилась тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Не включилась тревога\n");
        return;
    }

    /*!
        Шаг 2. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка R6 включена
    */
    if (p_gen6->setAndCheckBreak(ON, PIN))
    {
        printf("PASS Шаг 2. Педаль тормоза нажата\n");
    }
    else
    {
        printf("FAIL Шаг 2. Педаль тормоза не нажата\n");
        return;
    }

    if (!waitR6Block(OFF, TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не включена\n");
        return;
    }

    /*!
        Шаг 3. Отпустить педаль тормоза
    */
    /*!
        Педаль тормоза отпущена (не нажата)
        Блокировка R6 не выключилась
    */
    p_gen6->setBreak(OFF,
                     PIN,
                     TIME_DELAY::NULL_DELAY_S);

    if (!waitR6Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 не выключилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 выключилась\n");
    }
}

// 14. Превышение скорости 10 км/ч в тревоге без выключения блокировки
void AutoTestsModesP2::C187470_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187458) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Скорость по CAN:                                              | 0 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Включено (галочка стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(0);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Повысить скорость до 20 км/ч
    */
    /*!
        Скорость 20 км/ч
        Блокировка R6 не выключилась
    */
    p_gen6->setSpeed(20);

    if (!waitR6Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S + TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не выключилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 выключилась\n");
    }
}

// 15. Превышение скорости выше разрешенной в тревоге без выключения блокировки
void AutoTestsModesP2::C187471_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187471) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||Скорость по CAN:                                              | 0 км/ч
        ||R6:                                                           | включен
        ||Настройки:
        ||Автомобиль CAN:                                               | Batmobile (9999)
        ||Скорость (настройки CAN):                                     | Галочка стоит
        ||Скорость, ниже которой разрешена блокировка, км/ч:            | 30 км/ч
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    p_gen6->setSpeed(0);

    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Повысить скорость до 40 км/ч
    */
    /*!
        Скорость 40 км/ч
        Блокировка R6 не выключилась
    */
    p_gen6->setSpeed(40);

    if (!waitR6Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S + TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не выключилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 выключилась\n");
    }
}

// 16. Выключение блокировки
void AutoTestsModesP2::C187472_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187457) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать при срабатывании ДД (только для НЗ):              | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Блокировка R6 включена
    */
    if (!setIgnAndEngineAndCheckR6Block(IGN_ON,
                                        ENG_OFF,
                                        BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить тревогу нажав кнопку метки (коротко)
    */
    /*!
        Тревога выключена
        Блокировка R6 выключена
    */
    p_gen6->setTagVcc();
    wait(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    p_gen6->pushTagBtn(TAG_SHORT);

    if (waitR6Block(OFF, TIME_DELAY::MAX_REMOTE_STATUS_EN_TIME_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 выключена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не выключена\n");
    }
}

// 17. Пропала связь с ЦБ, зажигание вкл
void AutoTestsModesP2::C187478_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187478) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать только заведенный двигатель (только для НЗ):      | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить питание ЦБ (имитация потери связи с ЦБ)
    */
    /*!
        Питание ЦБ выключено
        Связь R6 с ЦБ потеряна
    */
    p_gen6->off();

    /*!
        Шаг 2. Включить зажигание на R6 и ожидать 60 секунд
    */
    /*!
        Зажигание на R6 включено
        Блокировка R6 включена
    */
    p_gen6->setR6Ign(); // Задержки для ожидания включения зажигания не требуется, т.к. R6 проверит зажигание только через 60 сек после потери связи с ЦБ

    if (!waitR6Block(ON, TIME_DELAY::R6_IGN_CHECK_AFTER_CONN_LOST_DELAY_S - TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включена раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включена раньше времени\n");
        return;
    }

    if (waitR6Block(ON, TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 не включена\n");
    }
}

// 18. Пропала связь с ЦБ, зажигание выкл, движения нет
void AutoTestsModesP2::C187479_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187478) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать только заведенный двигатель (только для НЗ):      | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить питание ЦБ (имитация потери связи с ЦБ)
    */
    /*!
        Питание ЦБ выключено
        Связь R6 с ЦБ потеряна
    */
    p_gen6->off();

    /*!
        Шаг 2. Ожидать 60 секунд
    */
    /*!
        Блокировка R6 не включилась
    */
    if (!waitR6Block(ON, TIME_DELAY::R6_IGN_CHECK_AFTER_CONN_LOST_DELAY_S + TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Блокировка R6 не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка R6 включилась\n");
    }
}

// 20. Пропала связь с ЦБ и восстановилась менее чем через 60 сек
void AutoTestsModesP2::C187481_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187478) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Снято с охраны
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать только заведенный двигатель (только для НЗ):      | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить питание ЦБ (имитация потери связи с ЦБ)
    */
    /*!
        Питание ЦБ выключено
        Связь R6 с ЦБ потеряна
    */

    /*!
        Шаг 2. Через 20 секунд включить питание ЦБ
    */
    /*!
        Связь с ЦБ восстановлена
        Блокировка R6 не включилась
    */
    if (!resetAndSetGen6VccAndCheckR6Block(TIME_DELAY::TWENTY_S))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }
}

// 21. Связь с ЦБ восстановилась более чем через 60 сек
void AutoTestsModesP2::C187482_TestCase()
{
    Timer alarm_timer;        // Таймер тревоги
    float block_check_time_s; // Время проверки блокировки во время тревоги


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c187478) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                 | Охрана
        ||Зажигание:                                                    | выключено
        ||R6:                                                           | включен
        ||Настройки:
        ||Блокировать двигатель в АО только при нажатии педали тормоза: | Выключено (галочка не стоит)
        ||Блокировка двигателя №1, Блокировка двигателя R6:
        ||Тип блокировки:                                               | НЗ (Нормально замкнутая)
        ||Блокировать только заведенный двигатель (только для НЗ):      | Выключено (галочка не стоит)
        ||Задержка блокировки, с:                                       | 0 секунд (без задержки)
        ||Внутренние тайминги системы (R6):
        ||Время ожидания восстановления связи с ЦБ:                     | 60 секунд
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить питание ЦБ (имитация потери связи с ЦБ)
    */
    /*!
        Питание ЦБ выключено
    */
    p_gen6->off();

    /*!
        Шаг 2. Ожидать 2 минуты (время большее, чем 'Время ожидания восстановления связи с ЦБ' + время потери ЦБ)
    */
    /*!
        Блокировка R6 не включилась
    */
    if (!waitR6Block(ON, TIME_DELAY::TWO_MINUTE))
    {
        printf("PASS Шаг 2. Блокировка не включилась\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка включилась\n");
        return;
    }

    /*!
        Шаг 3. Включить питание ЦБ
    */
    /*!
        Связь с ЦБ восстановлена
        Тревога
        Блокировка R6 включилась
    */
    p_gen6->on();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S + TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Тревога не включена\n");
        return;
    }

    alarm_timer.start();

    if (waitR6Block(ON, TIME_DELAY::R6_CONN_WAIT_TIME_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка R6 включена\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка R6 не включена\n");
        return;
    }

    /*!
        Шаг 4. Дождаться окончания тревоги
    */
    /*!
        Тревога окончена
        Блокировка R6 выключилась
    */
    block_check_time_s = TIME_DELAY::ALARM_DIS_TIME_S - alarm_timer.read() - TIME_DELAY::ALARM_DIS_ERROR_TIME_S; // Посчитать, сколько осталось времени работы тревоги после проверок
                                                                                                                 // И вычесть погрешность выключения тревоги

    if (block_check_time_s > TIME_DELAY::NULL_DELAY_S) // Проверяем только в том случае, если есть время на проверку
    {
        if (!waitR6Block(OFF, block_check_time_s))
        {
            printf("PASS Шаг 4. Блокировка не выключилась раньше времени\n");
        }
        else
        {
            printf("FAIL Шаг 4. Блокировка выключилась раньше времени\n");
            return;
        }
    }

    if (waitR6Block(OFF, TIME_DELAY::ALARM_DIS_ERROR_TIME_S * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S + TIME_DELAY::MAX_R6_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 4. Блокировка R6 выключилась\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка R6 не выключилась\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               OFF,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 4. Тревога окончена\n");
    }
    else
    {
        printf("FAIL Шаг 4. Тревога не окончена\n");
    }
}

// Прерывание тревоги по ДД без дозапирания
void AutoTestsModesP2::C3777171_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE // Нужен хотя бы один из модулей: R868 или BLE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Охрана
        ||Периметр:                          | не нарушен
        ||Настройки:
        ||Настроен:                          | ДД
        ||Настроен:                          | ДН
        ||Настроен:                          | ДУ
        ||Настроен выход:                    | ЦЗ закрыть
    */

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Включилась тревога
    */

    /*!
        Шаг 2. Прервать тревогу брелоком (нажать кнопку 2)
    */
    /*!
        Тревога прекратилась
        Запирание ЦЗ не произошло в течение 10 сек (импульс на выходе ЦЗ закрыть отсутствует)
    */
    if (!setSecureAndSensorAndCheckAlert(DIAG_SENSOR_BIT_MOVE))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Прерывание тревоги по ДН без дозапирания
void AutoTestsModesP2::C3777172_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE // Нужен хотя бы один из модулей: R868 или BLE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Охрана
        ||Периметр:                          | не нарушен
        ||Настройки:
        ||Настроен:                          | ДД
        ||Настроен:                          | ДН
        ||Настроен:                          | ДУ
        ||Настроен выход:                    | ЦЗ закрыть
    */

    /*!
        Шаг 1. Вызвать срабатывание ДН
    */
    /*!
        Сработал ДН
        Включилась тревога
    */

    /*!
        Шаг 2. Прервать тревогу брелоком (нажать кнопку 2)
    */
    /*!
        Тревога прекратилась
        Запирание ЦЗ не произошло в течение 10 сек (импульс на выходе ЦЗ закрыть отсутствует)
    */
    if (!setSecureAndSensorAndCheckAlert(DIAG_SENSOR_BIT_TILT))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Прерывание тревоги по ДУ без дозапирания
void AutoTestsModesP2::C3777173_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE // Нужен хотя бы один из модулей: R868 или BLE
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                      | Охрана
        ||Периметр:                          | не нарушен
        ||Настройки:
        ||Настроен:                          | ДД
        ||Настроен:                          | ДН
        ||Настроен:                          | ДУ
        ||Настроен выход:                    | ЦЗ закрыть
    */

    /*!
        Шаг 1. Вызвать срабатывание ДУ
    */
    /*!
        Сработал ДУ
        Включилась тревога
    */

    /*!
        Шаг 2. Прервать тревогу брелоком (нажать кнопку 2)
    */
    /*!
        Тревога прекратилась
        Запирание ЦЗ не произошло в течение 10 сек (импульс на выходе ЦЗ закрыть отсутствует)
    */
    if (!setSecureAndSensorAndCheckAlert(DIAG_SENSOR_BIT_SHOCK_HIGH))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Открытие багажника с включенным брелоком
void AutoTestsModesP2::C4045282_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045282) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | включен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | вкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Не позднее 10 сек включена охрана с открытым багажником
        Тревога не включилась
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_ON,
                                        ALERT_OFF))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с включенной меткой
void AutoTestsModesP2::C4045283_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045283) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | включена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | вкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Не позднее 10 сек включена охрана с открытым багажником
        Тревога не включилась
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_ON,
                                        REMOTE_OFF,
                                        ALERT_OFF))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с выключенным брелоком с последующим включением
void AutoTestsModesP2::C4045284_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045282) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | вкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск брелока) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок обнаружен
        Тревога отключена
        Переход в охрану с открытым багажником
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_OFF,
                                      REMOTE_ON,
                                      ALERT_OFF))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с выключенной меткой с последующим включением
void AutoTestsModesP2::C4045285_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045283) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | вкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск метки) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1.\n");
        return;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Тревога отключена
        Переход в охрану с открытым багажником
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_ON,
                                      REMOTE_OFF,
                                      ALERT_OFF))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с включенным брелоком
void AutoTestsModesP2::C4045286_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045286) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | включен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Не позднее 10 сек включена охрана с открытым багажником
        Тревога не включилась
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_ON,
                                        ALERT_OFF))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с включенной меткой
void AutoTestsModesP2::C4045287_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045286) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | включена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Не позднее 10 сек включена охрана с открытым багажником
        Тревога не включилась
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_ON,
                                        REMOTE_OFF,
                                        ALERT_OFF))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с выключенным брелоком с последующим включением
void AutoTestsModesP2::C4045288_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045286) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск брелока) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок обнаружен
        Тревога отключена
        Переход в охрану с открытым багажником произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_OFF,
                                      REMOTE_ON,
                                      ALERT_OFF))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с выключенной меткой с последующим включением
void AutoTestsModesP2::C4045289_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045286) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск метки) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Тревога не отключена (продолжается)
        Переход в охрану с нарушенным периметром / с открытым багажником не произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_ON,
                                      REMOTE_OFF,
                                      ALERT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с включенным брелоком
void AutoTestsModesP2::C4045290_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045290) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | включен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | вкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
        Охрана с нарушенным периметром не включена
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_ON,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с включенной меткой
void AutoTestsModesP2::C4045291_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045291) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | включена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | вкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
        Охрана с нарушенным периметром не включена
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_ON,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с выключенным брелоком с последующим включением
void AutoTestsModesP2::C4045292_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045290) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | вкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск брелока) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок обнаружен
        Тревога не отключена (продолжается)
        Переход в охрану с нарушенным периметром не произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_OFF,
                                      REMOTE_ON,
                                      ALERT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с выключенной меткой с последующим включением
void AutoTestsModesP2::C4045293_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045291) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | вкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск метки) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Тревога не отключена (продолжается)
        Переход в охрану с нарушенным периметром не произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_ON,
                                      REMOTE_OFF,
                                      ALERT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с включенным брелоком
void AutoTestsModesP2::C4045294_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045294) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | включен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
        Охрана с нарушенным периметром не включена
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_ON,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с включенной меткой
void AutoTestsModesP2::C4045295_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045294) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | включена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включилась тревога
        Охрана с нарушенным периметром не включена
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_ON,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Открытие багажника с выключенным брелоком с последующим включением
void AutoTestsModesP2::C4045296_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045294) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск брелока) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок обнаружен
        Тревога не отключена (продолжается)
        Переход в охрану с нарушенным периметром не произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_OFF,
                                      REMOTE_ON,
                                      ALERT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Открытие багажника с выключенной меткой с последующим включением
void AutoTestsModesP2::C4045297_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4045294) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | нет
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск метки) включилась Тревога по багажнику
    */
    if (!setSecureAndTrunkAndCheckAlarm(TAG_OFF,
                                        REMOTE_OFF,
                                        ALERT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Тревога не отключена (продолжается)
        Переход в охрану с нарушенным периметром не произошел
    */
    if (!setTagAndRemoteAndCheckAlarm(TAG_ON,
                                      REMOTE_OFF,
                                      ALERT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 1. Включение зажигания
void AutoTestsModesP2::C187456_TestCase()
{
    if (settings_check(p_c187457) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:     | Охрана
        ||Зажигание:        | выключено (двигатель выключен)
    */
    p_gen6->setR4Vcc();
    p_gen6->resetR4Ign();
    wait(TIME_DELAY::R4_VCC_INIT_WAIT_TIME_S);

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Включение зажигания
    */
    /*!
        Включается тревога
        Включается блокировка двигателя R4:
        - на серый провод Output реле R4 подает питание (-)
        - реле R4 размыкает контакт COM и NC
        - реле R4 замыкает контакт COM и NO
    */
    p_gen6->setR4Ign();
    p_gen6->setIgn(PIN, ON);

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    if (p_gen6->waitR4Output(ON))
    {
        printf("PASS Шаг 1. Серый провод Output реле R4 включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Серый провод Output реле R4 не включен\n");
        return;
    }

    // Проверяем только контакт NO, контакт NC не подключен к стенду
    if (p_gen6->waitR4Block(ON))
    {
        printf("PASS Шаг 1. Блокировка включена (реле R4 замыкает контакт COM и NO)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не включена (реле R4 не замыкает контакт COM и NO)\n");
        return;
    }

    /*!
        Выключение зажигания
    */
    /*!
        Выключается блокировка двигателя R4:
        - c серого провода Output реле R4 снимается питание (-)
        - реле R4 размыкает контакт COM и NO
        - реле R4 замыкает контакт COM и NC
    */
    p_gen6->resetR4Ign();

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 2. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не выключено\n");
        return;
    }

    if (p_gen6->waitR4Output(OFF, TIME_DELAY::MAX_R4_SIGNAL_WAIT_TIME_S))
    {
        printf("PASS Шаг 2. Серый провод Output реле R4 выключен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Серый провод Output реле R4 не выключен\n");
    }

    // Проверяем только контакт NO, контакт NC не подключен к стенду
    if (p_gen6->waitR4Block(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Шаг 2. Блокировка выключена (реле R4 размыкает контакт COM и NO)\n");
    }
    else
    {
        printf("FAIL Шаг 2. Блокировка не выключена (реле R4 не размыкает контакт COM и NO)\n");
    }
}

// Выключение сервиса по расстоянию
void AutoTestsModesP2::C4363738_TestCase()
{
    if (settings_check(p_c4363738) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверить, что выход из сервиса не произойдет без зажигания*
        ||Состояние стенда:
        ||Сервисный режим:                                     | включен
        ||Настроен:                                            | ДД
        ||Авторизация владельца:                               | метка, брелок
        ||Настроен CAN-автомобиль:                             | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                            | 0 км/ч
        ||Выход из сервисного режима:                          | по превышению пройденного расстояния
        ||Порог пройденного расстояния:                        | 100 м
        ||Порог скорости:                                      | 20 км/ч
        ||СМС оповещение о включении/выключении режима Сервис: | вкл
        ||Зажигание:                                           | выключено
    */

    /*!
        Шаг 1. Включить скорость 40 км/ч (CAN / GPS)
    */
    /*!
        Скорость: 40 км/ч
    */

    /*!
        Шаг 2. Через 10 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
        СМС оповещение о выходе из сервиса отсутствует
    */
    if (!setAndResetServiceBySensorNoIgn(40, TIME_DELAY::TEN_S))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Выключение сервиса по скорости
void AutoTestsModesP2::C4363739_TestCase()
{
    if (settings_check(p_c4363739) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверить, что выход из сервиса не произойдет без зажигания*
        ||Состояние стенда:
        ||Сервисный режим:                                     | включен
        ||Настроен:                                            | ДД
        ||Авторизация владельца:                               | метка, брелок
        ||Настроен CAN-автомобиль:                             | Batmobile (Скорость автомобиля: вкл)
        ||Скорость:                                            | 0 км/ч
        ||Выход из сервисного режима:                          | при привешении заданной скорости
        ||Порог пройденного расстояния:                        | 500 м
        ||Порог скорости:                                      | 15 км/ч
        ||СМС оповещение о включении/выключении режима Сервис: | вкл
        ||Зажигание:                                           | выключено
    */

    /*!
        Шаг 1. Включить скорость 16 км/ч (CAN / GPS)
    */
    /*!
        Скорость: 16 км/ч
    */

    /*!
        Шаг 2. Через 6 сек Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Выключение Сервиса и переход в Ожидание авторизации не произошли
        СМС оповещение о выходе из сервиса отсутствует
    */
    if (!setAndResetServiceBySensorNoIgn(16, TIME_DELAY::SIX_S))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// 1. Включение зажигания в запрете поездки при наличии метки
void AutoTestsModesP2::C4466808_TestCase()
{
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что при наличии метки запрет поездки выключается только при включении зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из запрета поездки в снято
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_ON))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 2. Исчезновение метки в запрете поездки при выключенном зажигании
void AutoTestsModesP2::C4466809_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что при наличии метки запрет поездки выключается только при включении зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(disarm_execution_method,
                                     TAG_ON))
    {
        printf("FAIL Шаг 1\n");
        is_fail = true;
    }

    /*!
        Шаг 2. Выключить метку
    */
    /*!
        Метка потеряна
        Запрет поездки остался активным
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    OFF,
                                    TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Запрет поездки остался активным\n");
        }
        else
        {
            printf("FAIL Шаг 2. Запрет поездки не остался активным\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 3. Появление метки в запрете поездки при выключенном зажигании
void AutoTestsModesP2::C4466810_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что при появлении метки запрет поездки не выключается без включения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | выключена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */
    if (!setArmAndDisarmAndCheckImmo(disarm_execution_method,
                                     TAG_OFF))
    {
        printf("FAIL Шаг 1\n");
        is_fail = true;
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Запрет поездки остался активным
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    OFF,
                                    TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Запрет поездки остался активным\n");
        }
        else
        {
            printf("FAIL Шаг 2. Запрет поездки не остался активным\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 4. Включение зажигания в запрете поездки при отсутствии метки
void AutoTestsModesP2::C4466811_TestCase()
{
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что запрет поездки активен без метки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | выключена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Запрет поездки остался активным
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 5. Выключение зажигания в запрете поездки при отсутствии метки
void AutoTestsModesP2::C4466812_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что на запрет поездки не влияет зажигание без метки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | выключена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Запрета поездки остался активным
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_OFF))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Запрет поездки остался активным
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 3. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    OFF,
                                    TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 3. Запрет поездки остался активным\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки не остался активным\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 6. Появление метки в запрете поездки при включенном зажигании
void AutoTestsModesP2::C4466813_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что запрет поездки выключается меткой при включенном зажигании*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | выключена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Запрет поездки остался активным
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_OFF))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Переход из запрета поездки в снято
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                   ON,
                                   TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из запрета поездки в снято\n");
        }
        else
        {
            printf("FAIL Шаг 3. Переход из запрета поездки в снято не произошел\n");
            is_fail = true;
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 7. Выключение зажигания в снято при отсутствии метки
void AutoTestsModesP2::C4466814_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что без зажигания включается запрет поездки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из запрета поездки в снято
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_ON))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
        Переход из снято в запрет поездки не произошел
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из снято в запрет поездки не произошел\n");
        }
        else
        {
            printf("FAIL Шаг 3. Произошел переход из снято в запрет поездки\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход из снято в запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 4. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 4. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 4. Переход из снято в запрет поездки\n");
        }
        else
        {
            printf("FAIL Шаг 4. Переход из снято в запрет поездки не произошел\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 8. Появление метки в снято при включенном зажигании
void AutoTestsModesP2::C4466815_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что метка не влияет на запрет поездки после его отключения*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из запрета поездки в снято
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_ON))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
        Переход из снято в запрет поездки не произошел
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из снято в запрет поездки не произошел\n");
        }
        else
        {
            printf("FAIL Шаг 3. Произошел переход из снято в запрет поездки\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Включить метку
    */
    /*!
        Метка найдена
        Переход из снято в запрет поездки не произошел
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 4. Переход из снято в запрет поездки не произошел\n");
        }
        else
        {
            printf("FAIL Шаг 4. Произошел переход из снято в запрет поездки\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 9. Исчезновение метки в снято при включенном зажигании
void AutoTestsModesP2::C4466816_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что метка не влияет на запрет поездки после его отключения*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из запрета поездки в снято
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_ON))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
        Переход из снято в запрет поездки не произошел
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из снято в запрет поездки не произошел\n");
        }
        else
        {
            printf("FAIL Шаг 3. Произошел переход из снято в запрет поездки\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// 10. Выключение зажигания в снято при наличии метки
void AutoTestsModesP2::C4466817_TestCase()
{
    bool           is_fail                 = false;
    command_type_t disarm_execution_method = getExecutionMethodDisarmNoTag();


    if (disarm_execution_method == ERROR_TYPE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c3136858) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, что зажигание влияет на запрет поездки после его отключения*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Метка:                               | включена
        ||Зажигание:                           | выключено
        ||Настройки:
        ||Снятие запрета поездки:              | по метке
        ||Условие активации запрета поездки:   | при каждом выключении зажигания
    */

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из запрета поездки в снято
    */
    if (!setArmAndDisarmAndCheckImmoAndSetIgn(disarm_execution_method,
                                              TAG_ON))
    {
        printf("FAIL Шаг 1-2\n");
        is_fail = true;
    }

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Переход из снято в запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 3. Зажигание выключено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не выключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
        {
            printf("PASS Шаг 3. Переход из снято в запрет поездки\n");
        }
        else
        {
            printf("FAIL Шаг 3. Переход из снято в запрет поездки не произошел\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек Мастера\n");
    }
}

// Исчезновение метки при наличии брелока
void AutoTestsModesP2::C4360828_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360828)
        ||  settings_check(p_c4360828) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО не включается, когда оно отключено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при наличии метки
void AutoTestsModesP2::C4360829_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360828)
        ||  settings_check(p_c4360828) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО не включается, когда оно отключено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при отсутствии брелока
void AutoTestsModesP2::C4360830_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360828)
        ||  settings_check(p_c4360828) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО не включается, когда оно отключено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | выключен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при отсутствии метки
void AutoTestsModesP2::C4360831_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360828)
        ||  settings_check(p_c4360828) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО не включается, когда оно отключено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при наличии брелока
void AutoTestsModesP2::C4360832_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360832)
        ||  settings_check(p_c4360832) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по метке включается при наличии брелока, когда АО по метке включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при наличии метки
void AutoTestsModesP2::C4360833_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360832)
        ||  settings_check(p_c4360832) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по брелоку не включается при наличии метки, когда АО по метке включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при отсутствии брелока
void AutoTestsModesP2::C4360834_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360832)
        ||  settings_check(p_c4360832) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по метке включается при отсутствии брелока, когда АО по метке включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | выключен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при отсутствии метки
void AutoTestsModesP2::C4360835_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360832)
        ||  settings_check(p_c4360832) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по метке включается при потере брелока, когда АО по метке включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | выключено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при наличии брелока
void AutoTestsModesP2::C4360836_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360836)
        ||  settings_check(p_c4360836) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по метке не включается при наличии брелока, когда АО по брелоку включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) не включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) не включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) не включилось АО и не включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_OFF))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при наличии метки
void AutoTestsModesP2::C4360837_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360836)
        ||  settings_check(p_c4360836) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по брелоку включается при наличии метки, когда АО по брелоку включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по брелоку)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_REMOTE))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при отсутствии брелока
void AutoTestsModesP2::C4360838_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360836)
        ||  settings_check(p_c4360836) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по брелоку включается при потере метки, когда АО по брелоку включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | выключен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при отсутствии метки
void AutoTestsModesP2::C4360839_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360836)
        ||  settings_check(p_c4360836) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по брелоку включается при отсутствии метки, когда АО по брелоку включено в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | выключено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при наличии брелока
void AutoTestsModesP2::C4360840_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360840)
        ||  settings_check(p_c4360840) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по метке включается при наличии брелока, когда АО по метке и брелоку включены в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по брелоку)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_REMOTE))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при наличии метки
void AutoTestsModesP2::C4360841_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360840)
        ||  settings_check(p_c4360840) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО по брелоку включается при наличии метки, когда АО по метке и брелоку включены в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по брелоку)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_REMOTE))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение метки при отсутствии брелока
void AutoTestsModesP2::C4360842_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360840)
        ||  settings_check(p_c4360840) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО включается при потере метки, когда АО по метке и брелоку включены в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | включена
        ||Брелок:                                              | выключен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_TAG_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Исчезновение брелока при отсутствии метки
void AutoTestsModesP2::C4360843_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c4360840)
        ||  settings_check(p_c4360840) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка того, АО включается при отсутствии метки, когда АО по метке и брелоку включены в настройках*
        ||Состояние стенда:
        ||Охрана:                                              | выключена
        ||Зажигание:                                           | включено
        ||Дверь:                                               | открыта
        ||Паркинг:                                             | выключен
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Настройки:
        ||АО по метке:                                         | включено
        ||АО по брелоку:                                       | включено
        ||АО, шаг 1: время до начала поиска метки или брелока: | 10
        ||АО, шаг 2: время поиска метки или брелока:           | 5
        ||АО, шаг 3: предупреждение звуковым извещателем:      | 5
        ||АО, шаг 4: предупреждение сиреной:                   | 5
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 15 сек (время до начала поиска+время поиска) включился звуковой извещатель
        Через 5 сек (время предупреждения звуковым извещателем) выключился звуковой извещатель и включилось предупреждение сиреной
        Через 5 сек (время предупреждения сиреной) выключилось предупреждение сиреной
        Включилось АО (по метке)
        Включилась тревога
    */
    if (!resetTagOrRemoteAndCheckAhj(AHJ_TYPE_REMOTE_OFF,
                                     AHJ_STATUS_TAG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Открытие двери в охране с включенной меткой
void AutoTestsModesP2::C4559714_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика дверей
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR, AUTH_STEP_START))
    {
        printf("FAIL Шаг 1\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Открытие двери водителя в охране с включенной меткой
void AutoTestsModesP2::C4559715_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь водителя:                                                | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери водителя
    */

    /*!
        Шаг 1. Открыть дверь водителя
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_DRIVER, AUTH_STEP_START))
    {
        printf("FAIL Шаг 1\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Открытие двери пассажира в охране с включенной меткой
void AutoTestsModesP2::C4559716_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь пассажира:                                               | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери пассажира
    */

    /*!
        Шаг 1. Открыть дверь пассажира
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_PASSENGER, AUTH_STEP_START))
    {
        printf("FAIL Шаг 1\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Открытие багажника в охране с включенной меткой
void AutoTestsModesP2::C4559717_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика багажника
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Переход в тревогу отсутствует
        Переход из охраны в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_TRUNK, AUTH_STEP_START))
    {
        printf("FAIL Шаг 1\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 1 авторизации после открытия двери
void AutoTestsModesP2::C4559718_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | выключена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика дверей
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR, AUTH_STEP_ONE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 1 авторизации после открытия двери водителя
void AutoTestsModesP2::C4559719_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь водителя:                                                | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери водителя
    */

    /*!
        Шаг 1. Открыть дверь водителя
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_PASSENGER, AUTH_STEP_ONE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 1 авторизации после открытия двери пассажира
void AutoTestsModesP2::C4559720_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь пассажира:                                               | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери пассажира
    */

    /*!
        Шаг 1. Открыть дверь пассажира
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_PASSENGER, AUTH_STEP_ONE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 1 авторизации после открытия багажника
void AutoTestsModesP2::C4559721_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика багажника
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
    */
    if (!setZoneAndCheckAuth(ZONE_TRUNK, AUTH_STEP_ONE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 2 авторизации после открытия двери
void AutoTestsModesP2::C4559722_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | выключена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика дверей
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Встроенный или внешний звуковой извещатель отключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR, AUTH_STEP_TWO))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 2 авторизации после открытия двери водителя
void AutoTestsModesP2::C4559723_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь водителя:                                                | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери водителя
    */

    /*!
        Шаг 1. Открыть дверь водителя
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Встроенный или внешний звуковой извещатель отключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_DRIVER, AUTH_STEP_TWO))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 2 авторизации после открытия двери пассажира
void AutoTestsModesP2::C4559724_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь пассажира:                                               | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери пассажира
    */

    /*!
        Шаг 1. Открыть дверь пассажира
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Встроенный или внешний звуковой извещатель отключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_PASSENGER, AUTH_STEP_TWO))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 2 авторизации после открытия багажника
void AutoTestsModesP2::C4559725_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика багажника
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Встроенный или внешний звуковой извещатель отключается
    */
    if (!setZoneAndCheckAuth(ZONE_TRUNK, AUTH_STEP_TWO))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 3 авторизации после открытия двери
void AutoTestsModesP2::C4559726_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | выключена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика дверей
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
        Через 10 сек (ожидание авторизации, шаг 2: предупреждение встроенным или внешним звуковым извещателем) выключается встроенный или внешний звуковой извещатель
        Включается предупреждение сиреной и световыми сигналами
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Предупреждение сиреной и световыми сигналами выключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR, AUTH_STEP_THREE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 3 авторизации после открытия двери водителя
void AutoTestsModesP2::C4559727_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь водителя:                                                | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери водителя
    */

    /*!
        Шаг 1. Открыть дверь водителя
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
        Через 10 сек (ожидание авторизации, шаг 2: предупреждение встроенным или внешним звуковым извещателем) выключается встроенный или внешний звуковой извещатель
        Включается предупреждение сиреной и световыми сигналами
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Предупреждение сиреной и световыми сигналами выключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_DRIVER, AUTH_STEP_THREE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 3 авторизации после открытия двери пассажира
void AutoTestsModesP2::C4559728_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь пассажира:                                               | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика двери пассажира
    */

    /*!
        Шаг 1. Открыть дверь пассажира
    */
    /*!
        Дверь открыта
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
        Через 10 сек (ожидание авторизации, шаг 2: предупреждение встроенным или внешним звуковым извещателем) выключается встроенный или внешний звуковой извещатель
        Включается предупреждение сиреной и световыми сигналами
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Предупреждение сиреной и световыми сигналами выключается
    */
    if (!setZoneAndCheckAuth(ZONE_DOOR_PASSENGER, AUTH_STEP_THREE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Включить метку во время шага 3 авторизации после открытия багажника
void AutoTestsModesP2::C4559729_TestCase()
{
    if (settings_check(p_c4559714) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        ||Состояние стенда:
        ||Автомобиль в:                                                  | Охрана
        ||Дверь:                                                         | закрыта
        ||Багажник:                                                      | закрыт
        ||Метка:                                                         | включена
        ||Брелок:                                                        | включен
        ||Настройки:
        ||Авторизация по Метке:                                          | вкл
        ||Авторизация по Брелоку:                                        | выкл
        ||Событие запуска авторизации при открытии двери или багажника:  | открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                   | 15 сек
        ||Ожидание авторизации, шаг 2:                                   | 10 сек
        ||Ожидание авторизации, шаг 3:                                   | 10 сек
        ||Настроен вход:                                                 | вход концевика багажника
    */

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Переход в тревогу отсутствует
        Переход из охраны в ожидание авторизации
        Через 15 сек (ожидание авторизации, шаг 1: время поиска метки или брелока) включается встроенный или внешний звуковой извещатель
        Через 10 сек (ожидание авторизации, шаг 2: предупреждение встроенным или внешним звуковым извещателем) выключается встроенный или внешний звуковой извещатель
        Включается предупреждение сиреной и световыми сигналами
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
        Переход в тревогу отсутствует
        Переход из авторизации в снято (прошла авторизация по метке)
        Предупреждение сиреной и световыми сигналами выключается
    */
    if (!setZoneAndCheckAuth(ZONE_TRUNK, AUTH_STEP_THREE))
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// НЗ блокировка заглушенного двигателя
void AutoTestsModesP2::C4559732_TestCase()
{
    if (settings_check(p_c4559732) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки*
        ||Состояние стенда:
        ||Автомобиль в:                              | Охрана
        ||Выход блокировки:                          | не активен (блокировка выключена)
        ||Выход блокировки R6:                       | не активен (блокировка выключена)
        ||Зажигание:                                 | выключено
        ||Обороты:                                   | выключены
        ||Двигатель:                                 | заглушен
        ||Настройки:
        ||Подключен:                                 | R6
        ||Настроен выход:                            | блокировка двигателя N1
        ||Тип блокировки  двигателя N1:              | НЗ
        ||Блокировать только заведенный двигатель:   | нет
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Тревога включена
        Включен выход блокировки основного блока
        Включен выход блокировки R6
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 2. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 3. Отключить тревогу кнопкой 2 брелока
    */
    /*!
        Переход из тревоги в охрану
        Выход блокировки основного блока отключен
        Выход блокировки R6 отключен
    */
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        p_gen6->pushTagBtn(TAG_SHORT);
    }
    else
    {
        p_gen6->setSecure(OFF,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Переход из тревоги в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 3. Переход из тревоги в охрану не произведен\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_OFF))
    {
        printf("FAIL Шаг 3\n");
    }
}

// НЗ блокировка заведенного двигателя
void AutoTestsModesP2::C4559733_TestCase()
{
    float block_err_time_s; // Погрешность выключения блокировки


    if (settings_check(p_c4559733) == 0)
    {
        return;
    }

    if (m_eng_block_local0_block_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Длительность блокировки\" не задана\n");
        return;
    }

    block_err_time_s = TimeoutCalculator::calcToutError(m_eng_block_local0_block_s);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки*
        ||Состояние стенда:
        ||Автомобиль в:                              | Охрана
        ||Выход блокировки:                          | не активен (блокировка выключена)
        ||Выход блокировки R6:                       | не активен (блокировка выключена)
        ||Зажигание:                                 | выключено
        ||Обороты:                                   | выключены
        ||Двигатель:                                 | заглушен
        ||Настройки:
        ||Подключен:                                 | R6
        ||Настроен выход:                            | блокировка двигателя N1
        ||Тип блокировки  двигателя N1:              | НЗ
        ||Блокировать при срабатывании ДД:           | да
        ||Задержка блокировки:                       | 0 сек
        ||Длительность блокировки:                   | 6 сек
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Тревога включена
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
        return;
    }

    /*!
        Шаг 2. Включить обороты
    */
    /*!
        Двигатель заведен
        Не Включен выход блокировки основного блока
        Не Включен выход блокировки R6
    */
    p_gen6->setEngine(ON, PIN);

    if (!waitStdAndR6Block(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить обороты
    */
    /*!
        Двигатель заглушен
        Не Включен выход блокировки основного блока
        Не Включен выход блокировки R6
    */
    p_gen6->setEngine(OFF,
                      PIN,
                      RPM_OFF);

    if (!waitStdAndR6Block(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включен выход блокировки основного блока
        Включен выход блокировки R6
        Через 6 сек. (Длительность блокировки) выходы блокировки основного блока и блокировки R6 отключены
    */
    p_gen6->setMoveSensor();

    if (!waitStdAndR6Block(BLOCK_ON))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_NOT_OFF,
                           m_eng_block_local0_block_s - block_err_time_s))
    {
        printf("FAIL Шаг 4. Блокировка отключилась раньше времени\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_OFF,
                           block_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
    {
        printf("FAIL Шаг 4. Блокировка не отключилась в ожидаемом диапазоне времени\n");
        return;
    }

    /*!
        Шаг 5. Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 5. Зажигание отключено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не отключено\n");
        return;
    }
    
    /*!
        Шаг 6. Отключить тревогу кнопкой 2 брелока
    */
    /*!
        Переход из тревоги в охрану
    */
    p_gen6->setSecureNoDelay(OFF, KEYRING);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 6. Переход из тревоги в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 6. Переход из тревоги в охрану не произведен\n");
    }
}

// НР блокировка при снятии с охраны
void AutoTestsModesP2::C4559734_TestCase()
{
    if (settings_check(p_c4559734) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения и включения блокировки*
        ||Состояние стенда:
        ||Автомобиль в:                  | Охрана
        ||Выход блокировки:              | не активен (блокировка включена)
        ||Выход блокировки R6:           | не активен (блокировка включена)
        ||Зажигание:                     | выключено
        ||Обороты:                       | выключены
        ||Двигатель:                     | заглушен
        ||Настройки:
        ||Подключен:                     | R6
        ||Настроен выход:                | блокировка двигателя N1
        ||Тип блокировки  двигателя N1:  | НР
        ||Снятие блокировки:             | При снятии с охраны
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в снято
        Включен выход блокировки основного блока
        Включен выход блокировки R6
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произведен\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить охрану
    */
    /*!
        Переход в охрану
        Выход блокировки основного блока отключен
        Выход блокировки R6 отключен
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 2. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 2. Переход в охрану не произведен\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_OFF))
    {
        printf("FAIL Шаг 2\n");
    }
}

// НР блокировка при включении зажигания
void AutoTestsModesP2::C4559735_TestCase()
{
    if (settings_check(p_c4559735) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения и включения блокировки*
        ||Состояние стенда:
        ||Автомобиль в:                  | Охрана
        ||Выход блокировки:              | не активен (блокировка включена)
        ||Выход блокировки R6:           | не активен (блокировка включена)
        ||Зажигание:                     | выключено
        ||Обороты:                       | выключены
        ||Двигатель:                     | заглушен
        ||Настройки:
        ||Подключен:                     | R6
        ||Настроен выход:                | блокировка двигателя N1
        ||Тип блокировки  двигателя N1:  | НР
        ||Снятие блокировки:             | При включении зажигания в снято с охраны
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Выключить охрану
    */
    /*!
        Переход в снято
        Выход блокировки основного блока не включен
        Выход блокировки R6 не включен
    */
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        // Метод Gen6Basic::setSecure не может нажать кнопку метки без задержки
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        p_gen6->pushTagBtn(TAG_SHORT);
    }
    else
    {
        p_gen6->setSecure(OFF,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }

    if (!waitStdAndR6Block(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произведен\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Включен выход блокировки основного блока
        Включен выход блокировки R6
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Выход блокировки основного блока отключен
        Выход блокировки R6 отключен
    */
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_EN_DELAY_S); // Чтобы не моментально включать/выключать зажигание

    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 3. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 3. Зажигание не выключено\n");
        return;
    }

    if (!waitStdAndR6Block(BLOCK_OFF))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Включить охрану
    */
    /*!
        Переход в охрану
        Выход блокировки основного блока не включен
        Выход блокировки R6 не включен
    */
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        // Метод Gen6Basic::setSecure не может нажать кнопку метки без задержки
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
        p_gen6->pushTagBtn(TAG_SHORT);
    }
    else
    {
        p_gen6->setSecure(ON,
                          KEYRING,
                          TIME_DELAY::NULL_DELAY_S);
    }

    if (!waitStdAndR6Block(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Шаг 4. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в охрану не произведен\n");
    }
}

// НР блокировка при включении зажигания в охране
void AutoTestsModesP2::C4559751_TestCase()
{
    if (settings_check(p_c4559735) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия отключения блокировки в охране*
        ||Состояние стенда:
        ||Автомобиль в:                  | Охрана
        ||Выход блокировки:              | не активен (блокировка включена)
        ||Выход блокировки R6:           | не активен (блокировка включена)
        ||Зажигание:                     | выключено
        ||Обороты:                       | выключены
        ||Двигатель:                     | заглушен
        ||Настройки:
        ||Подключен:                     | R6
        ||Настроен выход:                | блокировка двигателя N1
        ||Тип блокировки  двигателя N1:  | НР
        ||Снятие блокировки:             | При включении зажигания в снято с охраны
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Выход блокировки основного блока не включен
        Выход блокировки R6 не включен
    */
    p_gen6->setIgn(PIN,
                   ON,
                   TIME_DELAY::NULL_DELAY_S);

    if (!waitStdAndR6Block(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_IGN))
    {
        printf("PASS Шаг 1. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включено\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
    }
}

// Переключение из паркинга в антиограблении
void AutoTestsModesP2::C4686621_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4686621) == 0)
    {
        is_fail = true;
    }

    if (!getAndSetAhjSettings(p_c4686621))
    {
        printf("FAIL Не все настройки АО были заданы\n");
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия блокировки АКПП в антиограблении по команде*
        ||Состояние стенда:
        ||Автомобиль в:                  | антиограбление по команде
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП не включилась (отсутствует)
        Сообщения в CAN ID=1A2 D0=01 отсутствуют (ЦБ их не отсылает)
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_AHJ_CMD, ACT_TYPE_NO_ACT))
        {
            printf("FAIL Шаг 1\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в антиограблении по метке
void AutoTestsModesP2::C4686622_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4686621) == 0)
    {
        is_fail = true;
    }

    if (!getAndSetAhjSettings(p_c4686621))
    {
        printf("FAIL Не все настройки АО были заданы\n");
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия блокировки АКПП в антиограблении по метке*
        ||Состояние стенда:
        ||Автомобиль в:                  | антиограбление по метке
        ||Настройки:
        ||Антиограбление при пропадании: | метки
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    // Вкл. + выкл. охрану на случай, если перед кейсом было снятие кодом
    // Ввод кода экстренного снятия отключает все защитные функции до следующей постановки
    p_gen6->setSecure(ON, KEYRING);
    p_gen6->setSecure(OFF, KEYRING);

    /*!
        Шаг 1. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП не включилась (отсутствует)
        Сообщения в CAN ID=1A2 D0=01 отсутствуют (ЦБ их не отсылает)
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_AHJ_TAG, ACT_TYPE_NO_ACT))
        {
            printf("FAIL Шаг 1\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в снято
void AutoTestsModesP2::C4695722_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия блокировки АКПП в снято*
        ||Состояние стенда:
        ||Автомобиль в:                  | снято
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП не включилась (отсутствует)
        Сообщения в CAN ID=1A2 D0=01 отсутствуют (ЦБ их не отсылает)
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_DISARM, ACT_TYPE_NO_ACT))
        {
            printf("FAIL Шаг 1\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в тревоге с переключением в паркинг
void AutoTestsModesP2::C4695723_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в тревоге*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ALERT_HIGH, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в охране с переключением в паркинг
void AutoTestsModesP2::C4695724_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в охране*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ARM, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в авторизации с переключением в паркинг
void AutoTestsModesP2::C4695725_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695725) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Авторизация:                       | метка
        ||Требовать авторизацию при снятии:  | брелок
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_AUTH, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в запрете поездки с переключением в паркинг
void AutoTestsModesP2::C4695726_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695726) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в запрете поездки*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Снятие запрета поездки:            | метка
        ||Активация запрета поездки:         | при снятии с охраны
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_IMMO, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в охране с открытым багажником с переключением в паркинг
void AutoTestsModesP2::C4695727_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE) // Для отпирания багажника с брелка
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в охране с открытым багажником*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Снятие запрета поездки:            | метка
        ||Активация запрета поездки:         | при снятии с охраны
    */

    /*!
        Шаг 1. Нажать 2 раза на брелоке кнопку "2"
    */
    /*!
        Переход в охрану с открытым багажником
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ARM_TRUNK, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в предупредительной тревоге с переключением в паркинг
void AutoTestsModesP2::C4695728_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения блокировки АКПП в тревоге предупредительной*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
        ||ДУ: предупредительный:         | настроен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДУ предупредительного
    */
    /*!
        ДУ предупредительный сработал
        Включена предупредительная тревога
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Переключить положение АКПП (CAN) в "Р" (из "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ALERT_LOW, ACT_TYPE_PARKING_ON))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в тревоге с переходом в снято
void AutoTestsModesP2::C4695729_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в тревоге и отключение при выходе из охраны*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Выключить тревогу брелоком (кнопка 2)
    */
    /*!
        Тревога отключена
    */

    /*!
        Шаг 4. Выключить охрану брелоком (кнопка 2)
    */
    /*!
        Переход из охраны в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ALERT_HIGH, ACT_TYPE_DISARM))
        {
            printf("FAIL Шаг 1-4\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в охране с переходом в снято
void AutoTestsModesP2::C4695730_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в охране и отключение при выходе из охраны*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 2. Выключить охрану брелоком (кнопка 2)
    */
    /*!
        Переход из охраны в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ARM, ACT_TYPE_DISARM))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в авторизации с переходом в снято
void AutoTestsModesP2::C4695731_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695725) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в авторизации и отключение при переходе в снято*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Авторизация:                       | метка
        ||Требовать авторизацию при снятии:  | брелок
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Переход из авторизации в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_AUTH, ACT_TYPE_AUTH))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в запрете поездки с переходом в снято
void AutoTestsModesP2::C4695732_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695726) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в запрете поездкии и отключения в снято*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Снятие запрета поездки:            | метка
        ||Активация запрета поездки:         | при снятии с охраны
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Переход из запрета поездки в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_IMMO, ACT_TYPE_AUTH))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При сбросе настроек авторизации\n");
    }
}

// Переключение из паркинга в охране с открытым багажником с переходом в снято
void AutoTestsModesP2::C4695733_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE) // Для отпирания багажника с брелка
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в охране с открытым багажником и отключения при переходе в снято*
        ||Состояние стенда:
        ||Автомобиль в:                      | охрана
        ||Брелок:                            | включен
        ||Метка:                             | выключена
        ||Настройки:
        ||Автомобиль CAN:                    | 9942 - Batmobile
        ||Канал Паркинг CAN:                 | настроен
        ||Блокировка АКПП (настройка):       | включена
        ||Снятие запрета поездки:            | метка
        ||Активация запрета поездки:         | при снятии с охраны
    */

    /*!
        Шаг 1. Нажать 2 раза на брелоке кнопку "2"
    */
    /*!
        Переход в охрану с открытым багажником
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Отключить охрану
    */
    /*!
        Переход из охраны в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ARM_TRUNK, ACT_TYPE_DISARM))
        {
            printf("FAIL Шаг 1-3\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Переключение из паркинга в предупредительной тревоге с переходом в снято
void AutoTestsModesP2::C4695734_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c4695722) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения блокировки АКПП в тревоге предупредительной и отключения при переходе в снято*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | включена
        ||ДУ: предупредительный:         | настроен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДУ предупредительного
    */
    /*!
        ДУ предупредительный сработал
        Включена предупредительная тревога
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Включилась блокировка АКПП
        ЦБ отправляет в CAN сообщение ID=1A2 D0=01
    */

    /*!
        Шаг 3. Выключить тревогу брелоком (кнопка 2)
    */
    /*!
        Тревога отключена
    */

    /*!
        Шаг 4. Выключить охрану брелоком (кнопка 2)
    */
    /*!
        Переход из охраны в снято
        Блокировка АКПП отключилась
        ЦБ перестает отправлять в CAN сообщение ID=1A2 D0=01
        ЦБ начинает отправлять в CAN сообщение ID=1A2 D0=00
    */
    if (!is_fail)
    {
        if (!setStateAndCheckGearboxBlock(GUARD_STATE_ALERT_LOW, ACT_TYPE_DISARM))
        {
            printf("FAIL Шаг 1-4\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Авторизация по метке до команды открытия багажника (метка исчезает)
void AutoTestsModesP2::C4801978_TestCase()
{
    bool is_fail = false;


    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801978) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка тревоги без авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку до команды открытия багажника (брелок исчезает)
void AutoTestsModesP2::C4801979_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка тревоги без авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после команды открытия багажника (метка исчезает)
void AutoTestsModesP2::C4801980_TestCase()
{
    bool is_fail = false;


    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801978) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизации нет до открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Выключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после команды открытия багажника (брелок исчезает)
void AutoTestsModesP2::C4801981_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801981) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизации нет до открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Выключить брелок
    */
    /*!
        Брелок потерян
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после открытия багажника (метка исчезает)
void AutoTestsModesP2::C4801982_TestCase()
{
    bool is_fail = false;


    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801978) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизация проходит сразу после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Через 5 сек (Время достаточное для авторизации) выключить метку
    */
    /*!
        Метка потеряна
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_SMART_TAG, TIME_DELAY::STD_AUTH_TIME_S))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после открытия багажника (брелок исчезает)
void AutoTestsModesP2::C4801983_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801981) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизация проходит сразу после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | откл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Через 5 сек (Время достаточное для авторизации) выключить брелок
    */
    /*!
        Брелок потерян
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_REMOTE, TIME_DELAY::STD_AUTH_TIME_S))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после наступления тревоги (метка исчезает)
void AutoTestsModesP2::C4801984_TestCase()
{
    bool is_fail = false;


    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801978) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что после авторизации она не сбрасывается при потере средства авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Через 5 сек (Время достаточное чтобы убедиться, что тревога не наступила) выключить метку
    */
    /*!
        Метка потеряна
        Тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_SMART_TAG, TIME_DELAY::MAX_ALARM_SIGNAL_TIME_S))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после наступления тревоги (брелок исчезает)
void AutoTestsModesP2::C4801985_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801981) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что после авторизации она не сбрасывается при потере средства авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | вкл
        ||Метка:                                                                | вкл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | откл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | выкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(ON))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "открыть багажник" брелоком (нажать 2 раза кнопку "2")
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(KEYRING);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Через 5 сек (Время достаточное чтобы убедиться, что тревога не наступила) выключить брелок
    */
    /*!
        Брелок потерян
        Тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_REMOTE, TIME_DELAY::MAX_ALARM_SIGNAL_TIME_S))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке до команды открытия багажника (метка появляется и исчезает)
void AutoTestsModesP2::C4828410_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка тревоги без авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Выключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку до команды открытия багажника (брелок появляется и исчезает)
void AutoTestsModesP2::C4828411_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка тревоги без авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Включить брелок
    */
    /*!
        Брелок найден
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Выключить брелок
    */
    /*!
        Брелок потерян
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 3. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после команды открытия багажника (метка появляется и исчезает)
void AutoTestsModesP2::C4828412_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизации нет до открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 4. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после команды открытия багажника (брелок появляется и исчезает)
void AutoTestsModesP2::C4828413_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизации нет до открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок найден
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Выключить брелок
    */
    /*!
        Брелок потерян
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(OFF);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 4. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после открытия багажника (метка появляется и исчезает)
void AutoTestsModesP2::C4828414_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828414) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизация проходит после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 20 сек
        ||Ожидание авторизации, шаг 1                                           | 20 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 4. Через 5 сек (Время достаточное для авторизации) выключить метку
    */
    /*!
        Метка потеряна
        Через 20 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_SMART_TAG, TIME_DELAY::MAX_AUTH_TIME_S))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после открытия багажника (брелок появляется и исчезает)
void AutoTestsModesP2::C4828415_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что авторизация проходит после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | откл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить брелок
    */
    /*!
        Брелок найден
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    /*!
        Шаг 4. Через 10 сек (Время достаточное для авторизации) выключить брелок
    */
    /*!
        Брелок потерян
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) после открытия багажника тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_REMOTE, TIME_DELAY::MAX_AUTH_TIME_S))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после наступления тревоги (метка появляется и исчезает)
void AutoTestsModesP2::C4828416_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения тревоги после авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Переход из тревоги в охрану с открытым багажником
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_AUTH_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из тревоги в охрану с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 3. \"Охрана с открытым багажником\" не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
        Тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_SMART_TAG))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после наступления тревоги (брелок появляется и исчезает)
void AutoTestsModesP2::C4828417_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения тревоги после авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить брелок
    */
    /*!
        Брелок найден
        Переход из тревоги в охрану с открытым багажником
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_AUTH_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из тревоги в охрану с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 3. \"Охрана с открытым багажником\" не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 4. Выключить брелок
    */
    /*!
        Брелок потерян
        Тревога не включилась
    */
    if (!is_fail)
    {
        if (!resetTagOrRemoteAndCheckAlarm(AUTH_REMOTE))
        {
            printf("FAIL Шаг 4\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке до команды открытия багажника (метка появляется)
void AutoTestsModesP2::C4828418_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации до команды открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку до команды открытия багажника (брелок появляется)
void AutoTestsModesP2::C4828419_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации до команды открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }
    /*!
        Шаг 1. Включить брелок
    */
    /*!
        Брелок найден
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после команды открытия багажника (метка появляется)
void AutoTestsModesP2::C4828420_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации после команды открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка найдена
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после команды открытия багажника (брелок появляется)
void AutoTestsModesP2::C4828421_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации после команды открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок найден
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);
        p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S);
    }

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_OFF))
        {
            printf("FAIL Шаг 3\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после открытия багажника (метка появляется)
void AutoTestsModesP2::C4828422_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Через 15 сек после открытия багажника (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (!p_gen6->waitLightAndAlarm(TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + m_trunk_tag_rem_wait_time_s + TIME_DELAY::ALARM_EN_ERROR_TIME_S))
        {
            printf("PASS Шаг 3. Тревога не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 3. Тревога включилась\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после открытия багажника (брелок появляется)
void AutoTestsModesP2::C4828423_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка авторизации после открытия багажника в охране*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckTrunk(OPEN, PIN))
        {
            printf("PASS Шаг 2. Багажник открыт\n");
        }
        else
        {
            printf("FAIL Шаг 2. Багажник не открыт\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить брелок
    */
    /*!
        Брелок найден
        Через 15 сек после открытия багажника (Время поиска метки и брелока при открытом багажнике) тревога не включилась
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);

        if (!p_gen6->waitLightAndAlarm(TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + m_trunk_tag_rem_wait_time_s + TIME_DELAY::ALARM_EN_ERROR_TIME_S))
        {
            printf("PASS Шаг 3. Тревога не включилась\n");
        }
        else
        {
            printf("FAIL Шаг 3. Тревога включилась\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по метке после наступления тревоги (метка появляется)
void AutoTestsModesP2::C4828424_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4828410) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения тревоги после авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | вкл
        ||Авторизация владельца: Брелок                                         | выкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Переход из тревоги в охрану с открытым багажником
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_AUTH_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из тревоги в охрану с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 3. \"Охрана с открытым багажником\" не включена\n");
            is_fail = true;
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Авторизация по брелоку после наступления тревоги (брелок появляется)
void AutoTestsModesP2::C4828425_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4801979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения тревоги после авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | охрана
        ||Брелок:                                                               | откл
        ||Метка:                                                                | откл
        ||Багажник:                                                             | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                       | Batmobile
        ||Авторизация владельца: Метка                                          | выкл
        ||Авторизация владельца: Брелок                                         | вкл
        ||Slave при подключении к CAN                                           | вкл
        ||Аналоговый Slave                                                      | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока   | выкл
        ||Время поиска метки и брелока при открытом багажнике                   | 15 сек
        ||Ожидание авторизации, шаг 1                                           | 15 сек
        ||Ожидание авторизации, шаг 2                                           | 0 сек
        ||Ожидание авторизации, шаг 3                                           | 0 сек
    */
    if (!setSecureOnAndTagVccAndRemoteVcc(OFF))
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Отправить команду "отпереть багажник" через CAN (Batmobile)
    */
    /*!
        Охрана с открытым багажником включена
    */
    if (!is_fail)
    {
        p_gen6->unlockTrunk(CAN_USE);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 1. Охрана с открытым багажником включена\n");
        }
        else
        {
            printf("FAIL Шаг 1. Охрана с открытым багажником не включена\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки и брелока при открытом багажнике) включилась тревога
    */
    if (!is_fail)
    {
        if (!openTrunkAndCheckAlarm(ALERT_ON))
        {
            printf("FAIL Шаг 2\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить брелок
    */
    /*!
        Брелок найден
        Переход из тревоги в охрану с открытым багажником
    */
    if (!is_fail)
    {
        p_gen6->setLcdKeyringVcc(ON);

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM_TRUNK,
                                   ON,
                                   TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_AUTH_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 3. Переход из тревоги в охрану с открытым багажником\n");
        }
        else
        {
            printf("FAIL Шаг 3. \"Охрана с открытым багажником\" не включена\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Сброс питания ЦБ и R6
void AutoTestsModesP2::C4869745_TestCase()
{
    const float r6_siren_wait_time_s =   TIME_DELAY::R6_INIT_WAIT_TIME_S        // Время ожидания сирены R6
                                       + TIME_DELAY::R6_CONN_WAIT_TIME_S
                                       + TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка корректной работы сирены после потери и восстановления питания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | охрана
        ||R6:                                                   | включен
        ||R6:                                                   | зарегистрирован
        ||Питание ЦБ:                                           | подключено (12В)
        ||Настройки:
        ||Управление выходом на сирену подкапотного блока R6:   | Сирена
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отключить питание ЦБ и R6
    */
    /*!
        ЦБ и R6 отключены
    */
    p_gen6->off();
    p_gen6->resetR6Vcc();
    p_gen6->wait_s(TIME_DELAY::DEVICE_VCC_RESET_WAIT_TIME_S);

    /*!
        Шаг 2. Включить питание ЦБ и R6
    */
    /*!
        ЦБ и R6 включены
        На ЦБ включена тревога
        Включена сирена ЦБ
        Включена сирена R6
    */
    p_gen6->on();
    p_gen6->setR6Vcc();

    if (p_gen6->waitSiren(TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S, p_gen6->getPolarity(ID_OUT_SIREN)))
    {
        printf("PASS Шаг 2. Включена сирена ЦБ\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не включена сирена ЦБ\n");
        return;
    }

    if (p_gen6->waitR6SirenPotential(R6_SIREN_ACTIVE, r6_siren_wait_time_s))
    {
        printf("PASS Шаг 2. Включена сирена R6\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не включена сирена R6\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
    }
}

// Сброс питания ЦБ
void AutoTestsModesP2::C4869746_TestCase()
{
    const float r6_siren_wait_time_s =   TIME_DELAY::R6_INIT_WAIT_TIME_S        // Время ожидания сирены R6
                                       + TIME_DELAY::R6_CONN_WAIT_TIME_S
                                       + TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка корректной работы сирены после потери и восстановления питания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | охрана
        ||R6:                                                   | включен
        ||R6:                                                   | зарегистрирован
        ||Питание ЦБ:                                           | подключено (12В)
        ||Питание R6:                                           | подключено (12В)
        ||Настройки:                                         
        ||Управление выходом на сирену подкапотного блока R6:   | Сирена
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отключить питание ЦБ
    */
    /*!
        ЦБ отключен
    */
    p_gen6->off();
    p_gen6->wait_s(TIME_DELAY::DEVICE_VCC_RESET_WAIT_TIME_S);

    /*!
        Шаг 2. Включить питание ЦБ
    */
    /*!
        ЦБ включен
        На ЦБ включена тревога
        Включена сирена ЦБ
        Включена сирена R6
    */
    p_gen6->on();

    if (p_gen6->waitSiren(TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S, p_gen6->getPolarity(ID_OUT_SIREN)))
    {
        printf("PASS Шаг 2. Включена сирена ЦБ\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не включена сирена ЦБ\n");
        return;
    }

    if (p_gen6->waitR6SirenPotential(R6_SIREN_ACTIVE, r6_siren_wait_time_s))
    {
        printf("PASS Шаг 2. Включена сирена R6\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не включена сирена R6\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
    }
}

// Сброс питания R6
void AutoTestsModesP2::C4869747_TestCase()
{
    const float r6_siren_wait_time_s =   TIME_DELAY::R6_INIT_WAIT_TIME_S        // Время ожидания сирены R6
                                       + TIME_DELAY::R6_CONN_WAIT_TIME_S
                                       + TIME_DELAY::MAX_R6_SIGNAL_WAIT_TIME_S;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799851) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка корректной работы сирены после потери и восстановления питания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | охрана
        ||R6:                                                   | включен
        ||R6:                                                   | зарегистрирован
        ||Питание ЦБ:                                           | подключено (12В)
        ||Питание R6:                                           | подключено (12В)
        ||Настройки:
        ||Управление выходом на сирену подкапотного блока R6:   | Сирена
    */
    if (!setR6VccAndSecureAndIgnOff(SECURE_CMD_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отключить питание R6
    */
    /*!
        R6 отключен
    */
    p_gen6->resetR6Vcc();
    p_gen6->wait_s(TIME_DELAY::MAX_R6_CONNECTION_LOST_WAIT_TIME_S);

    /*!
        Шаг 2. Вызвать тревогу ЦБ (включить зажигание)
    */
    /*!
        На ЦБ включена тревога
        Включена сирена ЦБ
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }

    if (p_gen6->waitSiren(TIME_DELAY::DEVICE_VCC_INIT_WAIT_TIME_S, p_gen6->getPolarity(ID_OUT_SIREN)))
    {
        printf("PASS Шаг 2. Включена сирена ЦБ\n");
    }
    else
    {
        printf("FAIL Шаг 2. Не включена сирена ЦБ\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_GUARD_STATE,
                                SLP_STATUSES_SIZES::DIAG_DATA_GUARD_STATE_SIZE,
                                DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога не включена\n");
        return;
    }

    /*!
        Шаг 3. Включить питание R6
    */
    /*!
        R6 включен
        R6 установил связь с ЦБ
        Включена сирена R6
    */
    p_gen6->setR6Vcc();

    if (p_gen6->waitR6SirenPotential(R6_SIREN_ACTIVE, r6_siren_wait_time_s))
    {
        printf("PASS Шаг 3. Включена сирена R6\n");
    }
    else
    {
        printf("FAIL Шаг 3. Не включена сирена R6\n");
    }
}

// Запирание ЦЗ
void AutoTestsModesP2::C4886622_TestCase()
{
    if (settings_check(p_c9501311) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запирания ЦЗ в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:        | сервисный режим
        ||Зоны охраны:         | не нарушены
        ||Настройки:
        ||Настроен выход:      | ЦЗ открыть
        ||Настроен выход:      | ЦЗ закрыть
    */
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
    }
    else
    {
        p_gen6->setServiceModeTag(ON);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    /*!
        Шаг 1. Включить охрану (нажать кнопку 1 брелока)
    */
    /*!
        ЦБ остался в сервисном режиме
        На выход "ЦЗ закрыть" подан импульс (произошло запирание ЦЗ)
    */
    p_gen6->setPolarity(ID_OUT_LOCK_A);
    p_gen6->setSecureNoDelay(ON, KEYRING);

    if (p_gen6->checkPulseWidth(ID_OUT_LOCK_A,
                                TIME_DELAY::STD_ALT_LOCK_PULSE_TIME_S,
                                TIME_DELAY::MAX_WAITING_LOCK_A_PULSE_S))
    {
        printf("PASS Шаг 1. Произошло запирание ЦЗ\n");
    }
    else
    {
        printf("FAIL Шаг 1. Запирание ЦЗ не произошло (сигнал не получен или длительность несоответствует ожидаемой)\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. ЦБ остался в сервисном режиме\n");
    }
    else
    {
        printf("PASS Шаг 1. ЦБ не остался в сервисном режиме (сервисный режим выключился)\n");
    }
}

// Отпирание ЦЗ
void AutoTestsModesP2::C4886623_TestCase()
{
    if (settings_check(p_c9501311) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отпирания ЦЗ в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:        | сервисный режим
        ||Зоны охраны:         | не нарушены
        ||Настройки:
        ||Настроен выход:      | ЦЗ открыть
        ||Настроен выход:      | ЦЗ закрыть
    */
    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setServiceModeKeyring();
    }
    else
    {
        p_gen6->setServiceModeTag(ON);
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    /*!
        Шаг 1. Отлючить охрану (нажать кнопку 2 брелока)
    */
    /*!
        ЦБ остался в сервисном режиме
        На выход "ЦЗ открыть" подан импульс (произошло отпирание ЦЗ)
    */
    p_gen6->setPolarity(ID_OUT_LOCK_B);
    p_gen6->setSecureNoDelay(OFF, KEYRING);

    // Если нет брелка, но есть метка
    // То первое ее нажатие было "постановка", для "снятия" нужно нажать кнопку еще раз
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        wait(TIME_DELAY::MAX_WIRE_EN_DELAY_S);
        p_gen6->setSecureNoDelay(OFF, TAG);
    }

    if (p_gen6->checkPulseWidth(ID_OUT_LOCK_B,
                                TIME_DELAY::STD_ALT_LOCK_PULSE_TIME_S,
                                TIME_DELAY::MAX_WAITING_LOCK_A_PULSE_S))
    {
        printf("PASS Шаг 1. Произошло отпирание ЦЗ\n");
    }
    else
    {
        printf("FAIL Шаг 1. Отпирание ЦЗ не произошло (сигнал не получен или длительность несоответствует ожидаемой)\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. ЦБ остался в сервисном режиме\n");
    }
    else
    {
        printf("PASS Шаг 1. ЦБ не остался в сервисном режиме (сервисный режим выключился)\n");
    }
}

// 1 Потеря метки не приводит к включению ЗП
void AutoTestsModesP2::C4930044_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что ЗП не включается при потере метки с включенным зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Отключить метку
    */
    /*!
        Метка потеряна
        Через 1 мин (время до активации запрета поездки после выключения зажигания) запрет поездки не включился
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TimeoutCalculator::calcTimeWithError(m_immo_on_after_ign_off_delay_s) + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
        {
            printf("PASS Шаг 1. Запрет поездки не включился\n");
        }
        else
        {
            printf("FAIL Шаг 1. Запрет поездки включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 2 Включение зажигания с меткой до включения ЗП
void AutoTestsModesP2::C4930045_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что ЗП не включается после выключения зажигания, если потом его включить*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Через 1 мин (время до активации запрета поездки после выключения зажигания) после выключения зажигания запрет поездки не включился
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 2. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не включено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TimeoutCalculator::calcTimeWithError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 2. Запрет поездки не включился\n");
        }
        else
        {
            printf("FAIL Шаг 2. Запрет поездки включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 3 Включение ЗП с меткой после выключения зажигания
void AutoTestsModesP2::C4930046_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка таймера ЗП после выключения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Через 1 мин (время до активации запрета поездки после выключения зажигания) включился запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   m_immo_on_after_ign_off_delay_s,
                                   TimeoutCalculator::calcToutError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 1. Запрет поездки включился\n");
        }
        else
        {
            printf("FAIL Шаг 1. Запрет поездки не включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 4 Потеря метки до включения ЗП
void AutoTestsModesP2::C4930047_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что метка не влияет на ЗП после выключения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 2. Отключить метку
    */
    /*!
        Метка потеряна
        Через 1 мин (время до активации запрета поездки после выключения зажигания) после выключения зажигания включился запрет поездки
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   m_immo_on_after_ign_off_delay_s,
                                   TimeoutCalculator::calcToutError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 2. Запрет поездки включился\n");
        }
        else
        {
            printf("FAIL Шаг 2. Запрет поездки не включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 5 Включение зажигания без метки до включения ЗП
void AutoTestsModesP2::C4930048_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что ЗП не включается после выключения зажигания, если потом его включить*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Отключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 2. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
        Через 1 мин (время до активации запрета поездки после выключения зажигания) после выключения зажигания запрет поездки не включился
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(ON, PIN))
        {
            printf("PASS Шаг 3. Зажигание включено\n");
        }
        else
        {
            printf("FAIL Шаг 3. Зажигание не включено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                    ON,
                                    TimeoutCalculator::calcTimeWithError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 3. Запрет поездки не включился\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 6 Включение ЗП без метки после выключения зажигания
void AutoTestsModesP2::C4930049_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка таймера ЗП после выключения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Отключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Через 1 мин (время до активации запрета поездки после выключения зажигания) включился запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 2. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   m_immo_on_after_ign_off_delay_s,
                                   TimeoutCalculator::calcToutError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 2. Запрет поездки включился\n");
        }
        else
        {
            printf("FAIL Шаг 2. Запрет поездки не включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// 7 Метка найдена до включения ЗП
void AutoTestsModesP2::C4930050_TestCase()
{
    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930044) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что метка не влияет на ЗП после выключения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 1 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Отключить метку
    */
    /*!
        Метка потеряна
    */
    if (!is_fail)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 2. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 2. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка найдена
        Через 1 мин (время до активации запрета поездки после выключения зажигания) после выключения зажигания включился запрет поездки
    */
    if (!is_fail)
    {
        p_gen6->setTagVcc();

        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   m_immo_on_after_ign_off_delay_s,
                                   TimeoutCalculator::calcToutError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 3. Запрет поездки включился\n");
        }
        else
        {
            printf("FAIL Шаг 3. Запрет поездки не включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Макс. время до активации ЗП
void AutoTestsModesP2::C4930051_TestCase()
{
    // Кейс гоняется 1 час. Перемещен в таблицу исключенных

    bool is_fail = false;


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c4930051) == 0)
    {
        return;
    }

    if (m_immo_on_after_ign_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время до активации запрета поездки после выключения зажигания\" не задана\n");
        is_fail = true;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка макс. таймера ЗП после выключения зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | снято
        ||Зажигание:                                                          | включено
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Снятие запрета поездки:                                             | Метка
        ||Условие активации запрета поездки:                                  | При каждом выключении зажигания
        ||Время до активации запрета поездки после выключения зажигания:      | 60 мин
    */
    if (!is_fail)
    {
        if (!setDisarmAndSetRemoteAndTagAndIgn())
        {
            printf("FAIL Начальные условия\n");
            is_fail = true;
        }
    }

    /*!
        Шаг 1. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Через 60 мин (время до активации запрета поездки после выключения зажигания) включился запрет поездки
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckIgn(OFF, PIN))
        {
            printf("PASS Шаг 1. Зажигание отключено\n");
        }
        else
        {
            printf("FAIL Шаг 1. Зажигание не отключено\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_IMMO,
                                   ON,
                                   m_immo_on_after_ign_off_delay_s,
                                   TimeoutCalculator::calcToutError(m_immo_on_after_ign_off_delay_s)))
        {
            printf("PASS Шаг 1. Запрет поездки включился\n");
        }
        else
        {
            printf("FAIL Шаг 1. Запрет поездки не включился\n");
        }
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Звуковые извещатели отсутствуют
void AutoTestsModesP2::C9257883_TestCase()
{
    bool  is_fail = false;
    float auth_step_one_err_time_s;            // Погрешность шага 1 ожидания авторизации


    if (p_gen6->getDeviceName() == GEN6_X96V2) // На X96v2 есть внутренний звукоизвещатель
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9257883) == 0)
    {
        return;
    }

    if (   m_auth_step_one_vld_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_auth_step_three_time_s   == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки алгоритма \"Ожидания авторизации\" заданы\n");
        return;
    }

    auth_step_one_err_time_s = TimeoutCalculator::calcToutError(m_auth_step_one_vld_time_s);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей при их отсутствии*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 15 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | отсутствует
        ||Внешний звуковой извещатель:                                        | отсутствует
        ||Не Настроен выход:                                                  | внешний звуковой извещатель (отключен)
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */
    if (!setSecureAndRemoteAndResetTagAndIgn())
    {
        printf("FAIL Начальные условия\n");
        is_fail = true;
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */
    if (!is_fail)
    {
        if (p_gen6->setAndCheckSecure(OFF,
                                      KEYRING,
                                      DIAG_GUARD_STATE_WAITING_AUTH))
        {
            printf("PASS Шаг 1. Переход из снято в ожидание авторизации\n");
        }
        else
        {
            printf("FAIL Шаг 1. Переход из снято в ожидание авторизации не произошел\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        p_gen6->wait_s(TIME_DELAY::REMOTE_ACT_DELAY_S); // Пропустить сигналы сирены/света при постановке
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Через 15 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    if (!is_fail)
    {
        p_gen6->setDoor(ON,
                        PIN,
                        TIME_DELAY::NULL_DELAY_S);

        if (!p_gen6->waitLightAndAlarm(m_auth_step_one_vld_time_s - auth_step_one_err_time_s))
        {
            printf("PASS Шаг 2. Сирена и световые сигналы не включилась раньше времени\n");
        }
        else
        {
            printf("FAIL Шаг 2. Сирена и световые сигналы включилась раньше времени\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitLightAndAlarm(auth_step_one_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S))
        {
            printf("PASS Шаг 2. Сирена и световые сигналы включены\n");
        }
        else
        {
            printf("FAIL Шаг 2. Сирена и световые сигналы не включены\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    m_auth_step_three_time_s - TimeoutCalculator::calcToutError(m_auth_step_three_time_s)))
        {
            printf("PASS Шаг 2. Тревога не включилась раньше времени\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога включилась раньше времени\n");
            is_fail = true;
        }
    }

    if (!is_fail)
    {
        if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                   ON,
                                   TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("PASS Шаг 2. Тревога включена\n");
        }
        else
        {
            printf("FAIL Шаг 2. Тревога не включилась\n");
        }
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Есть внутренний звуковой извещатель
void AutoTestsModesP2::C9257884_TestCase()
{
    // Не поддается автоматизации: внутренний звуковой извещатель не проверяется (не подключен)

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей (внутреннего)*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 15 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | отсутствует
        ||Не Настроен выход:                                                  | внешний звуковой извещатель (отключен)
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Внутренний звуковой извещатель начинает издавать трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 15 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические сигналы и включились периодические сигналы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические сигналы звукоизвещателя и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
}

// Есть внешний звуковой извещатель
void AutoTestsModesP2::C9257885_TestCase()
{
    if (settings_check(p_c9257885) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей (внешнего)*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 15 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | отсутствует
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 15 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические импульсы и включились периодические импульсы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические импульсы звукоизвещателя и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    if (!setAndCheckAuthWithBuzzer())
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Есть внутренний и внешний звуковые извещатели
void AutoTestsModesP2::C9257886_TestCase()
{
    // Не поддается автоматизации: внутренний звуковой извещатель не проверяется (не подключен)
    // Можно проверять только внешний звуковой извещатель, но такой кейс уже есть

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей (внешнего и внутреннего)*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 15 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Внутренний звуковой извещатель начинает издавать трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 15 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические импульсы и сигналы внешнего и внутреннего звуковых извещателей и включились периодические импульсы и сигналы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические импульсы и сигналы звукоизвещателей и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
}

// Мин. время ожидания авторизации
void AutoTestsModesP2::C9257887_TestCase()
{
    if (settings_check(p_c9257887) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей при минимальном настроенном времени*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 1 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" поданы трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс)
        Внутренний звуковой извещатель издает трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс)
        Через 1 сек после открытия двери (Ожидание авторизации, шаг 1: время ввода кода авторизации) включились периодические импульсы и сигналы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические импульсы и сигналы звукоизвещателей и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    if (!setAndCheckAuthWithBuzzer())
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Макс. время ожидания авторизации
void AutoTestsModesP2::C9257888_TestCase()
{
    if (settings_check(p_c9257888) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей при максимальном настроенном времени*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | отключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | отключена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 60 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 0 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 0 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Внутренний звуковой извещатель начинает издавать трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 60 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические импульсы и сигналы внешнего и внутреннего звуковых извещателей и включилась тревога
    */
    if (!setAndCheckAuthWithBuzzer())
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Время поиска метки больше времени ввода кода
void AutoTestsModesP2::C9257889_TestCase()
{
    if (settings_check(p_c9257889) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей при различно настроенном времени авторизации шагов 1*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | включена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 60 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 1 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Внутренний звуковой извещатель начинает издавать трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 60 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические импульсы и сигналы внешнего и внутреннего звуковых извещателей и включились периодические импульсы и сигналы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические импульсы и сигналы звукоизвещателей и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    if (!setAndCheckAuthWithBuzzer())
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Время поиска метки меньше времени ввода кода
void AutoTestsModesP2::C9257890_TestCase()
{
    if (settings_check(p_c9257888) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка работы звуковых извещателей при различно настроенном времени авторизации шагов 1*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | охрана
        ||Зажигание:                                                          | выключено
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Настройки:
        ||Авторизация владельца: Штатные кнопки автомобиля:                   | включена
        ||Авторизация владельца: Метка:                                       | включена
        ||Авторизация владельца: Брелок:                                      | отключена
        ||Ожидание авторизации, шаг 1: время поиска метки:                    | 15 сек
        ||Ожидание авторизации, шаг 1: время ввода кода авторизации:          | 60 сек
        ||Ожидание авторизации, шаг 2: предупреждение звуковым извещателем:   | 5 сек
        ||Ожидание авторизации, шаг 3: предупреждение сиреной:                | 5 сек
        ||Код штатных кнопок автомобиля:                                      | прописан
        ||CAN-автомобиль:                                                     | Batmobile
        ||Внутренний звуковой извещатель:                                     | есть
        ||Внешний звуковой извещатель:                                        | есть
        ||Настроен выход:                                                     | внешний звуковой извещатель
        ||Требовать авторизацию при снятии с охраны:                          | брелоком
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из снято в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        На выход "внешний звуковой извещатель" подаются трехкратные периодические импульсы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Внутренний звуковой извещатель начинает издавать трехкратные периодические сигналы (3 импульса по 100 мс с промежутком 100 мс с промежутком до следующих 3 импульсов 3600 мс)
        Через 60 сек (Ожидание авторизации, шаг 1: время ввода кода авторизации) выключились трехкратные периодические импульсы и сигналы внешнего и внутреннего звуковых извещателей и включились периодические импульсы и сигналы (100 мс импульс и 1000 мс пауза)
        Через 5 сек (Ожидание авторизации, шаг 2: предупреждение звуковым извещателем) выключились периодические импульсы и сигналы звукоизвещателей и включились предупреждения сиреной и световыми сигналами
        Через 5 сек (Ожидание авторизации, шаг 3: предупреждение сиреной) включилась тревога
    */
    if (!setAndCheckAuthWithBuzzer())
    {
        printf("FAIL Шаг 1-2\n");
    }

    p_gen6->resetAuthAndImmo();

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL Сброс настроек не выполнен\n");
    }
}

// Появление метки без брелока
void AutoTestsModesP2::C9377438_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c9377438)
        ||  settings_check(p_c9377438) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что АО не отключется при появлении метки, если брелок отсутствует*
        ||Состояние стенда:
        ||Автомобиль в:                                          | снято
        ||Зажигание:                                             | включено
        ||Метка:                                                 | включена
        ||Брелок:                                                | включен
        ||Дверь:                                                 | закрыта
        ||Настройки:
        ||Антиограбление при пропадении метки:                   | включено
        ||Антиограбление при пропадении брелока:                 | включено
        ||АО, шаг 1: время до начала поиска метки или брелока:   | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:             | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:        | 5 сек
        ||АО, шаг 4: предупреждение сиреной:                     | 5 сек
        ||Датчик движения:                                       | включен (30)
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 5 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 5 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Выключить брелок
    */
    /*!
        Брелок потерян
    */
    p_gen6->setLcdKeyringVcc(OFF);
    p_gen6->wait_s(TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S);

    /*!
        Шаг 6. Включить метку
    */
    /*!
        Метка найдена
        Антиограбление по потере метки/брелока активно (не отключилось)
    */
    p_gen6->setTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                ON,
                                TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 6. Антиограбление по потере метки/брелока активно (не отключилось)\n");
    }
    else
    {
        printf("FAIL Шаг 6. Антиограбление по потере метки/брелока отключилось\n");
        return;
    }

    /*!
        Шаг 7. Включить брелок
    */
    /*!
        Брелок найден
        Переход из АО в снято
    */
    p_gen6->setLcdKeyringVcc(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 7. Переход из АО в снято\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход из АО в снято не произошел\n");
    }
}

// Появление метки с брелоком
void AutoTestsModesP2::C9377439_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c9377438)
        ||  settings_check(p_c9377438) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что АО отключется при появлении метки, если брелок включен*
        ||Состояние стенда:
        ||Автомобиль в:                                          | снято
        ||Зажигание:                                             | включено
        ||Метка:                                                 | включена
        ||Брелок:                                                | включен
        ||Дверь:                                                 | закрыта
        ||Настройки:
        ||Антиограбление при пропадении метки:                   | включено
        ||Антиограбление при пропадении брелока:                 | включено
        ||АО, шаг 1: время до начала поиска метки или брелока:   | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:             | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:        | 5 сек
        ||АО, шаг 4: предупреждение сиреной:                     | 5 сек
        ||Датчик движения:                                       | включен (30)
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!setDisarmAndDoorAndIgn(TAG_OFF, REMOTE_ON))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 5 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 5 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Включить метку
    */
    /*!
        Метка найдена
        Переход из АО в снято
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 5. Переход из АО в снято\n");
    }
    else
    {
        printf("FAIL Шаг 5. Переход из АО в снято не произошел\n");
    }
}

// Появление брелока без метки
void AutoTestsModesP2::C9377440_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c9377438)
        ||  settings_check(p_c9377438) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что АО не отключется при появлении брелока, если метка отсутствует*
        ||Состояние стенда:
        ||Автомобиль в:                                          | снято
        ||Зажигание:                                             | включено
        ||Метка:                                                 | включена
        ||Брелок:                                                | включен
        ||Дверь:                                                 | закрыта
        ||Настройки:
        ||Антиограбление при пропадении метки:                   | включено
        ||Антиограбление при пропадении брелока:                 | включено
        ||АО, шаг 1: время до начала поиска метки или брелока:   | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:             | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:        | 5 сек
        ||АО, шаг 4: предупреждение сиреной:                     | 5 сек
        ||Датчик движения:                                       | включен (30)
    */

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 5 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 5 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Выключить метку
    */
    /*!
        Метка потеряна
    */
    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 6. Включить брелок
    */
    /*!
        Брелок найден
        Антиограбление по потере метки/брелока активно (не отключилось)
    */
    p_gen6->setLcdKeyringVcc(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                                ON,
                                TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 6. Антиограбление по потере метки/брелока активно (не отключилось)\n");
    }
    else
    {
        printf("FAIL Шаг 6. Антиограбление по потере метки/брелока отключилось\n");
        return;
    }

    /*!
        Шаг 7. Включить метку
    */
    /*!
        Метка найдена
        Переход из АО в снято
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 7. Переход из АО в снято\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход из АО в снято не произошел\n");
    }
}

// Появление брелока с меткой
void AutoTestsModesP2::C9377441_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c9377438)
        ||  settings_check(p_c9377438) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что АО отключется при появлении брелока, если метка включена*
        ||Состояние стенда:
        ||Автомобиль в:                                          | снято
        ||Зажигание:                                             | включено
        ||Метка:                                                 | включена
        ||Брелок:                                                | включен
        ||Дверь:                                                 | закрыта
        ||Настройки:
        ||Антиограбление при пропадении метки:                   | включено
        ||Антиограбление при пропадении брелока:                 | включено
        ||АО, шаг 1: время до начала поиска метки или брелока:   | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:             | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:        | 5 сек
        ||АО, шаг 4: предупреждение сиреной:                     | 5 сек
        ||Датчик движения:                                       | включен (30)
    */

    /*!
        Шаг 1. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (!setDisarmAndDoorAndIgn(TAG_ON, REMOTE_OFF))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 5 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 5 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
    if (!setAhjTestsStepThree(NO_CHECK_BLOCK, CHECK_ALARM))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Включить брелок
    */
    /*!
        Брелок найден
        Переход из АО в снято
    */
    p_gen6->setLcdKeyringVcc(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 5. Переход из АО в снято\n");
    }
    else
    {
        printf("FAIL Шаг 5. Переход из АО в снято не произошел\n");
    }
}

// 1. Тревога не по ДД
void AutoTestsModesP2::C9491969_TestCase()
{
    if (settings_check(p_c9491969) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается, если тревога наступила не по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 2
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (открыть дверь)
    */
    /*!
        Включена тревога
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_DOOR, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// 2. Сработал ДД в тревоге с превышенной скоростью
void AutoTestsModesP2::C9491970_TestCase()
{
    if (settings_check(p_c9491969) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается, если превышена допустимая скорость*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 60
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 2
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(60, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 3. Сработал ДД в тревоге с допустимой скоростью
void AutoTestsModesP2::C9491971_TestCase()
{
    if (settings_check(p_c9491969) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 2
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 2 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. ("длительность блокировки") отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 4. Скорость снизилась после тревоги по ДД
void AutoTestsModesP2::C9491972_TestCase()
{
    if (settings_check(p_c9491969) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается по ДД только после снижения скорости до допустимой*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 60
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 2
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(60, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Понизить скорость до 0
    */
    /*!
        Скорость снижена
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    p_gen6->setSpeed(0);

    if (!setZoneAndCheckBlockTime(ZONE_NONE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 2 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. ("длительность блокировки") отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 4\n");
    }
}

// 5. Скорость снизилась после тревоги не по ДД
void AutoTestsModesP2::C9491973_TestCase()
{
    if (settings_check(p_c9491969) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается только по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 60
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 2
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(60, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Понизить скорость до 0
    */
    /*!
        Скорость снижена
        В течение 10 сек. ("задержка блокировки"+"длительность блокировки"+ запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    p_gen6->setSpeed(0);

    if (!setZoneAndCheckBlockTime(ZONE_NONE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 6. Перезапуск блокировки по ДД
void AutoTestsModesP2::C9491974_TestCase()
{
    if (settings_check(p_c9491974) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не перезапускается во время своего действия*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 10
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
    */

    /*!
        Шаг 2. Через 5 сек вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 10 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAlertAndZoneAndCheckBlock(ZONE_SENSOR_MOVE))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// 7. Перезапуск блокировки не по ДД
void AutoTestsModesP2::C9491975_TestCase()
{
    if (settings_check(p_c9491974) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не перезапускается во время своего действия*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 10
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
    */

    /*!
        Шаг 2. Через 5 сек открыть дверь
    */
    /*!
        Дверь открыта
        Через 10 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAlertAndZoneAndCheckBlock(ZONE_DOOR))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// 8. Блокировка истекла в тревоге
void AutoTestsModesP2::C9491976_TestCase()
{
    Timer alert_timer; // Таймер, включается в момент включения тревоги


    if (settings_check(p_c9491974) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка длительности блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 10
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 10 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
        Через 30 сек. (внутренний таймаут) тревога отключена
    */
    alert_timer.start();

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               OFF,
                               TIME_DELAY::ALARM_DIS_TIME_S - alert_timer.read(),
                               TIME_DELAY::ALARM_DIS_ERROR_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога отключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не отключена\n");
    }
}

// 9. Блокировка истекла в охране
void AutoTestsModesP2::C9491977_TestCase()
{
    Timer block_timer; // Таймер, включается в момент включения блокировки


    if (settings_check(p_c9491977) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка длительности блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 50
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 30 сек. (внутренний таймаут) тревога отключена
        Через 50 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    p_gen6->setMoveSensor();
    
    if (p_gen6->waitBlock(m_eng_block_local0_delay_s, TimeoutCalculator::calcToutError(m_eng_block_local0_delay_s)))
    {
        printf("PASS Шаг 1. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не включена\n");
        return;
    }

    block_timer.start();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               OFF,
                               TIME_DELAY::ALARM_DIS_TIME_S - block_timer.read(),
                               TIME_DELAY::ALARM_DIS_ERROR_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога отключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не отключена\n");
        return;
    }

    if (p_gen6->waitBlock(m_eng_block_local0_block_s - block_timer.read(),
                          TimeoutCalculator::calcToutError(m_eng_block_local0_block_s),
                          OFF))
    {
        printf("PASS Шаг 1. Блокировка отключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не отключена\n");
    }
}

// Блокировка с отключенным ДД
void AutoTestsModesP2::C9491978_TestCase()
{
    // Тест не автоматизирован, т.к. будет дублировать существующие кейсы
    // Из-за того, что ДД уже выключен на автостенде, а включается по SLP

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается с отключенным ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | отключен (0)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 10
        ||Настроен выход:                                        | блокировка двигателя
    */

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 10 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
}

// Блокировка с максимальным временем
void AutoTestsModesP2::C9491979_TestCase()
{
    if (settings_check(p_c9491979) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка максимального времени блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 60
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 60 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE,
                                  BLOCK_ON,
                                  NO_CHECK_ALARM)) // Не проверять тревогу после блокировки, т.к. к тому моменту она возможно будет выключена
    {
        printf("FAIL Шаг 1\n");
    }
}

// Блокировка с минимальным временем
void AutoTestsModesP2::C9491980_TestCase()
{
    if (settings_check(p_c9491980) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка минимального времени блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 3
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 1
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 3 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 1 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Блокировка с максимальной задержкой
void AutoTestsModesP2::C9491981_TestCase()
{
    if (settings_check(p_c9491981) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка максимального времени задержки блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 60
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 60 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE,
                                  BLOCK_ON,
                                  NO_CHECK_ALARM)) // Не проверять тревогу после блокировки, т.к. к тому моменту она возможно будет выключена))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Блокировка с минимальной задержкой
void AutoTestsModesP2::C9491982_TestCase()
{
    if (settings_check(p_c9491982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка минимального времени задержки блокировки по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 0
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 0
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// 10. Тревога по ДД с превышенной скоростью
void AutoTestsModesP2::C9501309_TestCase()
{
    if (settings_check(p_c9501309) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается, если превышена допустимая скорость*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 60
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 10
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 5
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(60, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Через 5 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        В течение 20 сек. ("задержка блокировки"+"длительность блокировки"+запас) блокировка не включилась и на выход блокировки потенциал не подавался
    */
    p_gen6->wait_s(TIME_DELAY::ALARM_ACT_DELAY_S);

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 11. Тревога по ДД с допустимой скоростью
void AutoTestsModesP2::C9501310_TestCase()
{
    if (settings_check(p_c9501310) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается, если допустимая скорость не превышена*
        ||Состояние стенда:
        ||Автомобиль в:                                          | охрана
        ||Зажигание:                                             | выключено
        ||Дверь:                                                 | закрыта
        ||Скорость:                                              | 20
        ||Блокировка:                                            | отключена
        ||Выход блокировки:                                      | отключен
        ||Настройки:
        ||Датчик движения:                                       | включен (30)
        ||Выбран CAN-автомобиль:                                 | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):            | включен
        ||Скорость, ниже которой разрешена блокировка двигателя: | 30
        ||Тип блокировки двигателя:                              | НЗ
        ||Задержка блокировки:                                   | 10
        ||Блокировать при срабатывании датчика движения:         | да
        ||Длительность блокировки:                               | 6
        ||Настроен выход:                                        | блокировка двигателя
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(20, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Через 5 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 10 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    p_gen6->wait_s(TIME_DELAY::ALARM_ACT_DELAY_S);

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Блокировка с нажатой педалью с разрешением на блокировку без педали
void AutoTestsModesP2::C9501311_TestCase()
{
    if (settings_check(p_c9501311) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что педаль тормоза не влияет на блокировку*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | выключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | нажата
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 10
        ||Блокировать при срабатывании датчика движения:                             | да
        ||Длительность блокировки:                                                   | 6
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 10 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Блокировка с не нажатой педалью с разрешением на блокировку без педали
void AutoTestsModesP2::C9501312_TestCase()
{
    if (settings_check(p_c9501311) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что педаль тормоза не влияет на блокировку*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | выключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 10
        ||Блокировать при срабатывании датчика движения:                             | да
        ||Длительность блокировки:                                                   | 6
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(0, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (вызвать срабатывание ДД)
    */
    /*!
        Сработал ДД
        Включена тревога
        Через 10 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Блокировка с нажатой педалью с запретом на блокировку без педали
void AutoTestsModesP2::C9501313_TestCase()
{
    if (settings_check(p_c9501313) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что педаль тормоза не влияет на блокировку*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | выключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | нажата
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 10
        ||Блокировать при срабатывании датчика движения:                             | да
        ||Длительность блокировки:                                                   | 6
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галки есть)
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(20, BRAKE_PEDAL_ON))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Через 5 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 10 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    p_gen6->wait_s(TIME_DELAY::ALARM_ACT_DELAY_S);

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Блокировка с не нажатой педалью с запретом на блокировку без педали
void AutoTestsModesP2::C9501314_TestCase()
{
    if (settings_check(p_c9501313) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что педаль тормоза не влияет на блокировку*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | выключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 10
        ||Блокировать при срабатывании датчика движения:                             | да
        ||Длительность блокировки:                                                   | 6
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галки есть)
    */
    if (!setSpeedAndBrakeAndArmZoneClosed(20, BRAKE_PEDAL_OFF))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать тревогу (включить зажигание)
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!setZoneAndCheckBlockTime(ZONE_IGN, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Через 5 сек. вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Через 10 сек. ("задержка блокировки") включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек. ("длительность блокировки") после включения блокировки отключилась блокировка (с выхода блокировки снят потенциал)
    */
    p_gen6->wait_s(TIME_DELAY::ALARM_ACT_DELAY_S);

    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 1. Включение АО без нажатой педали и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9501315_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 2. Включение АО с нажатой педалью и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9501316_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 3. Включение АО с нажатой педалью с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9501317_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 4. Повторное включение блокировки в АО без педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9501318_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза, даже если уже включалась во время этого АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Не позднее чем через 30 сек (внутренний таймаут продолжительности одного полуцикла тревоги) выключена тревога
        Блокировка отключена (с выхода блокировки снят потенциал)
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!resetBrakeAndRestartIgnAndCheckBlock(BLOCK_OFF))
    {
        printf("FAIL Шаг 6-8\n");
    }
}

// 5. Включение АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9501319_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 6. Включение АО без нажатой педали и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9501320_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501320)
        || settings_check(p_c9501320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 7. Включение АО с нажатой педалью и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9501321_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501320)
        || settings_check(p_c9501320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 8. Включение АО с нажатой педалью с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9501322_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501322)
        || settings_check(p_c9501322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 9. Повторное включение блокировки в АО без педали (нет данных о скорости)
void AutoTestsModesP2::C9501323_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501322)
        || settings_check(p_c9501322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза, даже если уже включалась во время этого АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Не позднее чем через 30 сек (внутренний таймаут продолжительности одного полуцикла тревоги) выключена тревога
        Блокировка отключена (с выхода блокировки снят потенциал)
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не включилась
    */
    if (!resetBrakeAndRestartIgnAndCheckBlock(BLOCK_OFF))
    {
        printf("FAIL Шаг 6-8\n");
    }
}

// 10. Включение АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9501324_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501322)
        || settings_check(p_c9501322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 11. Включение АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508181_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 12. Включение АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508182_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 13. Включение АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508183_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 14. Включение АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508184_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 15. Включение АО без нажатой педали и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9508185_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 9
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(9);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 16. Включение АО с нажатой педалью и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9508186_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 7
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(7);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 17. Включение АО с нажатой педалью с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9508187_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 3
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(3);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 18. Включение АО без нажатой педали с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9508188_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(0);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 19. 180 сек. АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508189_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 20. 180 сек. АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508190_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 21. 180 сек. АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508191_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 22. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9508192_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 23. 180 сек. АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9508193_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501322)
        || settings_check(p_c9501322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без нажатой педали тормоза через 180 сек после начала тревоги*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 24. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9508194_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали через 180 сек. после включения АО, если есть данные о скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 25. Нажатие педали в АО с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9518545_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается после нажатия педали в АО при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 26. Нажатие педали в АО с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9518546_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9501322)
        || settings_check(p_c9501322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается после нажатия педали в АО при отсутствии скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Включилась блокировка (на выход блокировки подан потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 27. Нажатие педали в АО с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9518547_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508187)
        || settings_check(p_c9508187) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(40);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setBrakeAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 28. Нажатие педали в АО без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9518548_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9508185)
        || settings_check(p_c9508185) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(40);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setBrakeAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 1. Включение АО без нажатой педали и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645327_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 2. Включение АО с нажатой педалью и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645328_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 3. Включение АО с нажатой педалью с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645329_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 4. Повторное включение блокировки в АО без педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645330_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без нажатой педали тормоза, если уже включалась во время этого АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!resetBrakeAndSetSensorAndCheckBlockOn())
    {
        printf("FAIL Шаг 6-7\n");
    }
}

// 5. Включение АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645331_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 6. Включение АО без нажатой педали и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645313_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645313)
        || settings_check(p_c9645313) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Через 180 сек. (внутренний таймаут) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_ON))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// 7. Включение АО с нажатой педалью и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645314_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645313)
        || settings_check(p_c9645313) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза по ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Через 180 сек. (внутренний таймаут) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_ON))
    {
        printf("FAIL Шаг 6-7\n");
    }
}

// 8. Включение АО с нажатой педалью с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645315_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645315)
        || settings_check(p_c9645315) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается по ДД c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 9. Повторное включение блокировки в АО без педали (нет данных о скорости)
void AutoTestsModesP2::C9645316_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645315)
        || settings_check(p_c9645315) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается по ДД без нажатой педали тормоза, если уже включалась во время этого АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
        return;
    }

    /*!
        Шаг 7. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 8. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!resetBrakeAndSetSensorAndCheckBlockOn())
    {
        printf("FAIL Шаг 7-8\n");
    }
}

// 10. Включение АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645317_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645315)
        || settings_check(p_c9645315) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается по ДД без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 11. Включение АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645334_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 12. Включение АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645335_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД  не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 13. Включение АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645336_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается по ДД с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 14. Включение АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645337_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 15. Включение АО без нажатой педали и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9645320_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 9
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(9);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 16. Включение АО с нажатой педалью и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9645321_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 7
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(7);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 17. Включение АО с нажатой педалью с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9645322_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 3
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(3);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 6\n");
    }
}

// 18. Включение АО без нажатой педали с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9645323_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(0);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setZoneAndCheckBlockTime(ZONE_SENSOR_MOVE, BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 19. 180 сек. АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645338_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// 20. 180 сек. АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645339_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 6-7\n");
    }
}

// 21. 180 сек. АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645340_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 6-7\n");
    }
}

// 22. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645341_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// 23. 180 сек. АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645318_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645315)
        || settings_check(p_c9645315) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается без нажатой педали тормоза через 180 сек после начала тревоги*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_ON))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// 24. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645332_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается без нажатой педали через 180 сек. после включения АО, если есть данные о скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Не ранее чем через 180 сек. (внутренний таймаут) после включения АО (окончание шага 4 АО) вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndCheckBlockTwice(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// 25. Нажатие педали в АО с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9645333_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается после нажатия педали в АО при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setSensorAndBrakeAndSensorAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5-7\n");
    }
}

// 26. Нажатие педали в АО с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9645319_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645315)
        || settings_check(p_c9645315) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД включается после нажатия педали в АО при отсутствии скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек. (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setSensorAndBrakeAndSensorAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5-7\n");
    }
}

// 27. Нажатие педали в АО с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645342_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645322)
        || settings_check(p_c9645322) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(40);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndBrakeAndSensorAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5-7\n");
    }
}

// 28. Нажатие педали в АО без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9645343_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9645320)
        || settings_check(p_c9645320) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка по ДД не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании ДД:                                           | включено (галка есть)
        ||Длительность блокировки:                                                   | 5 сек.
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(40);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 6. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */

    /*!
        Шаг 7. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки потенциал не подан)
    */
    if (!setSensorAndBrakeAndSensorAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5-7\n");
    }
}

// 1. Включение АО без нажатой педали и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658759_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 2. Включение АО с нажатой педалью и без требования нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658760_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 3. Включение АО с нажатой педалью с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658761_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 4. Повторное включение блокировки в АО без педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658762_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не отключается в АО, даже если тревога уже отключалась*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Не позднее чем через 30 сек (внутренний таймаут продолжительности одного полуцикла тревоги) выключена тревога
        Блокировка не отключилась (на выход блокировки не подан потенциал)
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не отключилась (на выход блокировки не подан потенциал)
    */
    if (!resetBrakeAndRestartIgnAndCheckBlock(BLOCK_NOT_OFF))
    {
        printf("FAIL Шаг 6-8\n");
    }
}

// 5. Включение АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658763_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 20
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(20);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 6. Включение АО без нажатой педали и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658745_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658745)
        || settings_check(p_c9658745) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 7. Включение АО с нажатой педалью и без требования нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658746_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658745)
        || settings_check(p_c9658745) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без настроенного необходимого нажатия педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 8. Включение АО с нажатой педалью с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658747_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658747)
        || settings_check(p_c9658747) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается c нажатой педалью тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 9. Повторное включение блокировки в АО без педали (нет данных о скорости)
void AutoTestsModesP2::C9658748_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658747)
        || settings_check(p_c9658747) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза, даже если уже включалась во время этого АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
        return;
    }

    /*!
        Шаг 6. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Не позднее чем через 30 сек (внутренний таймаут продолжительности одного полуцикла тревоги) выключена тревога
        Блокировка не отключилась (на выход блокировки не подан потенциал)
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        Блокировка не отключилась (на выход блокировки не подан потенциал)
    */
    if (!resetBrakeAndRestartIgnAndCheckBlock(BLOCK_NOT_OFF))
    {
        printf("FAIL Шаг 6-8\n");
    }
}

// 10. Включение АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658749_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658747)
        || settings_check(p_c9658747) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали тормоза*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 11. Включение АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658766_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 12. Включение АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658767_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 13. Включение АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658768_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 14. Включение АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658769_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 15. Включение АО без нажатой педали и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9658752_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 9
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(9);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 16. Включение АО с нажатой педалью и без требования нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9658753_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 7
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(7);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 17. Включение АО с нажатой педалью с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9658754_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 3
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(3);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 18. Включение АО без нажатой педали с требованием нажатия педали (скорость ниже 10)
void AutoTestsModesP2::C9658755_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается с скоростью ниже 10*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(0);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 19. 180 сек. АО без нажатой педали и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658770_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 20. 180 сек. АО с нажатой педалью и без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658771_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 21. 180 сек. АО с нажатой педалью с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658772_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_ON, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 22. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658773_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается с превышенной скоростью через 180 сек. после включения АО*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 60
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(60);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 23. 180 сек. АО без нажатой педали с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658750_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658747)
        || settings_check(p_c9658747) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается без нажатой педали тормоза через 180 сек после начала тревоги*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 24. 180 сек. АО без нажатой педали с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658764_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается без нажатой педали через 180 сек. после включения АО, если есть данные о скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
        Через 180 сек. (внутренний таймаут) блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_DELAYED_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 25. Нажатие педали в АО с требованием нажатия педали (скорость от 10 до допустимой)
void AutoTestsModesP2::C9658765_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается после нажатия педали в АО при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 15
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(15);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 26. Нажатие педали в АО с требованием нажатия педали (нет данных о скорости)
void AutoTestsModesP2::C9658751_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658747)
        || settings_check(p_c9658747) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается после нажатия педали в АО при отсутствии скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Включилась блокировка (с выхода блокировки снят потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 27. Нажатие педали в АО с требованием нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658774_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658754)
        || settings_check(p_c9658754) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | включено (галка есть)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */
    p_gen6->setSpeed(40);

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// 28. Нажатие педали в АО без требования нажатия педали (скорость выше допустимой)
void AutoTestsModesP2::C9658775_TestCase()
{
    if (   !getAndSetAhjSettings(p_c9658752)
        || settings_check(p_c9658752) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается после нажатия педали в АО при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | включено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 40
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | включен
        ||Педаль тормоза:                                                            | не нажата
        ||Метка:                                                                     | включена
        ||Паркинг:                                                                   | отключен
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Педаль тормоза CAN-автомобиля (сигнал состояния):                          | отключен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НР
        ||Снятие блокировки:                                                         | при снятии с охраны
        ||Задержка блокировки:                                                       | 0
        ||Блокировать при срабатывании датчика движения:                             | нет
        ||Настроен выход:                                                            | блокировка двигателя
        ||Настроен вход:                                                             | концевой выключатель педали тормоза
        ||Блокировать двигатель в антиограблении только при нажатии педали тормоза:  | отключено (галки нет)
        ||Антиограбление при пропадании:                                             | метки (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:                       | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:                                 | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:                            | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                                         | 3 сек
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setAhjAndCheckBlock(BRAKE_PEDAL_OFF, AHJ_BLOCK_TYPE_INSTANT_OFF))
    {
        printf("FAIL Шаг 1-4\n");
        return;
    }

    /*!
        Шаг 5. Нажать педаль тормоза
    */
    /*!
        Педаль тормоза нажата
        Блокировка не включилась (с выхода блокировки не снят потенциал)
    */
    if (!setBrakeAndCheckBlock(BLOCK_NOT_ON))
    {
        printf("FAIL Шаг 5\n");
    }
}

// Блокировка по ДД в ЗП при допустимой скорости
void AutoTestsModesP2::C9745928_TestCase()
{
    // Нужен хотя бы один способ снятия с охраны помимо метки
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9745928) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | отключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Метка:                                                                     | отключена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Длительность блокировки:                                                   | 5
        ||Настроен выход:                                                            | блокировка двигателя
        ||Снятие запрета поездки:                                                    | метка
        ||Условие активации запрета поездки:                                         | при снятии с охраны
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить скорость 20
    */
    /*!
        Скорость увеличилась до 20
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 5 сек (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setImmoAndSensorAndCheckBlock(BLOCK_ON,
                                       CAR_SPEED_ON,
                                       20))
    {
        printf("FAIL Шаг 1-4\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Блокировка по ДД с задержкой в ЗП при допустимой скорости
void AutoTestsModesP2::C9745929_TestCase()
{
    // Нужен хотя бы один способ снятия с охраны помимо метки
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9745929) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | отключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Метка:                                                                     | отключена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 2
        ||Длительность блокировки:                                                   | 6
        ||Настроен выход:                                                            | блокировка двигателя
        ||Снятие запрета поездки:                                                    | метка
        ||Условие активации запрета поездки:                                         | при снятии с охраны
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить скорость 25
    */
    /*!
        Скорость увеличилась до 25
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 2 сек (задержка блокировки) включилась блокировка (на выход блокировки подан потенциал)
        Через 6 сек (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setImmoAndSensorAndCheckBlock(BLOCK_ON,
                                       CAR_SPEED_ON,
                                       25))
    {
        printf("FAIL Шаг 1-4\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Блокировка по ДД в ЗП без данных о скорости
void AutoTestsModesP2::C9745930_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9745930) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | отключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Метка:                                                                     | отключена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Длительность блокировки:                                                   | 4
        ||Настроен выход:                                                            | блокировка двигателя
        ||Снятие запрета поездки:                                                    | метка
        ||Условие активации запрета поездки:                                         | при снятии с охраны
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Включилась блокировка (на выход блокировки подан потенциал)
        Через 4 сек (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setImmoAndSensorAndCheckBlock(BLOCK_ON,
                                       CAR_SPEED_OFF))
    {
        printf("FAIL Шаг 1-3\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Блокировка по ДД с задержкой в ЗП без данных о скорости
void AutoTestsModesP2::C9745931_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9745931) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка включается при допустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | отключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Метка:                                                                     | отключена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | 0000 - Без CAN
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 5
        ||Длительность блокировки:                                                   | 7
        ||Настроен выход:                                                            | блокировка двигателя
        ||Снятие запрета поездки:                                                    | метка
        ||Условие активации запрета поездки:                                         | при снятии с охраны
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 5 сек (задержка блокировки) включилась блокировка (на выход блокировки подан потенциал)
        Через 7 сек (длительность блокировки) блокировка отключилась (с выхода блокировки снят потенциал)
    */
    if (!setImmoAndSensorAndCheckBlock(BLOCK_ON,
                                       CAR_SPEED_OFF))
    {
        printf("FAIL Шаг 1-3\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Блокировка по ДД в ЗП при недопустимой скорости
void AutoTestsModesP2::C9745932_TestCase()
{
    // Нужен хотя бы один способ снятия с охраны помимо метки
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9745928) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка не включается при недопустимой скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | охрана
        ||Зажигание:                                                                 | отключено
        ||Дверь:                                                                     | закрыта
        ||Скорость:                                                                  | 0
        ||Блокировка:                                                                | отключена
        ||Выход блокировки:                                                          | отключен
        ||Метка:                                                                     | отключена
        ||Паркинг:                                                                   | отключен
        ||GPS-приемник:                                                              | отключен (координаты не получены)
        ||Настройки:
        ||Датчик движения:                                                           | включен (30)
        ||Выбран CAN-автомобиль:                                                     | Batmobile
        ||Скорость CAN-автомобиля (сигнал состояния):                                | включен
        ||Скорость, ниже которой разрешена блокировка двигателя:                     | 30
        ||Тип блокировки двигателя:                                                  | НЗ
        ||Задержка блокировки:                                                       | 0
        ||Длительность блокировки:                                                   | 5
        ||Настроен выход:                                                            | блокировка двигателя
        ||Снятие запрета поездки:                                                    | метка
        ||Условие активации запрета поездки:                                         | при снятии с охраны
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить скорость 50
    */
    /*!
        Скорость увеличилась до 50
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Блокировка не включилась (на выход блокировки не подан потенциал)
    */
    if (!setImmoAndSensorAndCheckBlock(BLOCK_NOT_ON,
                                       CAR_SPEED_ON,
                                       50))
    {
        printf("FAIL Шаг 1-4\n");
    }

    p_gen6->resetAuthAndImmo(IGN_NOT_OFF);

    if (settings_check(p_no_auth) == 0)
    {
        printf("FAIL При смене настроек\n");
    }
}

// Отсутствие блокировки АКПП при выключенной настройке
void AutoTestsModesP2::C9801189_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c9801189) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировк АКПП не включается, если отключена опционально*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | настроен
        ||Блокировка АКПП (настройка):   | отключена
    */

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Переключить положение АКПП (CAN) из "Р" (в "R" или "N" или "D") (при ручном тестировании с помощью imitCAN)
    */
    /*!
        Блокировка АКПП не включилась
        Сообщение в CAN ID=1A2 D0=01 отсутствует (ЦБ их не отсылает)
    */
    if (!is_fail)
    {
        if (!setArmAndCheckGearboxNoBlock(PARKING_TYPE_CAN))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Отсутствие блокировки АКПП на аналоговом паркинге
void AutoTestsModesP2::C9801190_TestCase()
{
    bool is_fail = false;


    if (!p_gen6->loadCanFirmware("9942"))
    {
        printf("FAIL При загрузке прошивки CAN\n");
        return;
    }

    if (settings_check(p_c9801190) == 0)
    {
        is_fail = true;
    }

    // убрать после решения FB-2113
    wait(TIME_DELAY::AFTER_LOADING_CAN_FW_TIME_S);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировк АКПП не включается если паркинг настроен не по CAN*
        ||Состояние стенда:
        ||Автомобиль в:                  | охрана
        ||Паркинг:                       | включен
        ||Настройки:
        ||Автомобиль CAN:                | 9942 - Batmobile
        ||Канал Паркинг CAN:             | не настроен
        ||Канал Паркинг:                 | настроен
        ||Блокировка АКПП (настройка):   | включена
    */

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Блокировка АКПП не включилась
        Сообщение в CAN ID=1A2 D0=01 отсутствует (ЦБ их не отсылает)
    */
    if (!is_fail)
    {
        if (!setArmAndCheckGearboxNoBlock(PARKING_TYPE_ANALOG))
        {
            printf("FAIL Шаг 1-2\n");
        }
    }

    if (settings_check(p_can_ovl_one_dis) == 0)
    {
        printf("FAIL При смене настроек (CAN)\n");
    }
}

// Нарушение зоны охраны в тревоге после открытия багажника (авторизация по брелоку)
void AutoTestsModesP2::C9913925_TestCase()
{
    if ((p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9913925) == 0)
    {
        return;
    }

    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время поиска метки и брелока при открытом багажнике\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что тревога по багажнику не прекращается при появлении средств авторизации, из-за наступления тревоги по другим зонам*
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Дверь:                                                                 | закрыта
        ||Зажигание:                                                             | выключено
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | выкл
        ||Авторизация по Брелоку:                                                | вкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия\n");
    }

    if ((p_gen6->getModules() & BLE_MODULE) == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
    }

    p_gen6->setLcdKeyringVcc(OFF);

    printf("INFO Ожидание потери метки/брелока\n");
    p_gen6->wait_s(max((float)TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S,
                       (float)TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S));

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск брелока) включилась Тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               m_trunk_tag_rem_wait_time_s,
                               TimeoutCalculator::calcToutError(m_trunk_tag_rem_wait_time_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность, т.к. статусы по SLP
                                                                                                                                        // Могут долго обновляться
    {
        printf("PASS Шаг 1. Тревога включилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включилась\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_TRUNK))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Тревога продолжается
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Тревога продолжается\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога выключена\n");
        return;
    }

    /*!
        Шаг 3. Включить брелок
    */
    /*!
        Брелок обнаружен
        Тревога продолжается (т.к. открыта дверь)
        Переход в охрану с нарушенным периметром не произошел
    */
    p_gen6->setLcdKeyringVcc(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::MAX_REMOTE_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Тревога продолжается (т.к. открыта дверь)\n");
    }
    else
    {
        // Тревога может выключиться из-за паузы между полуциклами
        // Если не возобновилась - значит ошибка
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    TIME_DELAY::ALARM_PAUSE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("FAIL Шаг 3. Тревога выключена\n");
        }
    }
}

// Нарушение зоны охраны в тревоге после открытия багажника (авторизация по метке)
void AutoTestsModesP2::C9913926_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c9913926) == 0)
    {
        return;
    }

    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Время поиска метки и брелока при открытом багажнике\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что тревога по багажнику не прекращается при появлении средств авторизации, из-за наступления тревоги по другим зонам*
        ||Состояние стенда:
        ||Автомобиль в:                                                          | Охрана
        ||Багажник:                                                              | закрыт
        ||Дверь:                                                                 | закрыта
        ||Зажигание:                                                             | выключено
        ||Метка:                                                                 | выключена
        ||Брелок:                                                                | выключен
        ||Настройки:
        ||Авторизация по Метке:                                                  | вкл
        ||Авторизация по Брелоку:                                                | выкл
        ||Разрешить в охране открытие багажника при наличии метки или брелока:   | да
        ||Время поиска метки и брелока при открытом багажнике:                   | 15 сек
    */
    if (!setSecureZoneClosed(ON, KEYRING))
    {
        printf("FAIL Начальные условия\n");
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        p_gen6->setLcdKeyringVcc(OFF);
    }

    p_gen6->resetTagVcc();

    printf("INFO Ожидание потери метки/брелока\n");
    p_gen6->wait_s(max((float)TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S,
                       (float)TIME_DELAY::MAX_REMOTE_INVISIBLE_TIME_S));

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (поиск метки) включилась Тревога по багажнику
    */
    p_gen6->setTrunk(OPEN, PIN);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               m_trunk_tag_rem_wait_time_s,
                               TimeoutCalculator::calcToutError(m_trunk_tag_rem_wait_time_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность, т.к. статусы по SLP
                                                                                                                                        // Могут долго обновляться
    {
        printf("PASS Шаг 1. Тревога включилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включилась\n");
        return;
    }

    if (p_gen6->getSlpCmdStatus(DIAG_DATA_PERIM,
                                SLP_STATUSES_SIZES::DIAG_DATA_PERIM_SIZE,
                                DIAG_PERIM_BIT_TRUNK))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Тревога продолжается
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 2. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 2. Зажигание не включено\n");
        return;
    }

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Тревога продолжается\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога выключена\n");
        return;
    }

    /*!
        Шаг 3. Включить метку
    */
    /*!
        Метка обнаружена
        Тревога продолжается (т.к. включено зажигание)
        Переход в охрану с нарушенным периметром не произошел
    */
    p_gen6->setTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::MAX_TAG_VISIBLE_TIME_S + TIME_DELAY::MAX_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Тревога продолжается (т.к. включено зажигание)\n");
    }
    else
    {
        // Тревога может выключиться из-за паузы между полуциклами
        // Если не возобновилась - значит ошибка
        if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ON,
                                    TIME_DELAY::ALARM_PAUSE_TIME_S + TIME_DELAY::MIN_WAITING_REGION_STATE_S))
        {
            printf("FAIL Шаг 3. Тревога выключена\n");
        }
    }
}

// 1. Выключение паркинга без зажигания с включенной настройкой
void AutoTestsModesP2::C10271054_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Статус паркинга (отключен) не изменился, т.к. зажигание выключено
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 2. Выключение ручника без зажигания с включенной настройкой
void AutoTestsModesP2::C10271055_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 3. Включение тормоза без зажигания с включенной настройкой
void AutoTestsModesP2::C10271056_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить педаль тормоза
    */
    /*!
        Статус педали тормоза (отключена) не изменился, т.к. зажигание выключено
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 4. Выключение паркинга без зажигания с отключенной настройкой
void AutoTestsModesP2::C10271057_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Статус паркинга (отключен) не изменился, т.к. зажигание выключено
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 5. Выключение ручника без зажигания с отключенной настройкой
void AutoTestsModesP2::C10271058_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 6. Включение тормоза без зажигания с отключенной настройкой
void AutoTestsModesP2::C10271059_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить педаль тормоза
    */
    /*!
        Статус педали тормоза (отключена) не изменился, т.к. зажигание выключено
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 7. Выключение паркинга с зажиганием с включенной настройкой с последующим выключением зажигания
void AutoTestsModesP2::C10271060_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 8. Выключение ручника с зажиганием с включенной настройкой с последующим выключением зажигания
void AutoTestsModesP2::C10271061_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 9. Включение тормоза с зажиганием с включенной настройкой с последующим выключением зажигания
void AutoTestsModesP2::C10271062_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить педаль тормоза
    */
    /*!
        Педаль тормоза включена
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 10. Выключение паркинга с зажиганием с включенной настройкой с последующим включением паркинга
void AutoTestsModesP2::C10271063_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Включить паркинг
    */
    /*!
        Паркинг включен
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 11. Выключение ручника с зажиганием с включенной настройкой с последующим включением ручника
void AutoTestsModesP2::C10271064_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Включить ручник
    */
    /*!
        Ручник включен
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 12. Включение тормоза с зажиганием с включенной настройкой с последующим выключением тормоза
void AutoTestsModesP2::C10271065_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить педаль тормоза
    */
    /*!
        Педаль тормоза включена
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 4. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 13. Выключение паркинга с зажиганием с отключенной настройкой
void AutoTestsModesP2::C10271066_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 14. Выключение ручника с зажиганием с отключенной настройкой
void AutoTestsModesP2::C10271067_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 15. Включение тормоза с зажиганием с отключенной настройкой
void AutoTestsModesP2::C10271068_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель не включается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | выкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Включить педаль тормоза
    */
    /*!
        Педаль тормоза включена
        Оповещение звукоизвещателем не включилось (импульсы на внешний звуковой извещатель отсутствуют)
    */
}

// 16. Включение зажигания с включенной настройкой с последующим выключением зажигания
void AutoTestsModesP2::C10271069_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Оповещение звукоизвещателем отключилось (импульсы на внешний звуковой извещатель прекратились)
    */
}

// 17. Включение паркинга с зажиганием с включенной настройкой с активным извещением
void AutoTestsModesP2::C10271070_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Включить паркинг
    */
    /*!
        Паркинг включен
        Оповещение звукоизвещателем продолжается
    */
}

// 18. Включение ручника с зажиганием с включенной настройкой с активным извещением
void AutoTestsModesP2::C10271071_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Включить ручник
    */
    /*!
        Ручник включен
        Оповещение звукоизвещателем продолжается
    */
}

// 19. Выключение тормоза с зажиганием с включенной настройкой с активным извещением
void AutoTestsModesP2::C10271072_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | вкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Включить педаль тормоза
    */
    /*!
        Педаль тормоза включена
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
        Оповещение звукоизвещателем продолжается
    */
}

// 20. Включение паркинга с зажиганием с отключенной настройкой с активным извещением
void AutoTestsModesP2::C10271073_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг отключен
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Включить паркинг
    */
    /*!
        Паркинг включен
        Оповещение звукоизвещателем продолжается
    */
}

// 21. Включение ручника с зажиганием с отключенной настройкой с активным извещением
void AutoTestsModesP2::C10271074_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Выключить ручник
    */
    /*!
        Ручник отключен
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Включить ручник
    */
    /*!
        Ручник включен
        Оповещение звукоизвещателем продолжается
    */
}

// 22. Выключение тормоза с зажиганием с отключенной настройкой с активным извещением
void AutoTestsModesP2::C10271075_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что звукоизвещатель включается и не выключается*
        ||Состояние стенда:
        ||Автомобиль в:                                                                           | Охрана
        ||Зажигание:                                                                              | выключено
        ||Метка:                                                                                  | выключена
        ||Брелок:                                                                                 | включен
        ||Педаль тормоза:                                                                         | не нажата
        ||Паркинг:                                                                                | включен
        ||Стояночный тормоз:                                                                      | включен
        ||Настройки:
        ||Снятие запрета поездки:                                                                 | по Метке
        ||Напоминание звуковым извещателем в запрете поездки/ При снятии с паркинга:              | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При опускании стояночного тормоза:  | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При нажатии педали тормоза:         | выкл
        ||Напоминание звуковым извещателем в запрете поездки/ При включенном зажигании:           | вкл
        ||Настроен выход:                                                                         | Внешний звуковой извещатель со встроенным генератором
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Оповещение звукоизвещателем включилось (импульсы на внешний звуковой извещатель по 3 шт с длительным промежутком)
    */

    /*!
        Шаг 3. Включить педаль тормоза
    */
    /*!
        Педаль тормоза включена
        Оповещение звукоизвещателем продолжается
    */

    /*!
        Шаг 4. Выключить педаль тормоза
    */
    /*!
        Педаль тормоза отключена
        Оповещение звукоизвещателем продолжается
    */
}

// Обновление прошивки с R4
void AutoTestsModesP2::C10288872_TestCase()
{
    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4
        ||Прошивка ЦБ:                         | предшествующая проверяемой
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена прошивка предшествующая проверяемой*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_PREV_TO_CURR, RELAY_TYPE_R4))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Обновление прошивки с R4v2
void AutoTestsModesP2::C10288873_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4v2 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4v2
        ||Прошивка ЦБ:                         | предшествующая проверяемой
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена прошивка предшествующая проверяемой*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4v2 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4v2 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4v2 включает блокировку
    */
}

// Обновление прошивки с R6
void AutoTestsModesP2::C10288874_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6
        ||Прошивка ЦБ:                         | предшествующая проверяемой
        **Примечание:** *на ЦБ установлена прошивка предшествующая проверяемой*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R6 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_PREV_TO_CURR, RELAY_TYPE_R6))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Обновление прошивки с R6eco
void AutoTestsModesP2::C10288875_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6eco
        ||Прошивка ЦБ:                         | предшествующая проверяемой
        **Примечание:** *на ЦБ установлена прошивка предшествующая проверяемой*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6eco запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6eco включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_PREV_TO_CURR, RELAY_TYPE_R6ECO))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Обновление прошивки с R4 с версии не выше 2.18
void AutoTestsModesP2::C10288876_TestCase()
{
    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4
        ||Прошивка ЦБ:                         | не выше 2.18 (=<2.18)
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена прошивка не выше 2.18 (=<2.18)*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую (новую)
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_SPECIAL_TO_CURR, RELAY_TYPE_R4))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Обновление прошивки с R4v2 с версии не выше 2.18
void AutoTestsModesP2::C10288877_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4v2 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4v2
        ||Прошивка ЦБ:                         | не выше 2.18 (=<2.18)
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена прошивка не выше 2.18 (=<2.18)*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4v2 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую (новую)
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4v2 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4v2 включает блокировку
    */
}

// Обновление прошивки с R6 с версии не выше 2.18
void AutoTestsModesP2::C10288878_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6
        ||Прошивка ЦБ:                         | не выше 2.18 (=<2.18)
        **Примечание:** *на ЦБ установлена прошивка не выше 2.18 (=<2.18)*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R6 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую (новую)
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_SPECIAL_TO_CURR, RELAY_TYPE_R6))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Обновление прошивки с R6eco с версии не выше 2.18
void AutoTestsModesP2::C10288879_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6eco
        ||Прошивка ЦБ:                         | не выше 2.18 (=<2.18)
        **Примечание:** *на ЦБ установлена прошивка не выше 2.18 (=<2.18)*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на проверяемую (новую)
    */
    /*!
        Прошивка ЦБ обновлена на проверяемую
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6eco запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6eco включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_SPECIAL_TO_CURR, RELAY_TYPE_R6ECO))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Откат прошивки с R4
void AutoTestsModesP2::C10288880_TestCase()
{
    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4 продолжает работать после обновления прошивки на предыдущую*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4
        ||Прошивка ЦБ:                         | последняя проверяемая
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена проверяемая прошивка*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на предшествующую проверяемой
    */
    /*!
        Прошивка ЦБ обновлена на предшествующую проверяемой
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_CURR_TO_PREV, RELAY_TYPE_R4))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Откат прошивки с R4v2
void AutoTestsModesP2::C10288881_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R4v2 продолжает работать после обновления прошивки на предыдущую*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||К ЦБ подключен и зарегистрирован:    | R4v2
        ||Прошивка ЦБ:                         | последняя проверяемая
        ||Настройки:
        ||Настроен выход:                      | Управление кодовым реле R4
        **Примечание:** *на ЦБ установлена проверяемая прошивка*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R4v2 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на предшествующую проверяемой
    */
    /*!
        Прошивка ЦБ обновлена на предшествующую проверяемой
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R4v2 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R4v2 включает блокировку
    */
}

// Откат прошивки с R6
void AutoTestsModesP2::C10288882_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки на предыдущую*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6
        ||Прошивка ЦБ:                         | последняя проверяемая
        **Примечание:** *на ЦБ установлена проверяемая прошивка*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
        R6 отпирает замок капота
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на предшествующую проверяемой
    */
    /*!
        Прошивка ЦБ обновлена на предшествующую проверяемой
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6 запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6 включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_CURR_TO_PREV, RELAY_TYPE_R6))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Откат прошивки с R6eco
void AutoTestsModesP2::C10288883_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (p_gen6->checkHotFirmware() != FW_TYPE_NOT_HOT) // Если FW_TYPE_HOT или FW_TYPE_UNKNOWN
    {
        printf("FAIL Данная прошивка не тестируется, т.к. на нее нельзя будет вернуться после теста (отсутствует на сервере)\n");
        return;
    }

    if (settings_check(p_c10288872) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::loadCurrFw); // Для возвращения на тестируемую версию ПО


    saveCurrFw();

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что R6 продолжает работать после обновления прошивки на предыдущую*
        ||Состояние стенда:
        ||Автомобиль в:                        | Охрана
        ||Зажигание:                           | выключено
        ||Брелок:                              | включен
        ||В ЦБ зарегистрирован:                | R6eco
        ||Прошивка ЦБ:                         | последняя проверяемая
        **Примечание:** *на ЦБ установлена проверяемая прошивка*
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в снято
    */

    /*!
        Шаг 2. Обновить прошивку ЦБ на предшествующую проверяемой
    */
    /*!
        Прошивка ЦБ обновлена на предшествующую проверяемой
    */

    /*!
        Шаг 3. Включить охрану брелоком
    */
    /*!
        Переход из снято в охрану
        R6eco запирает замок капота
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        Включение тревоги
        R6eco включает блокировку
    */
    if (!setFwAndCheckRelay(FW_UPDATE_FROM_CURR_TO_PREV, RELAY_TYPE_R6ECO))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// Открыть дверь
void AutoTestsModesP2::C10369958_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369958) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отключенной авторизации по двери авторизация не наступает*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Отключена
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включена тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
    }
}

// Открыть багажник
void AutoTestsModesP2::C10369959_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369958) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отключенной авторизации по багажнику авторизация не наступает*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Отключена
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включена тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
    }
}

// Открыть дверь с запущенным двигателем
void AutoTestsModesP2::C10369960_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369958) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отключенной авторизации по двери авторизация не наступает*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Отключена
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_DOOR, DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Открыть багажник с запущенным двигателем
void AutoTestsModesP2::C10369961_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369958) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отключенной авторизации по багажнику авторизация не наступает*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Отключена
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_TRUNK, DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Открыть дверь
void AutoTestsModesP2::C10369962_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369962) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации по двери авторизация не наступает с заглушенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери при работающем двигателе
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включена тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
    }
}

// Открыть багажник
void AutoTestsModesP2::C10369963_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369962) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации по двери авторизация по багажнику не наступает с заглушенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери при работающем двигателе
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 1. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 1. Багажник не открыт\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включена тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включена\n");
    }
}

// Открыть дверь с запущенным двигателем
void AutoTestsModesP2::C10369964_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369962) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации по двери авторизация по двери наступает с заведенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери при работающем двигателе
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в состояние авторизации
        Тревога не включилась
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_DOOR, DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Открыть багажник с запущенным двигателем
void AutoTestsModesP2::C10369965_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369962) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации по двери авторизация по багажнику не наступает с заведенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери при работающем двигателе
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Включена тревога
        Переход в состояние авторизации не произошел
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_TRUNK, DIAG_GUARD_STATE_ALERT_MAIN))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Открыть дверь с запущенным двигателем
void AutoTestsModesP2::C10369966_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369966) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации авторизация по двери наступает с заведенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть дверь
    */
    /*!
        Дверь открыта
        Переход в состояние авторизации
        Тревога не включилась
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_DOOR, DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Открыть багажник с запущенным двигателем
void AutoTestsModesP2::C10369967_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        // Если нет метки для авторизации - то должны присутствовать брелок (авторизация) и GSM модуль (для ДЗ)
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            || (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }
    else
    {
        // Если есть метка для авторизации - то для выполнения ДЗ должен присутствовать либо брелок, либо GSM модуль
        if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE)
        {
            printf(CASE_NOT_FOUND);
            return;
        }
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10369966) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при включенной авторизации авторизация по багажнику наступает с заведенным двигателем*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | Охрана
        ||Дверь:                                                                   | закрыта
        ||Багажник:                                                                | закрыт
        ||Метка:                                                                   | выключена
        ||Брелок:                                                                  | включен
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                    | вкл
        ||Авторизация по Брелоку:                                                  | выкл
        ||Slave при подключении к CAN:                                             | включено
        ||Аналоговый Slave:                                                        | включено
        ||(Событие запуска авторизации) При открытии двери или багажника:          | Открытие двери или багажника
        ||Ожидание авторизации, шаг 1:                                             | 15 сек
        ||Ожидание авторизации, шаг 2:                                             | 10 сек
        ||Ожидание авторизации, шаг 3:                                             | 10 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:     | отключено
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Один импульс
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 3с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 3с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 3с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 3с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    resetAuthByTagOrRemote();

    /*!
        Шаг 1. Выполнить ДЗ (брелоком)
    */
    /*!
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */

    /*!
        Шаг 2. Запустить двигатель (включить зажигание и обороты)
    */
    /*!
        Двигатель запущен
        Кнопка Старт-Стоп отключена
    */

    /*!
        Шаг 3. Открыть багажник
    */
    /*!
        Багажник открыт
        Переход в состояние авторизации
        Тревога не включилась
    */
    if (!runEngAndSetZoneAndCheckState(ZONE_DOOR, DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// 21. Включение зажигания и переход в сервис
void AutoTestsModesP2::C10415982_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию и не выключается при переходе в сервис*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */
    if (!setServiceAndCheckVideoRegOn(SERVICE_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Ожидать 6 мин. (внутренний тайминг системы 5 минут, выход не должен выключиться)
    */
    /*!
        Выход видеорегистратора включен
    */
    if (!p_gen6->waitVideoReg(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S + TIME_DELAY::ONE_MINUTE, !p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("PASS Шаг 3. Выход видеорегистратора включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Выход видеорегистратора не включен\n");
    }
}

// 22. Включение зажигания в сервисе
void AutoTestsModesP2::C10415983_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию в сервисе, и не выключается, если зажигание не отключено*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим включен
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Ожидать 6 мин. (внутренний тайминг системы 5 минут, выход не должен выключиться)
    */
    /*!
        Выход видеорегистратора включен
    */
    if (!p_gen6->waitVideoReg(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S + TIME_DELAY::ONE_MINUTE, !p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("PASS Шаг 3. Выход видеорегистратора включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Выход видеорегистратора не включен\n");
    }
}

// 23. Включение зажигания в сервисе и переход из сервиса
void AutoTestsModesP2::C10415984_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию в сервисе, и не выключается при выходе из сервиса, если зажигание не отключено*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим включен
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить сервисный режим
    */
    /*!
        Сервисный режим выключен
        Выход видеорегистратора включен
    */
    if (!setServiceAndCheckVideoRegOn(SERVICE_OFF))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Ожидать 6 мин. (внутренний тайминг системы 5 минут, выход не должен выключиться)
    */
    /*!
        Выход видеорегистратора включен
    */
    if (!p_gen6->waitVideoReg(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S + TIME_DELAY::ONE_MINUTE, !p_gen6->getPolarity(ID_OUT_VIDEO_REG)))
    {
        printf("PASS Шаг 3. Выход видеорегистратора включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Выход видеорегистратора не включен\n");
    }
}

// 24. Включение зажигания не в сервисе и выключение зажигания в сервисе
void AutoTestsModesP2::C10415985_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию в снято, и выключается в сервисе по истечению времени работы*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | снято
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */
    if (!setServiceAndCheckVideoRegOn(SERVICE_ON))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Выход видеорегистратора включен
    */

    /*!
        Шаг 4. Ожидать 5 мин. после отключения зажигания (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!resetIgnAndCheckVideoRegOff())
    {
        printf("FAIL Шаг 3-4\n");
    }
}

// 25. Включение и выключение зажигания в сервисе
void AutoTestsModesP2::C10415986_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию в сервисе и выключается по истечению времени работы в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим включен
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Выход видеорегистратора включен
    */

    /*!
        Шаг 3. Ожидать 5 мин. после отключения зажигания (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!resetIgnAndCheckVideoRegOff())
    {
        printf("FAIL Шаг 2-3\n");
    }
}

// 26. Включение зажигания в сервисе и выключение зажигания не в сервисе
void AutoTestsModesP2::C10415987_TestCase()
{
    Timer ign_off_timer; // Таймер, включается в момент выключения зажигания


    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по зажиганию в сервисе и выключается по истечению времени работы в снято с охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим включен
        ||Зажигание:                                                                 | выключено
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_ON))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Зажигание выключено
        Выход видеорегистратора включен
    */
    if (!setIgnAndCheckVideoRegOn(IGN_OFF, &ign_off_timer))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить сервисный режим
    */
    /*!
        Сервисный режим выключен
        Выход видеорегистратора включен
    */
    if (!setServiceAndCheckVideoRegOn(SERVICE_OFF))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Ожидать 5 мин. после отключения зажигания (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    ign_off_timer.stop();

    if (!waitVideoRegOff(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S - ign_off_timer.read(),
                         TimeoutCalculator::calcToutError(TIME_DELAY::MAX_VIDEO_REG_WORK_TIME_S)))
    {
        printf("FAIL Шаг 4\n");
    }
}

// 27. Включение и отмена тревоги и переход в сервис
void AutoTestsModesP2::C10415988_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по тревоге и выключается по истечению времени работы в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | в охране
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Не ранее чем через 15 сек после включения охраны
        Вызвать тревогу (имитация датчика движения)
    */
    /*!
        Тревога включена
        Выход видеорегистратора включен
    */

    /*!
        Шаг 2. Отменить тревогу любым способом
    */
    /*!
        Тревога выключена
        Выход видеорегистратора включен
    */

    /*!
        Шаг 3. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */

    /*!
        Шаг 4. Ожидать 2 мин. после включения тревоги (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!setAlertAndServiceAndCheckVideoReg(SERVICE_ON))
    {
        printf("FAIL Шаг 1-4\n");
    }
}

// 28. Включение и отмена тревоги и переход в сервис и из сервиса
void AutoTestsModesP2::C10415989_TestCase()
{
    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по тревоге и выключается по истечению времени работы после перехода в сервис и из сервиса*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | в охране
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Не ранее чем через 15 сек после включения охраны
        Вызвать тревогу (имитация датчика движения)
    */
    /*!
        Тревога включена
        Выход видеорегистратора включен
    */

    /*!
        Шаг 2. Отменить тревогу любым способом
    */
    /*!
        Тревога выключена
        Выход видеорегистратора включен
    */

    /*!
        Шаг 3. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */

    /*!
        Шаг 4. Выключить сервисный режим
    */
    /*!
        Сервисный режим выключен
        Выход видеорегистратора включен
    */

    /*!
        Шаг 5. Ожидать 2 мин. после включения тревоги (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!setAlertAndServiceAndCheckVideoReg(SERVICE_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// 29. Включение регистратора через смс и переход в сервис
void AutoTestsModesP2::C10415990_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по смс в снято с охраны и выключается по истечению времени работы после перехода в сервис*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | в снято с охраны
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отправить СМС "69"
    */
    /*!
        Выход видеорегистратора включен
        Получено СМС "команда "включить видеорегистратор" выполнена"
    */

    /*!
        Шаг 2. Включить сервисный режим
    */
    /*!
        Сервисный режим включен
        Выход видеорегистратора включен
    */

    /*!
        Шаг 3. Ожидать 5 мин. после включения выхода видеорегистратора (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!setAndCheckServiceAndVideoReg(SERVICE_ON))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// 30. Включение регистратора через смс в сервисе
void AutoTestsModesP2::C10415991_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по смс в сервисе и выключается по истечению времени работы в сервисе*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->outputSms(); // Пропустить СМС о входе в сервис

    /*!
        Шаг 1. Отправить СМС "69"
    */
    /*!
        Выход видеорегистратора включен
        Получено СМС "команда "включить видеорегистратор" выполнена"
    */

    /*!
        Шаг 2. Ожидать 5 мин. после включения выхода видеорегистратора (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!setAndCheckServiceAndVideoReg(SERVICE_NO_CONTROL))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// 31. Включение регистратора через смс в сервисе и выход из сервиса
void AutoTestsModesP2::C10415992_TestCase()
{
    if ((p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10415982) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *Проверка того что видеорегистратор включается по смс в сервисе и выключается по истечению времени работы в снято с охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                                              | сервисный режим
        ||Настроен выход:                                                            | управление реле питания видеорегистратора
        ||Выход видеорегистратора:                                                   | выключен
    */
    if (!setInitState(INIT_ST_SERVICE))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->outputSms(); // Пропустить СМС о входе в сервис

    /*!
        Шаг 1. Отправить СМС "69"
    */
    /*!
        Выход видеорегистратора включен
        Получено СМС "команда "включить видеорегистратор" выполнена"
    */

    /*!
        Шаг 2. Выключить сервисный режим
    */
    /*!
        Сервисный режим выключен
        Выход видеорегистратора включен
    */

    /*!
        Шаг 3. Ожидать 5 мин. после включения выхода видеорегистратора (внутренний тайминг системы)
    */
    /*!
        Выход видеорегистратора выключен
    */
    if (!setAndCheckServiceAndVideoReg(SERVICE_OFF))
    {
        printf("FAIL Шаг 1-3\n");
    }
}

// Закрыть дверь позднее чем через 10 сек
void AutoTestsModesP2::C10419622_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачного входа в режим ввода кода экстренного снятия с охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 1. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 1. Дверь не открыта\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Включена тревога\n");
    }
    else
    {
        printf("FAIL Шаг 1. Тревога не включилась\n");
        return;
    }

    /*!
        Шаг 2. Не ранее чем через 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы не отключились
        Тревога продолжается
    */
    p_gen6->wait_s(TIME_DELAY::ALT_SRV_BTN_DISARM_EN_TIMEOUT_S);
    p_gen6->setAltSrvBtnModeEn(ALT_SRV_BTN_TYPE_DOOR);

    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S); // Ожидание перед проверкой сигналов, т.к. они мигают, то без задержки точно не определить, что они отключились

    if (p_gen6->waitLights(TIME_DELAY::MAX_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_LIGHTS)))
    {
        printf("PASS Шаг 2. Световые сигналы не отключились\n");
    }
    else
    {
        printf("FAIL Шаг 2. Световые сигналы отключились\n");
        return;
    }

    p_gen6->wait_s(TIME_DELAY::ALARM_DIS_TIME_S);

    if (p_gen6->waitLights(TIME_DELAY::MAX_WIRE_EN_DELAY_S, p_gen6->getPolarity(ID_OUT_LIGHTS)))
    {
        printf("PASS Шаг 2. Световые сигналы не отключились (после полуцикла)\n");
    }
    else
    {
        printf("FAIL Шаг 2. Световые сигналы отключились (после полуцикла)\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 2. Тревога отключилась\n");
    }
}

// Ввести неправильно 1ую цифру
void AutoTestsModesP2::C10419623_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FIRST))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 2ую цифру
void AutoTestsModesP2::C10419624_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_SECOND))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 3ую цифру
void AutoTestsModesP2::C10419625_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_THIRD))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 4ую цифру
void AutoTestsModesP2::C10419626_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FOURTH))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильный код
void AutoTestsModesP2::C10419627_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_ALL))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести правильный код
void AutoTestsModesP2::C10419628_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны дверью*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Выключение авторизации кодом
void AutoTestsModesP2::C10419629_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419629) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны дверью*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | вкл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | брелоком
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - авторизация по метке
    // Иначе авторизация по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в авторизацию
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход из охраны в авторизацию\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в авторизацию не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 7. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_WAITING_AUTH,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-7\n");
    }
}

// Выключение запрета поездки кодом
void AutoTestsModesP2::C10419630_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419630) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны дверью*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | метка
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - снятие ЗП по метке
    // Иначе снятие ЗП по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход из охраны в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в запрет поездки не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Закрыть и открыть дверь A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Закрыть и открыть дверь B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Закрыть и открыть дверь X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 7. Закрыть и открыть дверь Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y закрываний и открываний двери
        Дверь осталась открытой
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_IMMO,
                                    ALT_SRV_BTN_TYPE_DOOR,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-7\n");
    }
}

// Ввести неправильно 1ую цифру
void AutoTestsModesP2::C10419632_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FIRST))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 2ую цифру
void AutoTestsModesP2::C10419633_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_SECOND))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 3ую цифру
void AutoTestsModesP2::C10419634_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_THIRD))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильно 4ую цифру
void AutoTestsModesP2::C10419635_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FOURTH))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести неправильный код
void AutoTestsModesP2::C10419636_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_ALL))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Ввести правильный код
void AutoTestsModesP2::C10419637_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
        Включена тревога
    */

    /*!
        Шаг 2. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
        Световые сигналы отключились
    */

    /*!
        Шаг 3. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Выключение авторизации кодом
void AutoTestsModesP2::C10419638_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419629) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | вкл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | брелоком
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - авторизация по метке
    // Иначе авторизция по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в авторизацию
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход из охраны в авторизацию\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в авторизацию не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 7. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_WAITING_AUTH,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-7\n");
    }
}

// Выключение запрета поездки кодом
void AutoTestsModesP2::C10419639_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419630) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | метка
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - снятие ЗП по метке
    // Иначе снятие ЗП по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход из охраны в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в запрет поездки не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 3. В течение (не позже) 10 сек (внутренний таймаут) с момента открытия двери (шаг 1): 4 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 4 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Включить и отключить зажигание A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано A включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Включить и отключить зажигание B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано B включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Включить и отключить зажигание X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано X включений и отключений зажигания
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 7. Включить и отключить зажигание Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Зафиксировано Y включений и отключений зажигания
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_IMMO,
                                    ALT_SRV_BTN_TYPE_IGN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-7\n");
    }
}

// Ввести неправильно 1ую цифру
void AutoTestsModesP2::C10419640_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FIRST))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Ввести неправильно 2ую цифру
void AutoTestsModesP2::C10419641_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_SECOND))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Ввести неправильно 3ую цифру
void AutoTestsModesP2::C10419642_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_THIRD))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Ввести неправильно 4ую цифру
void AutoTestsModesP2::C10419643_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_FOURTH))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Ввести неправильный код
void AutoTestsModesP2::C10419644_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что нельзя перейти в снято используя неверный код*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - цифра отличная от первой цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - цифра отличная от второй цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - цифра отличная от третьей цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - цифра отличная от четвертой цифры кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышки (импульсы) световыми сигналами отсутствуют
        Переход в снято не произошел
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_WRONG,
                                    EMERGENCY_DIS_PIN_NUM_ALL))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Ввести правильный код
void AutoTestsModesP2::C10419645_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны штатными кнопками*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) световые сигналы отключились 
        Вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_ALERT_MAIN,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Выключение авторизации кодом
void AutoTestsModesP2::C10419646_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419629) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны штатными кнопками*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | вкл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | брелоком
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | откл
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - авторизация по метке
    // Иначе авторизация по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в авторизацию
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_WAITING_AUTH))
    {
        printf("PASS Шаг 1. Переход из охраны в авторизацию\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в авторизацию не произошел\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_WAITING_AUTH,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-6\n");
    }
}

// Выключение запрета поездки кодом
void AutoTestsModesP2::C10419647_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::emergencyDisarming);


    if (settings_check(p_c10419630) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка ввода кода экстренного снятия с охраны зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                | Охрана
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Авторизация по Метке:                        | откл
        ||Авторизация по Брелоку:                      | откл
        ||Требовать авторизацию при снятии с охраны:   | откл
        ||Ожидание авторизации, шаг 1:                 | 15 сек
        ||Ожидание авторизации, шаг 2:                 | 10 сек
        ||Ожидание авторизации, шаг 3:                 | 10 сек
        ||Снятие запрета поездки:                      | метка
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если есть метка+брелок - снятие ЗП по метке
    // Иначе снятие ЗП по штатным кнопкам
    if (  (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        &&(p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в запрет поездки
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_IMMO))
    {
        printf("PASS Шаг 1. Переход из охраны в запрет поездки\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход из охраны в запрет поездки не произошел\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. Нажать штатную кнопку "Да" в imitCan A раз, где A - первая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 4. Нажать штатную кнопку "Да" в imitCan B раз, где B - вторая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan X раз, где X - третья цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) вспышка (импульс) световыми сигналами
    */

    /*!
        Шаг 6. Нажать штатную кнопку "Да" в imitCan Y раз, где Y - четвертая цифра кода экстренного снятия с охраны
    */
    /*!
        Через 5 сек (внутренний таймаут) три вспышки (импульса) световыми сигналами
        Переход в снято
    */
    if (!setAndCheckAltSrvBtnDisarm(DIAG_GUARD_STATE_IMMO,
                                    ALT_SRV_BTN_TYPE_STD_BTN,
                                    SRV_BTN_PIN_TYPE_CORRECT))
    {
        printf("FAIL Шаг 2-6\n");
    }
}

// Постановка в охрану штатными кнопками
void AutoTestsModesP2::C10419648_TestCase()
{
    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка постановки в охрану штатными кнопками*
        ||Состояние стенда:
        ||Автомобиль в:                                | снято
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */
    if (!setProgramNeutralAuto(GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan 3 раза
    */
    /*!
        Нет изменений
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan 3 раза
    */
    /*!
        Через 5 сек (внутренний таймаут) 3 длинных сигнала сирены 2 коротких сигнала сирены
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Через 15 сек после сигналов сирены (внутренний таймаут) переход в охрану
    */
    if (!p_gen6->setAndCheckAltSrvBtnArm(ALT_SRV_BTN_TYPE_STD_BTN))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Несоблюдение таймаутов при постановке кнопками
void AutoTestsModesP2::C10419649_TestCase()
{
    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачной постановки в охрану штатными кнопками*
        ||Состояние стенда:
        ||Автомобиль в:                                | снято
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
        ||Настройки:
        ||Настроен CAN-автомобиль:                     | 9999-Batmobile
        ||Сигнал CAN-состояния: Штатные кнопки:        | Вкл
        ||Подключен:                                   | imitCan
    */

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 2. Нажать штатную кнопку "Да" в imitCan 3 раза
    */
    /*!
        Нет изменений
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 4. Не ранее чем через 5 сек (внутренний таймаут) включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Нажать штатную кнопку "Да" в imitCan 3 раза
    */
    /*!
        Через 5 сек (внутренний таймаут) сигнала сирены отсутствуют
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        В течение 20 сек после шага 5 (внутренний таймаут) и позднее переход в охрану не произошел
    */
    if (!setAndCheckAltSrvBtnArmFail(ALT_SRV_BTN_TYPE_STD_BTN))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Постановка в охрану с помощью двери
void AutoTestsModesP2::C10419650_TestCase()
{
    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка постановки в охрану с помощью двери*
        ||Состояние стенда:
        ||Автомобиль в:                                | снято
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
    */
    if (!setProgramNeutralAuto(GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. 3 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 3 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
        3 длинных сигнала сирены 2 коротких сигнала сирены
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 7. Закрыть дверь
    */
    /*!
        Дверь закрыта
        Через 15 сек после выключения зажигания (внутренний таймаут) переход в охрану
    */
    if (!p_gen6->setAndCheckAltSrvBtnArm(ALT_SRV_BTN_TYPE_DOOR))
    {
        printf("FAIL Шаг 1-7\n");
    }
}

// Несоблюдение таймаутов при постановке дверью
void AutoTestsModesP2::C10419651_TestCase()
{
    if (settings_check(p_c10419622) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачной постановки в охрану с помощью двери*
        ||Состояние стенда:
        ||Автомобиль в:                                | снято
        ||Дверь:                                       | закрыта
        ||Багажник:                                    | закрыт
        ||Метка:                                       | выключена
        ||Брелок:                                      | включен
        ||Ручник:                                      | затянут
        ||Паркинг:                                     | включен
        ||Двигатель:                                   | заглушен
        ||Зажигание:                                   | выключено
        ||Обороты:                                     | выключены
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 3. 3 раза закрыть и открыть дверь
    */
    /*!
        Зафиксировано 3 закрывания и открывания двери
        Дверь осталась открытой
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Не ранее чем через 5 сек (внутренний таймаут) включить зажигание
    */
    /*!
        Зажигание включено
        3 длинных сигнала сирены 2 коротких сигнала сирены отсутствуют
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 7. Закрыть дверь
    */
    /*!
        Дверь закрыта
        В течение 15 сек после шага 6 (внутренний таймаут) и позднее переход в охрану не произошел
    */
    if (!setAndCheckAltSrvBtnArmFail(ALT_SRV_BTN_TYPE_DOOR))
    {
        printf("FAIL Шаг 1-7\n");
    }
}

// Переход в тревогу по двери раньше чем в охрану с нарушенным периметром
void AutoTestsModesP2::C10485319_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10485319) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что переход в тревогу происходит раньше чем переход в охрану с нарушенным периметром*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | затянут
        ||Паркинг:                                             | включен
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Авторизация по Метке:                                | вкл
        ||Авторизация по Брелоку:                              | откл
        ||Требовать авторизацию при снятии с охраны:           | брелок StarLine
        ||Ожидание авторизации, шаг 1:                         | 15 сек
        ||Ожидание авторизации, шаг 2:                         | 0 сек
        ||Ожидание авторизации, шаг 3:                         | 0 сек
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 25
        ||Постановка после закрытия двери или багажника, сек:  | 25
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Через 15 сек (Ожидание авторизации, шаг 1) переход в тревогу
        Через 25 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром не произошел
        Тревога продолжается
    */
    if (!setWaitingAuthAndCheckHandsFreeTimings(ZONE_DOOR, ALERT_CHECK_ON))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Переход в тревогу по багажнику раньше чем в охрану с нарушенным периметром
void AutoTestsModesP2::C10485320_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10485319) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что переход в тревогу происходит раньше чем переход в охрану с нарушенным периметром*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | затянут
        ||Паркинг:                                             | включен
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Авторизация по Метке:                                | вкл
        ||Авторизация по Брелоку:                              | откл
        ||Требовать авторизацию при снятии с охраны:           | брелок StarLine
        ||Ожидание авторизации, шаг 1:                         | 15 сек
        ||Ожидание авторизации, шаг 2:                         | 0 сек
        ||Ожидание авторизации, шаг 3:                         | 0 сек
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 25
        ||Постановка после закрытия двери или багажника, сек:  | 25
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Ожидание авторизации, шаг 1) переход в тревогу
        Через 25 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром не произошел
        Тревога продолжается
    */
    if (!setWaitingAuthAndCheckHandsFreeTimings(ZONE_TRUNK, ALERT_CHECK_ON))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Переход в охрану с нарушенным периметром по двери раньше чем в тревогу
void AutoTestsModesP2::C10485321_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10485321) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что переход в охрану с нарушенным периметром происходит раньше чем переход в тревогу*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | затянут
        ||Паркинг:                                             | включен
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Авторизация по Метке:                                | вкл
        ||Авторизация по Брелоку:                              | откл
        ||Требовать авторизацию при снятии с охраны:           | брелок StarLine
        ||Ожидание авторизации, шаг 1:                         | 20 сек
        ||Ожидание авторизации, шаг 2:                         | 0 сек
        ||Ожидание авторизации, шаг 3:                         | 0 сек
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 10
        ||Постановка после закрытия двери или багажника, сек:  | 10
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Через 10 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром
        Через 20 сек (Ожидание авторизации, шаг 1) переход в тревогу не произошел
    */
    if (!setWaitingAuthAndCheckHandsFreeTimings(ZONE_DOOR, ALERT_CHECK_NOT_ON))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Переход в охрану с нарушенным периметром по багажнику раньше чем в тревогу
void AutoTestsModesP2::C10485322_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE        // Помимо BLE модуля (для метки) должен быть любой модуль управления охраной без метки
        || (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
            && (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE))
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10485321) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что переход в охрану с нарушенным периметром происходит раньше чем переход в тревогу*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | затянут
        ||Паркинг:                                             | включен
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Авторизация по Метке:                                | вкл
        ||Авторизация по Брелоку:                              | откл
        ||Требовать авторизацию при снятии с охраны:           | брелок StarLine
        ||Ожидание авторизации, шаг 1:                         | 20 сек
        ||Ожидание авторизации, шаг 2:                         | 0 сек
        ||Ожидание авторизации, шаг 3:                         | 0 сек
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 10
        ||Постановка после закрытия двери или багажника, сек:  | 10
    */

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход из охраны в ожидание авторизации
    */

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 10 сек (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром
        Через 20 сек (Ожидание авторизации, шаг 1) переход в тревогу не произошел
    */
    if (!setWaitingAuthAndCheckHandsFreeTimings(ZONE_TRUNK, ALERT_CHECK_NOT_ON))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Включение настройки по BLE и выключение кнопкой без зажигания
void AutoTestsModesP2::C10489015_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799852) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения настройки по BLE кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
        ||Задан телефон:        | М1
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание отключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не отключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана отключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не отключена\n");
        return;
    }

    /*!
        Шаг 1. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        ЦБ перешел в режим настройки по BLE
        Сервисный светодиод начал постоянно моргать
    */
    if (!setAndCheckBleSettingsMode(ON, BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN_NO_IGN))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 9 раз сервисную кнопку
    */
    /*!
        Сервисный светодиод перестал постоянно моргать
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 4. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Режим настройки по BLE отключен
    */
    if (!setAndCheckBleSettingsMode(OFF, BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN_NO_IGN))
    {
        printf("FAIL Шаг 3-4\n");
    }
}

// Включение настройки по BLE и выключение по СМС
void AutoTestsModesP2::C10489016_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        || (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2799852) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения настройки по BLE по СМС*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
        ||Задан телефон:        | М1
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Начальные условия. Зажигание отключено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Зажигание не отключено\n");
        return;
    }

    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана отключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не отключена\n");
        return;
    }

    /*!
        Шаг 1. Отправить с М1 на ЦБ СМС: "НАСТРОЙКА+"
    */
    /*!
        ЦБ перешел в режим настройки по BLE
        Сервисный светодиод начал постоянно моргать
        ЦБ отправил на М1 СМС: "Режим настройки по BLE включен Охрана откл."
    */
    if (!setAndCheckBleSettingsMode(ON, BLE_SETTINGS_MODE_EN_TYPE_SMS))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС: "НАСТРОЙКА-"
    */
    /*!
        Сервисный светодиод перестал постоянно моргать
        Режим настройки по BLE отключен
        ЦБ отправил на М1 СМС: "Режим настройки по BLE отключен Охрана откл."
    */
    if (!setAndCheckBleSettingsMode(OFF, BLE_SETTINGS_MODE_EN_TYPE_SMS))
    {
        printf("FAIL Шаг 2\n");
    }
}

// 1.5.Вход через мобильное приложение
void AutoTestsModesP2::C15185_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424875) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана выключена
    */
    if (p_gen6->setAndCheckSecure(OFF,
                                  KEYRING,
                                  DIAG_GUARD_STATE_DISARM))
    {
        printf("PASS Начальные условия. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не выключена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить вход в сервисный режим через мобильное приложение
    */
    /*!
        Сервисный режим включен
        СМС-оповещение
    */
    p_gen6->setServiceModeMobile(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Шаг 1. Сервисный режим не включен\n");
        return;
    }

    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        if (p_gen6->getSim900()->waitCyrillicSms(Sim900::combineStr("%s\n%s\n%s %s",
                                                                    SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_GUARD_SERVICE,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_CMD_SRC,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_SRC_MOBILE).c_str()) == SIM900ACT_TRUESMS)
        {
            printf("PASS Шаг 1. СМС-оповещение получено\n");
        }
        else
        {
            printf("FAIL Шаг 1. СМС-оповещение не получено или неверно\n");
        }
    }
}

// 1.29.Выход через мобильное приложение
void AutoTestsModesP2::C15209_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c2424875) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Сервисный режим включен
    */
    p_gen6->setServiceModeMobile(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Сервисный режим включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Сервисный режим не включен\n");
        return;
    }

    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        p_gen6->outputSms(); // Пропустить СМС включения сервисного режима чтобы не мешать след. шагу
    }

    /*!
        Шаг 1. Выполнить выход из сервисного режима через голосовое меню
    */
    /*!
        Сервисный режим выключен
        Охрана выключена
        СМС-оповещение
    */
    p_gen6->wait_s(TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S); // Чтобы не сразу выключать сервис после включения
    p_gen6->setServiceModeMobile(OFF);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Охрана выключена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Охрана не выключена\n");
        return;
    }

    if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        if (p_gen6->getSim900()->waitCyrillicSms(Sim900::combineStr("%s\n%s %s\n%s",
                                                                    SMS_MSG_STR::SMS_ANSW_STR_SERVICE_OFF,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_CMD_SRC,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_SRC_MOBILE,
                                                                    SMS_MSG_STR::SMS_ANSW_STR_GUARD_DISARM).c_str()) == SIM900ACT_TRUESMS)
        {
            printf("PASS Шаг 1. СМС-оповещение получено\n");
        }
        else
        {
            printf("FAIL Шаг 1. СМС-оповещение не получено или неверно\n");
        }
    }
}

// 2.5.Вход через мобильное приложение
void AutoTestsModesP2::C15215_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Охрана включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить вход в сервисный режим через мобильное приложение
    */
    /*!
        Переход в сервисный режим не произошел
        Охрана включена
    */
    p_gen6->setServiceModeMobile(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошел переход из режима \"В охране\"\n");
    }
}

// 2.5.Вход через мобильное приложение
void AutoTestsModesP2::C15221_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Тревога включена
    */
    if (p_gen6->setAndCheckSecure(ON,
                                  KEYRING,
                                  DIAG_GUARD_STATE_ARM))
    {
        printf("PASS Начальные условия. Охрана включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Охрана не включена\n");
        return;
    }

    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Начальные условия. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Начальные условия. Дверь не открыта\n");
        return;
    }

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Начальные условия. Тревога включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Тревога не включена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить вход в сервисный режим через мобильное приложение
    */
    /*!
        Переход в сервисный режим не произошел
        Тревога включена
    */
    p_gen6->setServiceModeMobile(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ALERT_MAIN,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Тревога включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошел переход из режима \"Тревога\"\n");
    }
}

// 4.5.Вход через мобильное приложение
void AutoTestsModesP2::C15227_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Антиограбление включено
    */
    p_gen6->onAntiHijacking(MOBILE);

    if (p_gen6->waitAntiHijacking(AHJ_STATUS_CMD, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("PASS Начальные условия. Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Начальные условия. Антиограбление не включено\n");
        return;
    }

    /*!
        Шаг 1. Выполнить вход в сервисный режим через мобильное приложение
    */
    /*!
        Переход в сервисный режим не произошел
        Антиограбление включено
    */
    p_gen6->setServiceModeMobile(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_SERVICE,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Переход в сервисный режим не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошел переход в сервисный режим\n");
        return;
    }

    if (!p_gen6->waitAntiHijacking(AHJ_STATUS_OFF, TIME_DELAY::MAX_AHJ_EN_TIME_S))
    {
        printf("PASS Шаг 1. Антиограбление включено\n");
    }
    else
    {
        printf("FAIL Шаг 1. Антиограбление отключилось\n");
    }
}

// 5.5.Вход через мобильное приложение
void AutoTestsModesP2::C15233_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        Регистрация включена
    */
    p_gen6->registrationMode(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_REG,
                               ON,
                               TIME_DELAY::MAX_WIRE_STATUS_EN_TIME_S))
    {
        printf("PASS Начальные условия. Регистрация включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Регистрация не включена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить вход в сервисный режим через мобильное приложение
    */
    /*!
        Переход в сервисный режим не произошел
        Регистрация включена
    */
    p_gen6->setServiceModeMobile(ON);

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_REG,
                                OFF,
                                TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 1. Регистрация включена\n");
    }
    else
    {
        printf("FAIL Шаг 1. Произошел переход из режима \"Регистрация\"\n");
    }
}

// Постановка в охрану сервисной кнопкой без включения зажигания
void AutoTestsModesP2::C10634813_TestCase()
{
    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения охраны кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Нажать 3 раза сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        3-кратное подтверждение сервисным светодиодом входа в режим Охрана
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Через 20 секунд (внутренний таймаут) охрана включена
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_ARM_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_BTN,
                       DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Переход в меню программирования брелоком без зажигания
void AutoTestsModesP2::C10634814_TestCase()
{
    if (   p_gen6->getDeviceName()              == GEN6_X96V2   // Трансивер не проверяется на X96v2
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAndSetKeyringAndRelayVcc);


    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения программирования брелока кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Брелок:               | Включен
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Нажать 5 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        5-кратное подтверждение сервисным светодиодом входа в режим программирования брелоком
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Брелок перешел в меню программирования 
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_REMOTE_SETTINGS_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_BTN,
                       DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Перевод R6 в режим обновления прошивки без зажигания
void AutoTestsModesP2::C10634815_TestCase()
{
    if (   p_gen6->getDeviceName()             == GEN6_X96V2  // Трансивер не проверяется на X96v2
        || (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAndSetKeyringAndRelayVcc);


    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения обновления прошивки R6 кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Брелок:               | Включен
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Нажать 6 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        6-кратное подтверждение сервисным светодиодом входа в режим обновления прошивки R6
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_R6_FW_UPDATE_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_BTN,
                       DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Переход в режим регистрации без зажигания
void AutoTestsModesP2::C10634816_TestCase()
{
    if (settings_check(p_no_auth) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения регистрации кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Брелок:               | Включен
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Нажать 7 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        7-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Переход в Режим регистрации устройств
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_REG_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_BTN,
                       DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Постановка в охрану сервисной кнопкой после включения запрета поездки
void AutoTestsModesP2::C10634817_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10634817) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения охраны*
        ||Состояние стенда:
        ||Зажигание:                          | включено
        ||Обороты:                            | выключены
        ||Автомобиль в:                       | Снято
        ||Зажигание:                          | Включено
        ||Запрет поездки:                     | Отключен
        ||Метка:                              | Включена
        ||Настройки:                         
        ||Подключена:                         | сервисная кнопка с светодиодом
        ||Снятие запрета поездки:             | метка
        ||Условие активации запрета поездки:  | при выключении зажигания
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Переход в запрет поездки
        Зажигание отключено
    */
    if (!setImmoByIgn())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 3 раза сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        3-кратное подтверждение сервисным светодиодом
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
    */

    /*!
        Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Через 20 секунд (внутренний таймаут) охрана включена
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_ARM_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_IGN,
                       DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 3-5\n");
    }
}

// Переход в меню программирования брелоком после включения запрета поездки
void AutoTestsModesP2::C10634818_TestCase()
{
    if (   p_gen6->getDeviceName()              == GEN6_X96V2   // Трансивер не проверяется на X96v2
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::resetAndSetKeyringAndRelayVcc);


    if (settings_check(p_c10634817) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения программирования брелока*
        ||Состояние стенда:
        ||Зажигание:                          | включено
        ||Обороты:                            | выключены
        ||Автомобиль в:                       | Снято
        ||Зажигание:                          | Включено
        ||Запрет поездки:                     | Отключен
        ||Метка:                              | Включена
        ||Настройки:                         
        ||Подключена:                         | сервисная кнопка с светодиодом
        ||Снятие запрета поездки:             | метка
        ||Условие активации запрета поездки:  | при выключении зажигания
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Переход в запрет поездки
        Зажигание отключено
    */
    if (!setImmoByIgn())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 5 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        5-кратное подтверждение сервисным светодиодом
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Брелок перешел в меню программирования 
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_REMOTE_SETTINGS_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_IGN,
                       DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 3-4\n");
    }
}

// Перевод R6 в режим обновления прошивки после включения запрета поездки
void AutoTestsModesP2::C10634819_TestCase()
{
    if (   p_gen6->getDeviceName()             == GEN6_X96V2  // Трансивер не проверяется на X96v2
        || (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::resetAndSetKeyringAndRelayVcc);


    if (settings_check(p_c10634817) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения обновления прошивки R6*
        ||Состояние стенда:
        ||Состояние стенда:
        ||Зажигание:                          | включено
        ||Обороты:                            | выключены
        ||Автомобиль в:                       | Снято
        ||Зажигание:                          | Включено
        ||Запрет поездки:                     | Отключен
        ||Метка:                              | Включена
        ||Настройки:                         
        ||Подключена:                         | сервисная кнопка с светодиодом
        ||Снятие запрета поездки:             | метка
        ||Условие активации запрета поездки:  | при выключении зажигания
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Переход в запрет поездки
        Зажигание отключено
    */
    if (!setImmoByIgn())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 6 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        6-кратное подтверждение сервисным светодиодом
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_R6_FW_UPDATE_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_IGN,
                       DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 3-4\n");
    }
}

// Переход в режим регистрации после включения запрета поездки
void AutoTestsModesP2::C10634820_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter2(this, &AutoTestsModesP2::resetAuthAndImmo);
    SettingsResetter<AutoTestsModesP2> resetter1(this, &AutoTestsModesP2::setAndResetIgn);


    if (settings_check(p_c10634817) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения регистрации*
        ||Состояние стенда:
        ||Зажигание:                          | включено
        ||Обороты:                            | выключены
        ||Автомобиль в:                       | Снято
        ||Зажигание:                          | Включено
        ||Запрет поездки:                     | Отключен
        ||Метка:                              | Включена
        ||Настройки:                         
        ||Подключена:                         | сервисная кнопка с светодиодом
        ||Снятие запрета поездки:             | метка
        ||Условие активации запрета поездки:  | при выключении зажигания
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Переход в запрет поездки
        Зажигание отключено
    */
    if (!setImmoByIgn())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 7 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        7-кратное подтверждение сервисным светодиодом
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Переход в Режим регистрации устройств
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_REG_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_IGN,
                       DIAG_GUARD_STATE_REG))
    {
        printf("FAIL Шаг 3-4\n");
    }
}

// Переход в режим настройки по BLE после включения запрета поездки
void AutoTestsModesP2::C10634821_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10634817) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения настройки по BLE*
        ||Состояние стенда:
        ||Зажигание:                          | включено
        ||Обороты:                            | выключены
        ||Автомобиль в:                       | Снято
        ||Зажигание:                          | Включено
        ||Запрет поездки:                     | Отключен
        ||Метка:                              | Включена
        ||Настройки:                         
        ||Подключена:                         | сервисная кнопка с светодиодом
        ||Снятие запрета поездки:             | метка
        ||Условие активации запрета поездки:  | при выключении зажигания
    */

    /*!
        Шаг 1. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 2. Выключить зажигание
    */
    /*!
        Переход в запрет поездки
        Зажигание отключено
    */
    if (!setImmoByIgn())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        9-кратное подтверждение сервисным светодиодом
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Переход в Режим настройки по BLE
    */
    if (!setSrvBtnMenu(COUNT_STRUCT::BTN_MODE_BLE_CLICKS_COUNT,
                       SRV_BTN_MENU_ON_TYPE_IGN,
                       DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 3-4\n");
    }

    if (!checkBleSettingsModeIndication(ON))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_EEFLAG_SYSDATA,
                                 SLP_STATUSES_SIZES::DIAG_DATA_EEFLAG_SYSDATA_SIZE,
                                 DIAG_EEFLAG_SYSDATA::ID_FLAG_BLE_UPDATER,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 4. Переход в Режим настройки по BLE\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в Режим настройки по BLE не произошел\n");
    }
}

// СМС оповещение о АО по метке
void AutoTestsModesP2::C10634826_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE
        || (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c10634826)
        ||  settings_check(p_c10634826) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка СМС оповещения*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | закрыта
        ||Метка:                                                   | включена
        ||Брелок:                                                  | включен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (включено)
        ||Антиограбление при пропадании:                           | брелока (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Оповещение о вкл/выкл АО:                                | включено (М1)
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        На М1 отправлено СМС "Тревога! Антиограбление по потере блютуз-метки/брелока. Если блютуз-метка/брелок находятся в автомобиле, то необходимо заменить батарейку."
    */

    /*!
        Шаг 5. Включить метку
    */
    /*!
        Метка найдена
        СМС оповещение отсутствует
    */
    if (!setAhjAndCheckSms(AHJ_TYPE_TAG_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// СМС оповещение о АО по брелоку
void AutoTestsModesP2::C10634827_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE)  != GSM_MODULE
        || (p_gen6->getModules() & R868_MODULE) != R868_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (   !getAndSetAhjSettings(p_c10634826)
        ||  settings_check(p_c10634826) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка СМС оповещения*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | закрыта
        ||Метка:                                                   | включена
        ||Брелок:                                                  | включен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (включено)
        ||Антиограбление при пропадании:                           | брелока (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Оповещение о вкл/выкл АО:                                | включено (М1)
    */

    /*!
        Шаг 1. Открыть дверь
    */
    /*!
        Дверь открыта
    */

    /*!
        Шаг 2. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */

    /*!
        Шаг 3. Выключить брелок
    */
    /*!
        Брелок потерян
    */

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
        На М1 отправлено СМС "Тревога! Антиограбление по потере блютуз-метки/брелока. Если блютуз-метка/брелок находятся в автомобиле, то необходимо заменить батарейку."
    */

    /*!
        Шаг 5. Включить брелок
    */
    /*!
        Брелок найден
        СМС оповещение отсутствует
    */
    if (!setAhjAndCheckSms(AHJ_TYPE_REMOTE_OFF))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Зарегистрировать R6 1 раз
void AutoTestsModesP2::C10645333_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 4. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_ONLY, 1))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Зарегистрировать R6 2 раза
void AutoTestsModesP2::C10645334_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 6. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_ONLY, 2))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Зарегистрировать R6 3 раза
void AutoTestsModesP2::C10645335_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6 3тий раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 6. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_ONLY, 3))
    {
        printf("FAIL Шаг 1-7\n");
    }
}

// Зарегистрировать R6 4 раза
void AutoTestsModesP2::C10645336_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6 3тий раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6 4ый раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_ONLY, 4))
    {
        printf("FAIL Шаг 1-8\n");
    }
}

// Зарегистрировать R6 5 раз
void AutoTestsModesP2::C10645337_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6 3тий раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6 4ый раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 6. Зарегистрировать R6 5ый раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 8. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 9. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_ONLY, 5))
    {
        printf("FAIL Шаг 1-9\n");
    }
}

// Зарегистрировать R6eco 1 раз
void AutoTestsModesP2::C10645338_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 4. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY, 1))
    {
        printf("FAIL Шаг 1-5\n");
    }
}

// Зарегистрировать R6eco 2 раза
void AutoTestsModesP2::C10645339_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 6. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY, 2))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Зарегистрировать R6eco 3 раза
void AutoTestsModesP2::C10645340_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6eco 3тий раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 6. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY, 3))
    {
        printf("FAIL Шаг 1-7\n");
    }
}

// Зарегистрировать R6eco 4 раза
void AutoTestsModesP2::C10645341_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6eco 3тий раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6eco 4ый раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY, 4))
    {
        printf("FAIL Шаг 1-8\n");
    }
}

// Зарегистрировать R6eco 5 раз
void AutoTestsModesP2::C10645342_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6eco 3тий раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6eco 4ый раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 6. Зарегистрировать R6eco 5ый раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 7. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 8. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 9. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_ONLY, 5))
    {
        printf("FAIL Шаг 1-9\n");
    }
}

// Зарегистрировать R6 и R6eco 1 раз
void AutoTestsModesP2::C10645343_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 6. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO, 1))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Зарегистрировать R6 и R6eco 2 раза
void AutoTestsModesP2::C10645344_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO, 2))
    {
        printf("FAIL Шаг 1-8\n");
    }
}

// Зарегистрировать R6 и R6eco 3 раза
void AutoTestsModesP2::C10645345_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 6. Зарегистрировать R6 3тий раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 7. Зарегистрировать R6eco 3тий раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 8. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 9. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 10. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6_THEN_R6ECO, 3))
    {
        printf("FAIL Шаг 1-10\n");
    }
}

// Зарегистрировать R6eco и R6 1 раз
void AutoTestsModesP2::C10645346_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 6. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6, 1))
    {
        printf("FAIL Шаг 1-6\n");
    }
}

// Зарегистрировать R6eco и R6 2 раза
void AutoTestsModesP2::C10645347_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 7. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 8. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6, 2))
    {
        printf("FAIL Шаг 1-8\n");
    }
}

// Зарегистрировать R6eco и R6 3 раза
void AutoTestsModesP2::C10645348_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10645338) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации кодовых реле*
        ||Состояние стенда:
        ||Состояние охраны ЦБ:                 | снято
        ||Зажигание:                           | отключено
        ||R6:                                  | выключен
        ||R6:                                  | не зарегистрирован
        ||R6eco:                               | выключен
        ||R6eco:                               | не зарегистрирован
        ||Питание ЦБ:                          | подключено (12В)
        ||Настройки:
        ||Настроен выход R6:                   | Блокировка двигателя N1
        ||Настроен выход R6eco:                | Блокировка двигателя N1
        ||Блокировка двигателя N1:             | НЗ
        ||Задержка блокировки:                 | 0с
        ||Блокировка при начале движения:      | отключена
        **Примечание:** *Для регистрации R6 (R6eco) требуется: Отключить питание от микрореле, Соединить между собой провода OUTPUT и INPUT (бело-черный и желто-красный),
                         Подать питание на микрореле, Через 10 секунд успешная регистрация будет подтверждена 2 сигналами светодиода на сервисной кнопке,
                         Разомкнуть провода OUTPUT и INPUT (бело-черный и желто-красный)
        **Примечание:** *Для входа в режим регистрации устройств требуется: Нажать сервисную кнопку 7 раз, Включить зажигание, 
                         Последуют 7 сигналов светодиода на сервисной кнопке и 7 сигналов сирены, Вход в режим регистрации будет подтвержден 
                         2 сигналами светодиода на сервисной кнопке и 2 короткими сигналами сирены
    */
    if (!setDisarmAndResetBleRelayVcc())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Перевести ЦБ в режим регистрации (нажать 7 раз сервисную кнопку и включить зажигание)
    */
    /*!
        Зажигание включено
        Переход в режим регистрации устройств
    */

    /*!
        Шаг 2. Зарегистрировать R6eco 1 раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 3. Зарегистрировать R6 1 раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 4. Зарегистрировать R6eco 2ой раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 5. Зарегистрировать R6 2ой раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 6. Зарегистрировать R6eco 3тий раз (соединить провода бело-черный и желто-красный и включить питание)
    */
    /*!
        R6eco зарегистрирован
    */

    /*!
        Шаг 7. Зарегистрировать R6 3тий раз (соединить провода OUTPUT и INPUT и включить питание)
    */
    /*!
        R6 зарегистрирован
    */

    /*!
        Шаг 8. Выключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в снято
    */

    /*!
        Шаг 9. Включить охрану
    */
    /*!
        Переход в охрану
    */

    /*!
        Шаг 10. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        R6 включило блокировку
        R6eco включило блокировку
    */
    if (!registerBleRelayFewTimesAndCheckBlock(RELAY_REGISTRATION_SEQUENCE_R6ECO_THEN_R6, 3))
    {
        printf("FAIL Шаг 1-10\n");
    }
}

// Выключение охраны аналоговым Slave без метки
void AutoTestsModesP2::C10832739_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10832739) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что Slave не выключает охрану без метки*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | Охрана
        ||Дверь:                                                              | закрыта
        ||Багажник:                                                           | закрыт
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Ручник:                                                             | затянут
        ||Паркинг:                                                            | включен
        ||Двигатель:                                                          | заглушен
        ||Зажигание:                                                          | выключено
        ||Обороты:                                                            | выключены
        ||Настройки:
        ||Управление штатной системой охраны (Slave при подключении к CAN):   | включено
        ||Управление штатной системой охраны (Аналоговый Slave):              | включено
        ||Настроен вход:                                                      | ЦЗ открыть (для аналогового Slave)
        ||Настроен вход:                                                      | ЦЗ закрыть (для аналогового Slave)
        ||Настроен вход:                                                      | Объединенный вход поворотников (для аналогового Slave)
        ||Настроен CAN-автомобиль:                                            | 9999-Batmobile
        ||Функции управления CAN: Постановка штатной системой охраны:         | Вкл
        ||Функции управления CAN: Снятие штатной системой охраны:             | Вкл
        ||Запрет снятия с охраны без метки: Штатной системой охраны (Slave):  | Вкл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Подать на вход ЦЗ открыть импульс длительностью 0,2-1,8 сек (внутренний таймаут)
    */
    /*!
        Нет изменений
    */

    /*!
        Шаг 2. Не позднее чем через 5 сек (внутренний таймаут) подать на вход поворотников импульс длительностью 0,2-1,8 сек (внутренний таймаут)
    */
    /*!
        Нет изменений
        Переход из охраны в снято не произошел
    */
    if (!setTagAndSlaveDisarmAndCheckDisarm(TAG_OFF,
                                            SLAVE_TYPE_ANALOG,
                                            DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Выключение охраны Slave по CAN без метки
void AutoTestsModesP2::C10832740_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10832739) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что Slave не выключает охрану без метки*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | Охрана
        ||Дверь:                                                              | закрыта
        ||Багажник:                                                           | закрыт
        ||Метка:                                                              | выключена
        ||Брелок:                                                             | включен
        ||Ручник:                                                             | затянут
        ||Паркинг:                                                            | включен
        ||Двигатель:                                                          | заглушен
        ||Зажигание:                                                          | выключено
        ||Обороты:                                                            | выключены
        ||Настройки:
        ||Управление штатной системой охраны (Slave при подключении к CAN):   | включено
        ||Управление штатной системой охраны (Аналоговый Slave):              | включено
        ||Настроен вход:                                                      | ЦЗ открыть (для аналогового Slave)
        ||Настроен вход:                                                      | ЦЗ закрыть (для аналогового Slave)
        ||Настроен вход:                                                      | Объединенный вход поворотников (для аналогового Slave)
        ||Настроен CAN-автомобиль:                                            | 9999-Batmobile
        ||Функции управления CAN: Постановка штатной системой охраны:         | Вкл
        ||Функции управления CAN: Снятие штатной системой охраны:             | Вкл
        ||Запрет снятия с охраны без метки: Штатной системой охраны (Slave):  | Вкл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Подать с помощью imitcan команду на выключение охраны (Slave при подключении к CAN)
    */
    /*!
        Нет изменений
        Переход из охраны в снято не произошел
    */
    if (!setTagAndSlaveDisarmAndCheckDisarm(TAG_OFF,
                                            SLAVE_TYPE_CAN,
                                            DIAG_GUARD_STATE_ARM))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Выключение охраны аналоговым Slave с меткой
void AutoTestsModesP2::C10832741_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10832739) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что Slave выключает охрану с меткой*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | Охрана
        ||Дверь:                                                              | закрыта
        ||Багажник:                                                           | закрыт
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Ручник:                                                             | затянут
        ||Паркинг:                                                            | включен
        ||Двигатель:                                                          | заглушен
        ||Зажигание:                                                          | выключено
        ||Обороты:                                                            | выключены
        ||Настройки:
        ||Управление штатной системой охраны (Slave при подключении к CAN):   | включено
        ||Управление штатной системой охраны (Аналоговый Slave):              | включено
        ||Настроен вход:                                                      | ЦЗ открыть (для аналогового Slave)
        ||Настроен вход:                                                      | ЦЗ закрыть (для аналогового Slave)
        ||Настроен вход:                                                      | Объединенный вход поворотников (для аналогового Slave)
        ||Настроен CAN-автомобиль:                                            | 9999-Batmobile
        ||Функции управления CAN: Постановка штатной системой охраны:         | Вкл
        ||Функции управления CAN: Снятие штатной системой охраны:             | Вкл
        ||Запрет снятия с охраны без метки: Штатной системой охраны (Slave):  | Вкл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Подать на вход ЦЗ открыть импульс длительностью 0,2-1,8 сек (внутренний таймаут)
    */
    /*!
        Нет изменений
    */

    /*!
        Шаг 2. Не позднее чем через 5 сек (внутренний таймаут) подать на вход поворотников импульс длительностью 0,2-1,8 сек (внутренний таймаут)
    */
    /*!
        Переход из охраны в снято
    */
    if (!setTagAndSlaveDisarmAndCheckDisarm(TAG_ON,
                                            SLAVE_TYPE_ANALOG,
                                            DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1-2\n");
    }
}

// Выключение охраны Slave по CAN с меткой
void AutoTestsModesP2::C10832742_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10832739) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что Slave выключает охрану с меткой*
        ||Состояние стенда:
        ||Автомобиль в:                                                       | Охрана
        ||Дверь:                                                              | закрыта
        ||Багажник:                                                           | закрыт
        ||Метка:                                                              | включена
        ||Брелок:                                                             | включен
        ||Ручник:                                                             | затянут
        ||Паркинг:                                                            | включен
        ||Двигатель:                                                          | заглушен
        ||Зажигание:                                                          | выключено
        ||Обороты:                                                            | выключены
        ||Настройки:
        ||Управление штатной системой охраны (Slave при подключении к CAN):   | включено
        ||Управление штатной системой охраны (Аналоговый Slave):              | включено
        ||Настроен вход:                                                      | ЦЗ открыть (для аналогового Slave)
        ||Настроен вход:                                                      | ЦЗ закрыть (для аналогового Slave)
        ||Настроен вход:                                                      | Объединенный вход поворотников (для аналогового Slave)
        ||Настроен CAN-автомобиль:                                            | 9999-Batmobile
        ||Функции управления CAN: Постановка штатной системой охраны:         | Вкл
        ||Функции управления CAN: Снятие штатной системой охраны:             | Вкл
        ||Запрет снятия с охраны без метки: Штатной системой охраны (Slave):  | Вкл
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Подать с помощью imitcan команду на выключение охраны (Slave при подключении к CAN)
    */
    /*!
        Переход из охраны в снято
    */
    if (!setTagAndSlaveDisarmAndCheckDisarm(TAG_ON,
                                            SLAVE_TYPE_CAN,
                                            DIAG_GUARD_STATE_DISARM))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Таймер открытия багажника меньше таймера авторизации
void AutoTestsModesP2::C10861710_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE // Нужен хотя бы 1 модуль для авторизации
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10861710) == 0)
    {
        return;
    }

    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("Настройка \"Время поиска метки или брелока при открытом багажнике\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отсутствии метки и брелока тревога включается по истечению наименьшего из двух настроенных таймаутов (решили не исправлять:
                       Запускается таймер только на время указанное в настройке "Разрешить поиск метки и брелока при открытом багажнике", даже если значение
                       настройки "Ожидание авторизации, шаг 1: время поиска метки или брелока" меньше)*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | Охрана
        ||Дверь:                                                                | закрыта
        ||Багажник:                                                             | закрыт
        ||Метка:                                                                | отключена
        ||Брелок:                                                               | отключен
        ||Ручник:                                                               | затянут
        ||Паркинг:                                                              | включен
        ||Двигатель:                                                            | заглушен
        ||Зажигание:                                                            | выключено
        ||Обороты:                                                              | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                 | вкл
        ||Авторизация по Брелоку:                                               | вкл
        ||Требовать авторизацию при снятии с охраны:                            | брелок StarLine
        ||Требовать авторизацию при снятии с охраны:                            | метка
        ||Ожидание авторизации, шаг 1:                                          | 30 сек
        ||Ожидание авторизации, шаг 2:                                          | 0 сек
        ||Ожидание авторизации, шаг 3:                                          | 0 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:  | вкл (разрешено)
        ||Время поиска метки или брелока при открытом багажнике:                | 15 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setTagAndRemoteVcc(TAG_OFF, REMOTE_OFF);

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Время поиска метки или брелока при открытом багажнике) включена тревога
    */
    if (!setTrunkAndCheckAlarm(ALERT_ON, m_trunk_tag_rem_wait_time_s))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Таймер авторизации меньше таймера открытия багажника
void AutoTestsModesP2::C10861711_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE // Нужен хотя бы 1 модуль для авторизации
        && (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10861711) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (m_trunk_tag_rem_wait_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("Настройка \"Время поиска метки или брелока при открытом багажнике\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что при отсутствии метки и брелока тревога включается по истечению наименьшего из двух настроенных таймаутов (решили не исправлять:
                       Запускается таймер только на время указанное в настройке "Разрешить поиск метки и брелока при открытом багажнике", даже если значение
                       настройки "Ожидание авторизации, шаг 1: время поиска метки или брелока" меньше)*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | Охрана
        ||Дверь:                                                                | закрыта
        ||Багажник:                                                             | закрыт
        ||Метка:                                                                | отключена
        ||Брелок:                                                               | отключен
        ||Ручник:                                                               | затянут
        ||Паркинг:                                                              | включен
        ||Двигатель:                                                            | заглушен
        ||Зажигание:                                                            | выключено
        ||Обороты:                                                              | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                 | вкл
        ||Авторизация по Брелоку:                                               | вкл
        ||Требовать авторизацию при снятии с охраны:                            | брелок StarLine
        ||Требовать авторизацию при снятии с охраны:                            | метка
        ||Ожидание авторизации, шаг 1:                                          | 15 сек
        ||Ожидание авторизации, шаг 2:                                          | 0 сек
        ||Ожидание авторизации, шаг 3:                                          | 0 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:  | вкл (разрешено)
        ||Время поиска метки или брелока при открытом багажнике:                | 30 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setTagAndRemoteVcc(TAG_OFF, REMOTE_OFF);

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек (Ожидание авторизации, шаг 1) тревога не включилась
        Через 30 сек (Время поиска метки или брелока при открытом багажнике) включена тревога
    */
    if (!setTrunkAndCheckAlarm(ALERT_ON, m_trunk_tag_rem_wait_time_s))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Таймер авторизации продолжает работать после сброса таймера багажника меткой
void AutoTestsModesP2::C10861712_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        || (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10861712) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (m_auth_step_one_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("Настройка \"Ожидание авторизации, шаг 1\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что если стоит ожидание авторизации по брелку, а была предъявлена метка, то таймер ожидания метки/брелка сбрасывается, а
                       ожидание авторизации продолжает работать (решили не исправлять: После перехода в "Охрану с открытым багажником" не запускается ожидание
                       авторизации. Не критично. Оставляем как есть)*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | Охрана
        ||Дверь:                                                                | закрыта
        ||Багажник:                                                             | закрыт
        ||Метка:                                                                | включена
        ||Брелок:                                                               | отключен
        ||Ручник:                                                               | затянут
        ||Паркинг:                                                              | включен
        ||Двигатель:                                                            | заглушен
        ||Зажигание:                                                            | выключено
        ||Обороты:                                                              | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                 | откл
        ||Авторизация по Брелоку:                                               | вкл
        ||Требовать авторизацию при снятии с охраны:                            | меткой
        ||Ожидание авторизации, шаг 1:                                          | 30 сек
        ||Ожидание авторизации, шаг 2:                                          | 0 сек
        ||Ожидание авторизации, шаг 3:                                          | 0 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:  | вкл (разрешено)
        ||Время поиска метки или брелока при открытом багажнике:                | 15 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setTagAndRemoteVcc(TAG_ON, REMOTE_OFF);

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Охрана с откр. багажником включена
        Через 15 сек (Время поиска метки или брелока при открытом багажнике) тревога не включилась
        Через 30 сек (Ожидание авторизации, шаг 1) тревога не включилась
    */
    if (!setTrunkAndCheckAlarm(ALERT_OFF, m_auth_step_one_time_s + TIME_DELAY::MAX_WIRE_EN_DELAY_S))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Таймер авторизации продолжает работать после сброса таймера багажника брелоком
void AutoTestsModesP2::C10861713_TestCase()
{
    if (   (p_gen6->getModules() & R868_MODULE) != R868_MODULE
        || (p_gen6->getModules() & BLE_MODULE)  != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10861713) == 0)
    {
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (m_auth_step_one_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("Настройка \"Ожидание авторизации, шаг 1\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что если стоит ожидание авторизации по брелку, а была предъявлена метка, то таймер ожидания метки/брелка сбрасывается, а
                       ожидание авторизации продолжает работать (решили не исправлять: После перехода в "Охрану с открытым багажником" не запускается ожидание
                       авторизации. Не критично. Оставляем как есть)*
        ||Состояние стенда:
        ||Автомобиль в:                                                         | Охрана
        ||Дверь:                                                                | закрыта
        ||Багажник:                                                             | закрыт
        ||Метка:                                                                | отключена
        ||Брелок:                                                               | включен
        ||Ручник:                                                               | затянут
        ||Паркинг:                                                              | включен
        ||Двигатель:                                                            | заглушен
        ||Зажигание:                                                            | выключено
        ||Обороты:                                                              | выключены
        ||Настройки:
        ||Авторизация по Метке:                                                 | вкл
        ||Авторизация по Брелоку:                                               | откл
        ||Требовать авторизацию при снятии с охраны:                            | брелоком
        ||Ожидание авторизации, шаг 1:                                          | 30 сек
        ||Ожидание авторизации, шаг 2:                                          | 0 сек
        ||Ожидание авторизации, шаг 3:                                          | 0 сек
        ||Разрешить в охране открытие багажника при наличии метки или брелока:  | вкл (разрешено)
        ||Время поиска метки или брелока при открытом багажнике:                | 15 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setTagAndRemoteVcc(TAG_OFF, REMOTE_ON);

    /*!
        Шаг 1. Открыть багажник
    */
    /*!
        Багажник открыт
        Охрана с откр. багажником включена
        Через 15 сек (Время поиска метки или брелока при открытом багажнике) тревога не включилась
        Через 30 сек (Ожидание авторизации, шаг 1) тревога не включилась
    */
    if (!setTrunkAndCheckAlarm(ALERT_OFF, m_auth_step_one_time_s + TIME_DELAY::MAX_WIRE_EN_DELAY_S))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Сработал ДД с отключенным зажиганием в охране (Минимальный импульс)
void AutoTestsModesP2::C10854614_TestCase()
{
    if (settings_check(p_c10854614) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка мин. импульса без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | включена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Включена тревога
        На выход кнопки старт-стоп подан импульс на 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 1\n");
    }

    p_gen6->checkAlarm(ON);
}

// Переход в тревогу с включенным зажиганием из охраны (Максимальный импульс)
void AutoTestsModesP2::C10854615_TestCase()
{
    if (settings_check(p_c10854615) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка макс. импульса без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | включена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 60 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Сработал ДД
        Включена тревога
        На выход кнопки старт-стоп подан импульс на 60с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 1\n");
    }

    // Не проверяем тревогу после импульсов, т.к. она уже завершилась
}

// Минимальные 3 импульса
void AutoTestsModesP2::C10854616_TestCase()
{
    if (settings_check(p_c10854614) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка мин. 3х импульсов с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | включена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    p_gen6->checkAlarm(ON);
}

// Максимальные 3 импульса
void AutoTestsModesP2::C10854617_TestCase()
{
    if (settings_check(p_c10854615) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка макс. 3х импульсов с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | включена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 60 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 60с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    p_gen6->checkAlarm(ON);
}

// Переключение АКПП из паркинга в авторизации
void AutoTestsModesP2::C10854594_TestCase()
{
    if (!checkModulesForWaitingAuthTagRem())
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854594) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульсов в авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Метка
        ||Требовать авторизацию при снятии:                     | Брелоком
        ||Ожидание авторизации: Шаг 1: время поиска метки:      | 15 сек
        ||Ожидание авторизации: Шаг 2:                          | 0 сек
        ||Ожидание авторизации: Шаг 3:                          | 0 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setAuthDeviceVcc(OFF);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в авторизацию владельца
    */
    if (!setAndCheckWaitingAuthTagRem())
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг выключен
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 3\n");
    }
}

// Сработал ДД с отключенным зажиганием в авторизации
void AutoTestsModesP2::C10854588_TestCase()
{
    if (!checkModulesForWaitingAuthTagRem())
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854594) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульсов в авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Метка
        ||Требовать авторизацию при снятии:                     | Брелоком
        ||Ожидание авторизации: Шаг 1: время поиска метки:      | 15 сек
        ||Ожидание авторизации: Шаг 2:                          | 0 сек
        ||Ожидание авторизации: Шаг 3:                          | 0 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setAuthDeviceVcc(OFF);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в авторизацию владельца
    */
    if (!setAndCheckWaitingAuthTagRem())
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2.  Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп подан 1 импульс длительностью 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД с включенным зажиганием в авторизации
void AutoTestsModesP2::C10854595_TestCase()
{
    if (!checkModulesForWaitingAuthTagRem())
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854594) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульсов в авторизации*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Метка
        ||Требовать авторизацию при снятии:                     | Брелоком
        ||Ожидание авторизации: Шаг 1: время поиска метки:      | 15 сек
        ||Ожидание авторизации: Шаг 2:                          | 0 сек
        ||Ожидание авторизации: Шаг 3:                          | 0 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setAuthDeviceVcc(OFF);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в авторизацию владельца
    */
    if (!setAndCheckWaitingAuthTagRem())
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3.  Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 3\n");
    }
}

// Переход в тревогу с отключенным зажиганием в авторизации
void AutoTestsModesP2::C10854589_TestCase()
{
    if (!checkModulesForWaitingAuthTagRem())
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854594) == 0)
    {
        return;
    }

    if (m_auth_step_one_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Ожидание авторизации, Шаг 1: время поиска метки или брелока\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка что импульсов в авторизации нет, если происходит переход в тревогу без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Метка
        ||Требовать авторизацию при снятии:                     | Брелоком
        ||Ожидание авторизации: Шаг 1: время поиска метки:      | 15 сек
        ||Ожидание авторизации: Шаг 2:                          | 0 сек
        ||Ожидание авторизации: Шаг 3:                          | 0 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setAuthDeviceVcc(OFF);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в авторизацию владельца
    */
    if (!setAndCheckWaitingAuthTagRem())
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
        Через 15 сек (Ожидание авторизации: Шаг 1: время поиска метки) переход в тревогу
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_DOOR_OPEN,
                                                  START_BTN_CHECK_PULSES_NULL,
                                                  m_auth_step_one_time_s + TimeoutCalculator::calcToutError(m_auth_step_one_time_s)))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    p_gen6->checkAlarm(ON);
}

// Переход в тревогу с включенным зажиганием в авторизации
void AutoTestsModesP2::C10854590_TestCase()
{
    if (!checkModulesForWaitingAuthTagRem())
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854594) == 0)
    {
        return;
    }

    if (m_auth_step_one_time_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Ожидание авторизации, Шаг 1: время поиска метки или брелока\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в авторизации, если происходит переход в тревогу c зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Метка
        ||Требовать авторизацию при снятии:                     | Брелоком
        ||Ожидание авторизации: Шаг 1: время поиска метки:      | 15 сек
        ||Ожидание авторизации: Шаг 2:                          | 0 сек
        ||Ожидание авторизации: Шаг 3:                          | 0 сек
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    setAuthDeviceVcc(OFF);

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в авторизацию владельца
    */
    if (!setAndCheckWaitingAuthTagRem())
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
        Через 15 сек (Ожидание авторизации: Шаг 1: время поиска метки) переход в тревогу
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL,
                                                  m_auth_step_one_time_s - TimeoutCalculator::calcToutError(m_auth_step_one_time_s)))
    {
        printf("FAIL Шаг 2. Получены импульсы кнопки Старт-Стоп до включения тревоги\n");
        return;
    }

    if (!checkStartStopBtnBlock(START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2. Импульсы Старт-Стоп не получены после включения тревоги\n");
        return;
    }

    p_gen6->checkAlarm(ON);
}

// Переключение АКПП из паркинга в запрете поездки
void AutoTestsModesP2::C10854596_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854596) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в запрете поездки, если происходит выключение паркинга*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Метка
        ||Условие активации запрета поездки:                    | при снятии с охраны
    */
    if (!setProgramNeutralAuto(GUARD_STATE_ARM, TIME_DELAY::NULL_DELAY_S))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если в системе есть метка + брелок, то снятие охраны брелком, а ЗП по метке
    // Иначе ЗП по штатным кнопкам
    if (   (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в запрет поездки
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Переход в запрет поездки не произведен\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Выключить паркинг
    */
    /*!
        Паркинг выключен
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 3\n");
    }
}

// Сработал ДД с отключенным зажиганием в запрете поездки
void AutoTestsModesP2::C10854591_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854596) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия импульсов в запрете поездки, если происходит срабатывание ДД без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Метка
        ||Условие активации запрета поездки:                    | при снятии с охраны
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если в системе есть метка + брелок, то снятие охраны брелком, а ЗП по метке
    // Иначе ЗП по штатным кнопкам
    if (   (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в запрет поездки
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Переход в запрет поездки не произведен\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД с включенным зажиганием в запрете поездки
void AutoTestsModesP2::C10854597_TestCase()
{
    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c10854596) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в запрете поездки, если происходит срабатывание ДД с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Метка
        ||Условие активации запрета поездки:                    | при снятии с охраны
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    // Если в системе есть метка + брелок, то снятие охраны брелком, а ЗП по метке
    // Иначе ЗП по штатным кнопкам
    if (   (p_gen6->getModules() & R868_MODULE) == R868_MODULE
        && (p_gen6->getModules() & BLE_MODULE)  == BLE_MODULE)
    {
        p_gen6->resetTagVcc();
        p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);
    }

    /*!
        Шаг 1. Выключить охрану брелоком
    */
    /*!
        Переход в запрет поездки
    */
    if (!p_gen6->setAndCheckSecure(OFF,
                                   KEYRING,
                                   DIAG_GUARD_STATE_IMMO))
    {
        printf("FAIL Шаг 1. Переход в запрет поездки не произведен\n");
        return;
    }

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 3\n");
    }
}

// Переключение АКПП из паркинга в тревоге
void AutoTestsModesP2::C10854607_TestCase()
{
    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в тревоге, если происходит выключение паркинга*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Условие активации запрета поездки:                    | при снятии с охраны
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Паркинг выключен
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД с отключенным зажиганием в тревоге
void AutoTestsModesP2::C10854608_TestCase()
{
    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 1 импульса в тревоге, если происходит срабатывание ДД без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Включена тревога
        На выход кнопки старт-стоп подан 1 импульс длительностью 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    p_gen6->checkAlarm(ON);
}

// Сработал ДД с включенным зажиганием в тревоге
void AutoTestsModesP2::C10854609_TestCase()
{
    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в тревоге, если происходит срабатывание ДД с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    p_gen6->checkAlarm(ON);

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД с отключенным зажиганием в предупредительной тревоге
void AutoTestsModesP2::C10854601_TestCase()
{
    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 1 импульса в предупредительной тревоге, если происходит срабатывание ДД без зажигания*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДУ предупредительного
    */
    /*!
        Датчик удара предупредительный сработал
        Включена Тревога по предупредительному датчику удара
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_SHOCK_LOW,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    // Без проверки тревоги, т.к. нужно включить ДД пока она не кончилась

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Включена тревога
        На выход кнопки старт-стоп подан 1 импульс длительностью 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Переход в тревогу с включенным зажиганием из предупредительной тревоге
void AutoTestsModesP2::C10854602_TestCase()
{
    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в предупредительной тревоге, если происходит переход в тревогу с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДУ предупредительного
    */
    /*!
        Датчик удара предупредительный сработал
        Включена Тревога по предупредительному датчику удара
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_SHOCK_LOW,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    // Без проверки тревоги, т.к. нужно включить ДД пока она не кончилась

    /*!
        Шаг 2. Включить зажигание
    */
    /*!
        Зажигание включено
        Включена тревога
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Переключение АКПП из паркинга с зажиганием включенным ранее чем АО
void AutoTestsModesP2::C10854603_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854603) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия импульсов в АО, если происходит выключение паркинга*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Снято
        ||Антиограбление:                                       | Отключено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Откл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    if (!setProgramNeutralAuto(GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС "31"
    */
    /*!
        ЦБ присылает ответное СМС с кодом подтверждения включения АО
    */

    /*!
        Шаг 3. Отправить с М1 на ЦБ СМС "31 хххх", где хххх - код подтверждения включения АО
    */
    /*!
        Переход из охраны в Антиограбление
    */
    if (!setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Шаг 2-3\n");
        return;
    }

    /*!
        Шаг 4. Выключить паркинг
    */
    /*!
        Паркинг выключен
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 4\n");
    }
}

// Переключение АКПП из паркинга с АО включенным ранее чем зажигание
void AutoTestsModesP2::C10854604_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854603) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в АО, если происходит выключение паркинга*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Антиограбление:                                       | Отключено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Откл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отправить с М1 на ЦБ СМС "31"
    */
    /*!
        ЦБ присылает ответное СМС с кодом подтверждения включения АО
    */

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС "31 хххх", где хххх - код подтверждения включения АО
    */
    /*!
        Переход из охраны в Антиограбление
    */
    if (!setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Выключить паркинг
    */
    /*!
        Паркинг выключен
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 4\n");
    }
}

// Сработал ДД с зажиганием включенным ранее чем АО
void AutoTestsModesP2::C10854605_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854603) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия импульсов в АО, если происходит срабатывание ДД с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Снято
        ||Антиограбление:                                       | Отключено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Откл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    if (!setProgramNeutralAuto(GUARD_STATE_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС "31"
    */
    /*!
        ЦБ присылает ответное СМС с кодом подтверждения включения АО
    */

    /*!
        Шаг 3. Отправить с М1 на ЦБ СМС "31 хххх", где хххх - код подтверждения включения АО
    */
    /*!
        Переход из охраны в Антиограбление
    */
    if (!setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Шаг 2-3\n");
        return;
    }

    /*!
        Шаг 4. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 4\n");
    }
}

// Сработал ДД с АО включенным ранее чем зажигание
void AutoTestsModesP2::C10854606_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854603) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка 3х импульсов в АО, если происходит срабатывание ДД с зажиганием*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Охрана
        ||Антиограбление:                                       | Отключено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Откл
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    p_gen6->outputSms(TIME_DELAY::STD_WAITING_SMS_TIME_S); // AT-6854

    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Отправить с М1 на ЦБ СМС "31"
    */
    /*!
        ЦБ присылает ответное СМС с кодом подтверждения включения АО
    */

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС "31 хххх", где хххх - код подтверждения включения АО
    */
    /*!
        Переход из охраны в Антиограбление
    */
    if (!setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп подан 1 импульс длительностью 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 5\n");
    }
}

// Переключение АКПП из паркинга в АО без скорости
void AutoTestsModesP2::C10854598_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульсов в АО, если происходит выключение паркинга*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Антиограбление
        ||Антиограбление:                                       | Включено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Скорость автомобиля:                                  | 0
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    setCanCarSpeed(0);

    if (   !setProgramNeutralAuto(GUARD_STATE_DISARM)
        || !setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Паркинг выключен
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД в АО с включенным зажиганием без скорости
void AutoTestsModesP2::C10854600_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульсов в АО, если происходит срабатывание ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Антиограбление
        ||Антиограбление:                                       | Включено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Скорость автомобиля:                                  | 0
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    setCanCarSpeed(0);

    if (   !setProgramNeutralAuto(GUARD_STATE_DISARM)
        || !setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп поданы 3 импульса длительностью по 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_THREE))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Переключение АКПП из паркинга в АО с скоростью
void AutoTestsModesP2::C10854610_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия импульсов в АО, если происходит выключение паркинга на скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Антиограбление
        ||Антиограбление:                                       | Включено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Скорость автомобиля:                                  | 60
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    p_gen6->outputSms(TIME_DELAY::STD_WAITING_SMS_TIME_S); // AT-6854
    setCanCarSpeed(60);

    if (   !setProgramNeutralAuto(GUARD_STATE_DISARM)
        || !setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Выключить паркинг
    */
    /*!
        Паркинг выключен
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_PARKING_OFF,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД в АО с включенным зажиганием с скоростью
void AutoTestsModesP2::C10854612_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отсутствия импульсов в АО, если происходит срабатывание ДД на скорости*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Антиограбление
        ||Антиограбление:                                       | Включено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Скорость автомобиля:                                  | 60
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    setCanCarSpeed(60);

    if (   !setProgramNeutralAuto(GUARD_STATE_DISARM)
        || !setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Включить зажигание
    */
    /*!
        Зажигание включено
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_IGN_ON,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        Импульсы на кнопке Старт-Стоп отсутствуют
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_NULL))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Сработал ДД в АО с отключенным зажиганием
void AutoTestsModesP2::C10854613_TestCase()
{
    if (   (p_gen6->getModules() & GSM_MODULE) != GSM_MODULE  // Модули для включения АО по команде
        && (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c10854607) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка импульса в АО, если происходит срабатывание ДД*
        ||Состояние стенда:
        ||Автомобиль в:                                         | Антиограбление
        ||Антиограбление:                                       | Включено
        ||Дверь:                                                | закрыта
        ||Багажник:                                             | закрыт
        ||Метка:                                                | выключена
        ||Брелок:                                               | включен
        ||Ручник:                                               | затянут
        ||Паркинг:                                              | включен
        ||Двигатель:                                            | заглушен
        ||Зажигание:                                            | выключено
        ||Обороты:                                              | выключены
        ||Настройки:
        ||Система запуска:                                      | Старт-Стоп
        ||КПП:                                                  | АКПП
        ||Настроен выход:                                       | Запуск двигателя: кнопка старт-стоп
        ||Блокировка двигателя импульсом на кнопку старт-стоп:  | включено
        ||Длительность импульса на кнопку старт-стоп:           | 1 сек
        ||Датчик движения:                                      | настроен
        ||Датчик удара: предупредительный:                      | настроен
        ||Настроен CAN-автомобиль:                              | 9999-Batmobile
        ||Сигналы состояния CAN: Скорость автомобиля:           | Вкл
        ||Скорость автомобиля:                                  | 0
        ||Авторизация владельца:                                | Отключена
        ||Снятие запрета поездки:                               | Отключен
        ||Задан телефон:                                        | М1
    */
    p_gen6->outputSms(TIME_DELAY::STD_WAITING_SMS_TIME_S); // AT-6854
    setCanCarSpeed(0);

    if (   !setProgramNeutralAuto(GUARD_STATE_DISARM)
        || !setAndCheckAhjSmsOrMobile())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        ДД сработал
        На выход кнопки старт-стоп подан 1 импульс длительностью 1с (Длительность импульса на кнопку старт-стоп)
    */
    if (!setBlockTriggerAndCheckStartStopBtnBlock(START_STOP_BLOCK_TRIGGER_SENSOR_MOVE,
                                                  START_BTN_CHECK_PULSES_ONE))
    {
        printf("FAIL Шаг 1\n");
    }
}

// НР блокировка во время ДЗ на Замке Зажигания
void AutoTestsModesP2::C10964449_TestCase()
{
    bool  acc_polarity;       // Полярность выхода аксессуары (не выкл. на время работы стартера)
    bool  ign1_polarity;      // Полярность выхода зажигание-1
    bool  starter_polarity;   // Полярность выхода стартер

    float ign1_wait_time_s;   // Время включения зажигания-1
    float immo_check_time_s;  // Время проверки задержки выкл. обходчика

    float ign1_err_time_s;    // Погрешность включения зажигания-1
    float starter_err_time_s; // Погрешность включения стартера
    float acc_off_err_time_s; // Погрешность выключения аксессуаров


    if (settings_check(p_c10964449) == 0)
    {
        return;
    }

    if (   m_acc_after_immo_delay_s         == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_ign_after_acc_delay_s          == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_starter_delay_s                == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_starter_max_work_time_s        == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_acc_off_after_ign_off_delay_s  == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_immo_off_after_acc_off_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки запуска двигателя были заданы\n");
        return;
    }

    acc_polarity       = p_gen6->getPolarity(ID_OUT_ACC_EXC);
    ign1_polarity      = p_gen6->getPolarity(ID_OUT_IGN1);
    starter_polarity   = p_gen6->getPolarity(ID_OUT_STARTER);

    ign1_wait_time_s   = m_acc_after_immo_delay_s + m_ign_after_acc_delay_s;
    immo_check_time_s  =   m_acc_off_after_ign_off_delay_s
                         + m_immo_off_after_acc_off_delay_s
                         + TIME_DELAY::MAX_WIRE_EN_DELAY_S;

    ign1_err_time_s    = TimeoutCalculator::calcToutError(ign1_wait_time_s);
    starter_err_time_s = TimeoutCalculator::calcToutError(m_starter_delay_s);
    acc_off_err_time_s = TimeoutCalculator::calcToutError(m_acc_off_after_ign_off_delay_s);

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка отключается во время включения зажигания и не раньше*
        ||Состояние стенда:
        ||Автомобиль в:                                        | охрана
        ||Ручник:                                              | затянут
        ||Паркинг:                                             | включен
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Брелок:                                              | включен
        ||Модуль запуска:                                      | подключен
        ||Дверь:                                               | закрыта
        ||Блокировка НР:                                       | отключена
        ||Выход блокировки НР:                                 | включен
        ||Настройки:
        ||Тип блокировки двигателя:                            | НР
        ||Снятие блокировки:                                   | при включении зажигания в снято с охраны
        ||Задержка блокировки:                                 | 0
        ||Настроен выход:                                      | блокировка двигателя
        ||Система запуска:                                     | замок зажигания
        ||КПП:                                                 | АКПП
        ||Управление обходом:                                  | Аналоговый сигнал
        ||Алгоритм работы модуля обхода:                       | Активен все время при АЗ/ДЗ и при ПН/ТТ
        ||Задержка включения обхода:                           | 1с
        ||Задержка включения аксессуаров:                      | 3с
        ||Задержка включения зажигания:                        | 3с
        ||Задержка включения стартера:                         | 3с
        ||Максимальное время работы стартера:                  | 5с
        ||Задержка выключения аксессуаров:                     | 3с
        ||Задержка выключения модуля обхода:                   | 6с
        ||Настроен выход:                                      | Запуск двигателя: аксессуары, не выкл. на время кручения стартером
        ||Настроен выход:                                      | Запуск двигателя: зажигание-1
        ||Настроен выход:                                      | Запуск двигателя: стартер
        ||Настроен выход:                                      | Управление потенциалом модуля обхода штатного иммобилайзера
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    if (waitBlock(ON))
    {
        printf("PASS Начальные условия. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Блокировка не включена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить ДЗ
    */
    /*!
        Начал выполняться ДЗ:
        Через 1с (Задержка включения обхода) включен обход
        Через 3с (Задержка включения аксессуаров) модулем запуска включены аксессуары
        Через 3с (Задержка включения зажигания) модулем запуска включено зажигание
        Блокировка отключилась (на выход блокировки подан потенциал)
        Через 3с (Задержка включения стартера) модулем запуска включен стартер
    */
    p_gen6->setRemoteRun(KEYRING);

    if (p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Включен обход\n");
    }
    else
    {
        printf("FAIL Шаг 1. Обход не включился\n");
        return;
    }

    if (!waitBlock(OFF, ign1_wait_time_s - ign1_err_time_s))
    {
        printf("PASS Шаг 1. Блокировка не отключилась раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка отключилась раньше времени\n");
        return;
    }

    if (p_gen6->waitIgn1(ign1_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S, ign1_polarity))
    {
        printf("PASS Шаг 1. Модулем запуска включено зажигание\n");
    }
    else
    {
        printf("FAIL Шаг 1. Зажигание не включилось модулем запуска\n");
        return;
    }

    if (waitBlock(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Шаг 1. Блокировка отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не отключилась\n");
        return;
    }

    if (   !p_gen6->waitStarter(m_starter_delay_s - starter_err_time_s,                   starter_polarity)
        &&  p_gen6->waitStarter(starter_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S, starter_polarity))
    {
        printf("PASS Шаг 1. Модулем запуска включен стартер\n");
    }
    else
    {
        printf("FAIL Шаг 1. Модулем запуска не включен стартер или включен вне времени ожидания\n");
        return;
    }

    /*!
        Шаг 2. Включить обороты
    */
    /*!
        Двигатель заведен
        Модулем запуска выключен стартер
    */
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S); // Не моментально включаем обороты после стартера
    p_gen6->setRpm(RPM_ON, PIN);

    if (p_gen6->waitStarter(m_starter_max_work_time_s, !starter_polarity))
    {
        printf("PASS Шаг 2. Модулем запуска выключен стартер\n");
    }
    else
    {
        printf("FAIL Шаг 2. Модулем запуска не выключен стартер\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Двигатель не заведен\n");
        return;
    }

    /*!
        Шаг 3. Подать команду глушения двигателя
    */
    /*!
        Модулем запуска отлючено зажигание
        Блокировка включилась (с выхода блокировки снят потенциал)
        Через 3с (Задержка выключения аксессуаров) модулем запуска отключены аксессуары
        Через 6с (Задержка выключения модуля обхода) отключен обход
    */
    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_RUN_ENGINE_TIME_S); // Не сразу глушим двигатель
    p_gen6->setRemoteStop(KEYRING);

    if (p_gen6->waitIgn1(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, !ign1_polarity))
    {
        printf("PASS Шаг 3. Модулем запуска отключено зажигание\n");
    }
    else
    {
        printf("FAIL Шаг 3. Модулем запуска не отключено зажигание\n");
        return;
    }

    if (waitBlock(ON, TIME_DELAY::MAX_STD_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 3. Блокировка включилась\n");
    }
    else
    {
        printf("FAIL Шаг 3. Блокировка не включилась\n");
        return;
    }

    if (   !p_gen6->waitAcc(m_acc_off_after_ign_off_delay_s - acc_off_err_time_s,     !acc_polarity)
        && !p_gen6->waitAcc(acc_off_err_time_s * TIME_DELAY::EPS_TO_ERR_MULTIPLIER_S, !acc_polarity))
    {
        printf("PASS Шаг 3. Модулем запуска отключены аксессуары\n");
    }
    else
    {
        printf("FAIL Шаг 3. Модулем запуска не отключены аксессуары или отключены вне времени ожидания\n");
        return;
    }

    if (!p_gen6->checkImmoDisDelayAfterAcc(m_immo_off_after_acc_off_delay_s,
                                           TimeoutCalculator::calcToutError(m_immo_off_after_acc_off_delay_s),
                                           immo_check_time_s))
    {
        printf("PASS Шаг 3. Отключен обход\n");
    }
    else
    {
        printf("FAIL Шаг 3. Обход не отключен\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 3. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Двигатель не заглушен\n");
    }
}

// НР блокировка во время ДЗ на Замке Зажигания
void AutoTestsModesP2::C10964450_TestCase()
{
    bool  start_stop_btn_polarity; // Полярность кнопки Старт-Стоп
    float block_check_time_s;      // Время проверки блокировки на Шаге 1 (проверяем пока не пройдут все импульсы Старт-Стоп)


    if (settings_check(p_c10964450) == 0)
    {
        return;
    }

    if (   m_start_stop_first_pulse_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND
        || m_start_stop_last_pulse_delay_s  == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Не все настройки запуска двигателя были заданы\n");
        return;
    }

    start_stop_btn_polarity = p_gen6->getPolarity(ID_OUT_START_STOP_BTN);
    block_check_time_s      =   m_start_stop_first_pulse_delay_s        + TIME_DELAY::START_STOP_BTN_DIS_TIME_S // 1-й импульс Старт-Стоп
                              + TIME_DELAY::START_STOP_BTN_PAUSE_TIME_S + TIME_DELAY::START_STOP_BTN_DIS_TIME_S // 2-й импульс Старт-Стоп
                              + m_start_stop_last_pulse_delay_s;                                                // 3-й импульс Старт-Стоп


    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка, что блокировка отключается во время включения зажигания и не раньше*
        ||Состояние стенда:
        ||Автомобиль в:                                                            | охрана
        ||Ручник:                                                                  | затянут
        ||Паркинг:                                                                 | включен
        ||Двигатель:                                                               | заглушен
        ||Зажигание:                                                               | выключено
        ||Обороты:                                                                 | выключены
        ||Брелок:                                                                  | включен
        ||Модуль запуска:                                                          | подключен
        ||Дверь:                                                                   | закрыта
        ||Блокировка НР:                                                           | отключена
        ||Выход блокировки НР:                                                     | включен
        ||Настройки:
        ||Тип блокировки двигателя:                                                | НР
        ||Снятие блокировки:                                                       | при включении зажигания в снято с охраны
        ||Задержка блокировки:                                                     | 0
        ||Настроен выход:                                                          | блокировка двигателя
        ||Система запуска:                                                         | Старт-Стоп
        ||КПП:                                                                     | АКПП
        ||Время работы автозапуска:                                                | 3 мин
        ||Задержка включения обхода:                                               | 1с
        ||Кол-во импульсов кнопки Старт-Стоп:                                      | Три импульса
        ||Задержка включения первого импульса кнопки Старт-Стоп:                   | 5с
        ||Задержка включения последнего импульса кнопки Старт-Стоп:                | 5с
        ||Длительность последнего импульса кнопки Старт-Стоп:                      | 5с
        ||Время ожидания запуска двигателя после нажатия кнопки с педалью тормоза: | 5с
    */
    if (!setProgramNeutralAuto())
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    if (waitBlock(ON))
    {
        printf("PASS Начальные условия. Блокировка включена\n");
    }
    else
    {
        printf("FAIL Начальные условия. Блокировка не включена\n");
        return;
    }

    /*!
        Шаг 1. Выполнить ДЗ
    */
    /*!
        Начал выполняться ДЗ:
        Через 1с (Задержка включения обхода) включен обход
        Через 5с (Задержка включения первого импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
        Через 1с (внутренний таймаут) модулем запуска выключена кнопка Старт-Стоп
        Через 1с (внутренний таймаут) модулем запуска включена кнопка Старт-Стоп
        Через 1с (внутренний таймаут) модулем запуска выключена кнопка Старт-Стоп
        Через 5с (Задержка включения последнего импульса кнопки Старт-Стоп) модулем запуска включена кнопка Старт-Стоп
    */
    p_gen6->setRemoteRun(KEYRING);

    if (p_gen6->waitInspector(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, p_gen6->getPolarity(ID_OUT_IMMO)))
    {
        printf("PASS Шаг 1. Включен обход\n");
    }
    else
    {
        printf("FAIL Шаг 1. Обход не включился\n");
        return;
    }

    if (!waitBlock(OFF, block_check_time_s))
    {
        printf("PASS Шаг 1. Блокировка не отключилась раньше времени\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка отключилась раньше времени\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, start_stop_btn_polarity))
    {
        printf("PASS Шаг 1. Модулем запуска включена кнопка Старт-Стоп (последнее нажатие)\n");
    }
    else
    {
        printf("FAIL Шаг 1. Модулем запуска не включена кнопка Старт-Стоп (последнее нажатие)\n");
        return;
    }

    /*!
        Шаг 2. Включить обороты и зажигание (завести двигатель)
    */
    /*!
        Двигатель заведен
        Блокировка отключилась (на выход блокировки подан потенциал)
        Модулем запуска отключена кнопка Старт-Стоп
    */
    wait(TIME_DELAY::STD_WIRE_EN_DELAY_S); // Не моментально заводим двигатель после 3-го нажатия Старт-Стоп
    p_gen6->setIgn(PIN, ON);
    p_gen6->setRpm(RPM_ON, PIN);

    if (waitBlock(OFF, TIME_DELAY::STD_WIRE_EN_DELAY_S))
    {
        printf("PASS Шаг 1. Блокировка отключилась\n");
    }
    else
    {
        printf("FAIL Шаг 1. Блокировка не отключилась\n");
        return;
    }

    if (p_gen6->waitStartStopBtn(TIME_DELAY::BYPASS_AFTER_KEYRING_TIME_S, !start_stop_btn_polarity))
    {
        printf("PASS Шаг 2. Модулем запуска отключена кнопка Старт-Стоп\n");
    }
    else
    {
        printf("FAIL Шаг 2. Модулем запуска не отключена кнопка Старт-Стоп\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 ON,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 2. Двигатель заведен\n");
    }
    else
    {
        printf("FAIL Шаг 2. Двигатель не заведен\n");
        return;
    }

    /*!
        Шаг 3. Подать команду глушения двигателя
    */
    /*!
        На кнопку Старт-Стоп поданы импульсы глушения (3 шт)
    */
    p_gen6->wait_s(TIME_DELAY::MIN_AFTER_RUN_ENGINE_TIME_S); // Не сразу глушим двигатель
    p_gen6->setRemoteStop(KEYRING);

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Двигатель заглушен
        Зажигание отключено
        Блокировка включилась (с выхода блокировки снят потенциал)
    */
    p_gen6->checkEngineStop(m_engine_start_system, STOP_AFTER_THIRD_IMPULSE_REMOVED);

    if (waitBlock(ON, TIME_DELAY::MAX_STD_BLOCK_WAIT_TIME_S))
    {
        printf("PASS Шаг 4. Блокировка включилась\n");
    }
    else
    {
        printf("FAIL Шаг 4. Блокировка не включилась\n");
        return;
    }

    if (p_gen6->waitSlpCmdStatus(DIAG_DATA_FLAG,
                                 SLP_STATUSES_SIZES::DIAG_DATA_FLAG_SIZE,
                                 DIAG_FLAG_BIT_ENG_RUNNING,
                                 OFF,
                                 TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 4. Двигатель заглушен\n");
    }
    else
    {
        printf("FAIL Шаг 4. Двигатель не заглушен\n");
    }
}

// Регистрация валидатора
void AutoTestsModesP2::C11110395_TestCase()
{
    // Сервисный светодиод на трансивере не проверяется
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c11110395) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка регистрации валидатора*
        ||Состояние стенда:
        ||Автомобиль (ЦБ) в:                         | Режим регистрации (регистрация устройств)
        ||Брелок:                                    | откл
        ||Метка:                                     | откл
        ||Подключена:                                | сервисная кнопка со светодиодом
        ||Настройки:
        ||Автомобиль CAN:                            | Batmobile
        ||Сигнал состояния CAN: Штатные кнопки:      | вкл
        ||Настроен выход:                            | сирена
    */
    if (!setInitState(INIT_ST_REG))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->wait_s(TIME_DELAY::REGISTER_MODE_ON_TIME_S);

    /*!
        Шаг 1. Ввести с помощью штатных кнопок (imitcan) желаемый код валидатора (количество нажатий кнопок от 2 до 15) (промежутки между нажатиями кнопок не более 3 сек. (внутренний таймаут))
    */
    /*!
        Каждое нажатие кнопок подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки
        Через 3 сек (внутренний таймаут) подтверждение ввода 2мя импульсами на светодиоде сервисной кнопки
    */
    if (!sendBtnAndCheckSignals(p_gen6->getValidatorCode().size(),
                                COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                SIREN_OFF))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Не позднее чем через 3 сек (внутренний таймаут) повторно ввести с помощью штатных кнопок (imitcan) код валидатора из шага 1
    */
    /*!
        Каждое нажатие кнопок подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки
        Через 3 сек (внутренний таймаут) подтверждение ввода 2мя импульсами на светодиоде сервисной кнопки и на сирене (импульсы сирены и светодиода одновременны)
        Зарегистрировано новое устройство
    */
    if (!sendBtnAndCheckSignals(p_gen6->getValidatorCode().size(),
                                COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                SIREN_ON))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Неудачная регистрация валидатора
void AutoTestsModesP2::C11110396_TestCase()
{
    // Сервисный светодиод на трансивере не проверяется
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c11110395) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачной регистрации валидатора*
        ||Состояние стенда:
        ||Автомобиль (ЦБ) в:                         | Режим регистрации (регистрация устройств)
        ||Брелок:                                    | откл
        ||Метка:                                     | откл
        ||Подключена:                                | сервисная кнопка со светодиодом
        ||Настройки:
        ||Автомобиль CAN:                            | Batmobile
        ||Сигнал состояния CAN: Штатные кнопки:      | вкл
        ||Настроен выход:                            | сирена
    */
    if (!setInitState(INIT_ST_REG))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->wait_s(TIME_DELAY::REGISTER_MODE_ON_TIME_S);

    /*!
        Шаг 1. Нажать 1 раз штатную кнопку (imitcan)
    */
    /*!
        Нажатие кнопки подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки
        Через 3 сек (внутренний таймаут) сообщение о ошибке 4мя импульсами на светодиоде сервисной кнопки
    */
    if (!sendBtnAndCheckSignals(1,
                                COUNT_STRUCT::BTN_VALIDATOR_REG_FAIL_LIGHTS_COUNT,
                                SIREN_OFF))
    {
        printf("FAIL Шаг 1\n");
    }
}

// Неудачное подтверждение регистрации валидатора
void AutoTestsModesP2::C11110397_TestCase()
{
    // Сервисный светодиод на трансивере не проверяется
    if (p_gen6->getDeviceName() == GEN6_X96V2)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c11110395) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неверного подтверждения регистрации валидатора*
        ||Состояние стенда:
        ||Автомобиль (ЦБ) в:                         | Режим регистрации (регистрация устройств)
        ||Брелок:                                    | откл
        ||Метка:                                     | откл
        ||Подключена:                                | сервисная кнопка со светодиодом
        ||Настройки:
        ||Автомобиль CAN:                            | Batmobile
        ||Сигнал состояния CAN: Штатные кнопки:      | вкл
        ||Настроен выход:                            | сирена
    */
    if (!setInitState(INIT_ST_REG))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->wait_s(TIME_DELAY::REGISTER_MODE_ON_TIME_S);

    /*!
        Шаг 1. Ввести с помощью штатных кнопок (imitcan) желаемый код валидатора (количество нажатий кнопок от 2 до 15) (промежутки между нажатиями кнопок не более 3 сек. (внутренний таймаут))
    */
    /*!
        Каждое нажатие кнопок подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки
        Через 3 сек (внутренний таймаут) подтверждение ввода 2мя импульсами на светодиоде сервисной кнопки
    */
    if (!sendBtnAndCheckSignals(p_gen6->getValidatorCode().size(),
                                COUNT_STRUCT::BTN_CMD_SUCCESS_LED_LIGHTS_COUNT,
                                SIREN_OFF))
    {
        printf("FAIL Шаг 1\n");
        return;
    }

    /*!
        Шаг 2. Не позднее чем через 3 сек (внутренний таймаут) нажать 1 раз штатную кнопку (imitcan)
    */
    /*!
        Нажатие кнопки подтверждается импульсом на светодиоде (вспышкой) сервисной кнопки
        Через 3 сек (внутренний таймаут) сообщение о ошибке 4мя импульсами на светодиоде сервисной кнопки
    */
    if (!sendBtnAndCheckSignals(1,
                                COUNT_STRUCT::BTN_VALIDATOR_REG_FAIL_LIGHTS_COUNT,
                                SIREN_OFF))
    {
        printf("FAIL Шаг 2\n");
    }
}

// Оповещение о тревоге из-за не пройденной авторизации после открытия аналогового багажника
void AutoTestsModesP2::C11446206_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка оповещения о тревоге звонком*
        ||Состояние стенда:
        ||Автомобиль (ЦБ) в:                                                | Охрана
        ||Брелок:                                                           | включен
        ||Метка:                                                            | отключена
        ||Багажник:                                                         | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                   | Batmobile (9999)
        ||Функция управления CAN: Снятие штатной системы охраны:            | Включена
        ||Функция управления CAN: Отпирание багажника:                      | Включена
        ||Авторизация владельца: Меткой:                                    | Включена
        ||Ожидание авторизации, шаг 1:                                      | 15 сек
        ||Ожидание авторизации, шаг 2:                                      | 0 сек
        ||Ожидание авторизации, шаг 3:                                      | 0 сек
        ||Управление штатной системой охраны (Slave при подключении к CAN): | включен
        ||Задан телефон:                                                    | М1
        ||Настройки оповещения: Тревога: М1-звонок                          | Включен
    */

    /*!
        Шаг 1. Подать команду на отпирание багажника брелоком (2 раза нажать кноку 2)
    */
    /*!
        Охрана с откр. багажником включена
    */

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 15 сек. (Ожидание авторизации, шаг 1) включена тревога
        На М1 поступил звонок от ЦБ с оповещением о тревоге
    */
}

// Оповещение о тревоге из-за не пройденной авторизации после открытия CAN багажника
void AutoTestsModesP2::C11446207_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка оповещения о тревоге звонком*
        ||Состояние стенда:
        ||Автомобиль (ЦБ) в:                                                | Охрана
        ||Брелок:                                                           | включен
        ||Метка:                                                            | отключена
        ||Багажник:                                                         | закрыт
        ||Настройки:
        ||Автомобиль CAN:                                                   | Batmobile (9999)
        ||Функция управления CAN: Снятие штатной системы охраны:            | Включена
        ||Функция управления CAN: Отпирание багажника:                      | Включена
        ||Авторизация владельца: Меткой:                                    | Включена
        ||Ожидание авторизации, шаг 1:                                      | 15 сек
        ||Ожидание авторизации, шаг 2:                                      | 0 сек
        ||Ожидание авторизации, шаг 3:                                      | 0 сек
        ||Управление штатной системой охраны (Slave при подключении к CAN): | включен
        ||Задан телефон:                                                    | М1
        ||Настройки оповещения: Тревога: М1-звонок                          | Включен
    */

    /*!
        Шаг 1. Подать команду на отпирание багажника с помощью imitCan (кнопка "отпереть багажник")
        или
        Отправить в ЦБ по CAN:
        ID=001 D0=00
        ID=001 D0=01        
    */
    /*!
        Охрана с откр. багажником включена
    */

    /*!
        Шаг 2. Открыть багажник с помощью imitCan (кнопка "багажник")
        или
        Отправить в ЦБ по CAN:
        ID=061 D0=01
    */
    /*!
        Багажник открыт
        Через 15 сек. (Ожидание авторизации, шаг 1) включена тревога
        На М1 поступил звонок от ЦБ с оповещением о тревоге
    */
}

// Выключение АО по СМС после пропажи метки
void AutoTestsModesP2::C11516269_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения АО на 1 цикл охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | открыта
        ||Метка:                                                   | отлючена
        ||Брелок:                                                  | включен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (включено)
        ||Антиограбление при пропадании:                           | брелока (отключено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Телефон М1:                                              | настроен
        ||www.starline-online.ru:                                  | подключен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС: "30 ХХХХ", где хххх – код экстренного выключения охраны
    */
    /*!
        СМС получена ЦБ
        Антиограбление по потере метки/брелока отключено
        Переход в снято
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        В течение 21 сек (АО, шаг 1 + АО, шаг 2 + АО, шаг 3 + АО, шаг 4) Антиограбление по потере метки/брелока не включено
        Звуковой извещатель не включен
        Сирена не включена
        Тревога не включена
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход из снято в охрану с нарушенным периметром
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Переход в снято
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 8. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
}

// Выключение АО через www.starline-online.ru после пропажи метки
void AutoTestsModesP2::C11516270_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения АО на 1 цикл охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | открыта
        ||Метка:                                                   | отлючена
        ||Брелок:                                                  | включен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (включено)
        ||Антиограбление при пропадании:                           | брелока (отключено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Телефон М1:                                              | настроен
        ||www.starline-online.ru:                                  | подключен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */

    /*!
        Шаг 2. С помощью www.starline-online.ru отключить АО (потребуется ввести код экстренного выключения охраны)
    */
    /*!
        СМС получена ЦБ
        Антиограбление по потере метки/брелока отключено
        Переход в снято
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        В течение 21 сек (АО, шаг 1 + АО, шаг 2 + АО, шаг 3 + АО, шаг 4) Антиограбление по потере метки/брелока не включено
        Звуковой извещатель не включен
        Сирена не включена
        Тревога не включена
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход из снято в охрану с нарушенным периметром
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Переход в снято
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 8. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
}

// Выключение АО по СМС после пропажи брелока
void AutoTestsModesP2::C11516271_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения АО на 1 цикл охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | открыта
        ||Метка:                                                   | влючена
        ||Брелок:                                                  | отключен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (отключено)
        ||Антиограбление при пропадании:                           | брелока (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Телефон М1:                                              | настроен
        ||www.starline-online.ru:                                  | подключен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */

    /*!
        Шаг 2. Отправить с М1 на ЦБ СМС: "30 ХХХХ", где хххх – код экстренного выключения охраны
    */
    /*!
        СМС получена ЦБ
        Антиограбление по потере метки/брелока отключено
        Переход в снято
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        В течение 21 сек (АО, шаг 1 + АО, шаг 2 + АО, шаг 3 + АО, шаг 4) Антиограбление по потере метки/брелока не включено
        Звуковой извещатель не включен
        Сирена не включена
        Тревога не включена
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход из снято в охрану с нарушенным периметром
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Переход в снято
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 8. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
}

// Выключение АО через www.starline-online.ru после пропажи брелока
void AutoTestsModesP2::C11516272_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка отключения АО на 1 цикл охраны*
        ||Состояние стенда:
        ||Автомобиль в:                                            | снято
        ||Зажигание:                                               | включено
        ||Дверь:                                                   | открыта
        ||Метка:                                                   | влючена
        ||Брелок:                                                  | отключен
        ||Паркинг:                                                 | отключен
        ||Настройки:
        ||Датчик движения:                                         | включен (30)
        ||Антиограбление при пропадании:                           | метки (отключено)
        ||Антиограбление при пропадании:                           | брелока (включено)
        ||АО, шаг 1: время до начала поиска метки или брелока:     | 10 сек
        ||АО, шаг 2: время поиска метки или брелока:               | 5 сек
        ||АО, шаг 3: предупреждение звуковым извещателем:          | 3 сек
        ||АО, шаг 4: предупреждение сиреной:                       | 3 сек
        ||Телефон М1:                                              | настроен
        ||www.starline-online.ru:                                  | подключен
    */

    /*!
        Шаг 1. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */

    /*!
        Шаг 2. С епомощью www.starline-online.ru отключить АО (потребуется ввести код экстренного выключения охраны)
    */
    /*!
        СМС получена ЦБ
        Антиограбление по потере метки/брелока отключено
        Переход в снято
    */

    /*!
        Шаг 3. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        В течение 21 сек (АО, шаг 1 + АО, шаг 2 + АО, шаг 3 + АО, шаг 4) Антиограбление по потере метки/брелока не включено
        Звуковой извещатель не включен
        Сирена не включена
        Тревога не включена
    */

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */

    /*!
        Шаг 5. Включить охрану
    */
    /*!
        Переход из снято в охрану с нарушенным периметром
    */

    /*!
        Шаг 6. Выключить охрану
    */
    /*!
        Переход в снято
    */

    /*!
        Шаг 7. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 8. Вызвать срабатывание ДД
    */
    /*!
        Зафиксировано движение
        Через 15 сек (АО, шаг 1: время до начала поиска метки или брелока + АО, шаг 2: время поиска метки или брелока) включен звуковой извещатель (если извещатель отсутствует, то сразу включается сирена)
        Через 3 сек (АО, шаг 3: предупреждение звуковым извещателем) выключен звуковой извещатель и включена сирена
        Через 3 сек (АО, шаг 4: предупреждение сиреной) выключена сирена и включена тревога
        Антиограбление по потере метки/брелока включено
    */
}

// Включение HIC по двери и зажиганию и выключение по двери
void AutoTestsModesP2::C11846848_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_open_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после открытия двери или багажника\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 4. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 4. Зажигание не включено\n");
        return;
    }

    /*!
        Шаг 5. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 5. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 6. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР не произошел
    */
    p_gen6->resetTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 6. Переход в охрану не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 6. Произошел переход в охрану\n");
        return;
    }

    /*!
        Шаг 7. Открыть дверь
    */
    /*!
        Дверь открыта
        Через 5 сек. (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром по СР
    */

    // Без проверки по SLP чтобы проверить тайминг включения охраны
    p_gen6->setDoor(OPEN, PIN);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               m_hf_arm_after_zone_open_delay_s,
                               TimeoutCalculator::calcToutError(m_hf_arm_after_zone_open_delay_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
    {
        printf("PASS Шаг 7. Переход в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход в охрану с нарушенным периметром не произошел\n");
        return;
    }

    /*!
        Шаг 8. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 8. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 8. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 9. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 9. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 9. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 10. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 10. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 10. Переход в охрану не произошел\n");
    }
}

// Включение HIC по багажнику и включению ручника и выключение по багажнику
void AutoTestsModesP2::C11846849_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    if (m_hf_arm_after_zone_open_delay_s == SLM_SETTINGS_STATE::FLOAT_SLM_SETTING_NOT_FOUND)
    {
        printf("FAIL Настройка \"Постановка после открытия двери или багажника\" не задана\n");
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 2. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 3. Закрыть багажник
    */
    /*!
        Багажник закрыт
    */
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 3. Багажник не закрыт\n");
        return;
    }

    /*!
        Шаг 4. Включить ручник
    */
    /*!
        Ручник включен
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 4. Ручник включен\n");
    }
    else
    {
        printf("FAIL Шаг 4. Ручник не включен\n");
        return;
    }

    /*!
        Шаг 5. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР не произошел
    */
    p_gen6->resetTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 5. Переход в охрану не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 5. Произошел переход в охрану\n");
        return;
    }

    /*!
        Шаг 6. Открыть багажник
    */
    /*!
        Багажник открыт
        Через 5 сек. (Постановка после открытия двери или багажника) переход в охрану с нарушенным периметром по СР
    */

    // Без проверки по SLP чтобы проверить тайминг включения охраны
    p_gen6->setTrunk(OPEN, PIN);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               m_hf_arm_after_zone_open_delay_s,
                               TimeoutCalculator::calcToutError(m_hf_arm_after_zone_open_delay_s) + TIME_DELAY::MIN_WAITING_REGION_STATE_S)) // Увеличенная погрешность из-за чтения по SLP
    {
        printf("PASS Шаг 6. Переход в охрану с нарушенным периметром\n");
    }
    else
    {
        printf("FAIL Шаг 6. Переход в охрану с нарушенным периметром не произошел\n");
        return;
    }

    /*!
        Шаг 7. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 7. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 8. Закрыть багажник
    */
    /*!
        Багажник закрыт
    */
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Шаг 8. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 8. Багажник не закрыт\n");
        return;
    }

    /*!
        Шаг 9. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 9. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 9. Переход в охрану не произошел\n");
    }
}

// Включение HIC по двери и выключению ручника и выключение по охране
void AutoTestsModesP2::C11846850_TestCase()
{
    float arm_wait_time_s; // Время ожидания включения охраны (зависит от устройства постановки)


    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if ((p_gen6->getModules() & R868_MODULE) == R868_MODULE)
    {
        arm_wait_time_s = TIME_DELAY::WAITING_REGION_STATE_S;
    }
    else if ((p_gen6->getModules() & GSM_MODULE) == GSM_MODULE)
    {
        arm_wait_time_s = TIME_DELAY::MAX_WAITING_SMS_STATUS_TIME_S;
    }
    else
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка включения и отключения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | включен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Начальные условия. Ручник включен\n");
    }
    else
    {
        printf("FAIL Начальные условия. Ручник не включен\n");
        return;
    }

    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Выключить ручник
    */
    /*!
        Ручник выключен
    */
    if (p_gen6->setAndCheckHandBreak(OFF, PIN))
    {
        printf("PASS Шаг 4. Ручник выключен\n");
    }
    else
    {
        printf("FAIL Шаг 4. Ручник не выключен\n");
        return;
    }

    /*!
        Шаг 5. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР не произошел
    */
    p_gen6->resetTagVcc();

    if (!p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                                ON,
                                TIME_DELAY::WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 5. Переход в охрану не произошел\n");
    }
    else
    {
        printf("FAIL Шаг 5. Произошел переход в охрану\n");
        return;
    }

    /*!
        Шаг 6. Включить охрану брелоком
    */
    /*!
        Охрана включена
    */
    setSecureNoTagNoDelay(ON);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               arm_wait_time_s))
    {
        printf("PASS Шаг 6. Охрана включена\n");
    }
    else
    {
        printf("FAIL Шаг 6. Охрана не включена\n");
        return;
    }

    /*!
        Шаг 7. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 7. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 8. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 8. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 8. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 9. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 9. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 9. Переход в охрану не произошел\n");
    }
}

// Включение HIC по багажнику и зажиганию без закрытия багажника
void AutoTestsModesP2::C11846851_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачного включения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 2. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 3. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 3. Зажигание не включено\n");
        return;
    }

    /*!
        Шаг 4. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 4. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 4. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 5. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 5. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 5. Переход в охрану не произошел\n");
    }
}

// Включение HIC по двери и включению ручника без закрытия двери
void AutoTestsModesP2::C11846852_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачного включения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 3. Включить ручник
    */
    /*!
        Ручник включен
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 3. Ручник включен\n");
    }
    else
    {
        printf("FAIL Шаг 3. Ручник не включен\n");
        return;
    }

    /*!
        Шаг 4. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 4. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 4. Переход в охрану не произошел\n");
    }
}

// Включение HIC по багажнику и зажиганию с открытым багажником
void AutoTestsModesP2::C11846853_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачного включения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть багажник
    */
    /*!
        Багажник открыт
    */    
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 2. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 2. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 3. Закрыть багажник
    */
    /*!
        Багажник закрыт
    */    
    if (p_gen6->setAndCheckTrunk(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Багажник закрыт\n");
    }
    else
    {
        printf("FAIL Шаг 3. Багажник не закрыт\n");
        return;
    }

    /*!
        Шаг 4. Открыть багажник
    */
    /*!
        Багажник открыт
    */
    if (p_gen6->setAndCheckTrunk(OPEN, PIN))
    {
        printf("PASS Шаг 4. Багажник открыт\n");
    }
    else
    {
        printf("FAIL Шаг 4. Багажник не открыт\n");
        return;
    }

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
    */    
    if (p_gen6->setAndCheckIgn(ON, PIN))
    {
        printf("PASS Шаг 5. Зажигание включено\n");
    }
    else
    {
        printf("FAIL Шаг 5. Зажигание не включено\n");
        return;
    }

    /*!
        Шаг 6. Выключить зажигание
    */
    /*!
        Зажигание отключено
    */    
    if (p_gen6->setAndCheckIgn(OFF, PIN))
    {
        printf("PASS Шаг 6. Зажигание выключено\n");
    }
    else
    {
        printf("FAIL Шаг 6. Зажигание не выключено\n");
        return;
    }

    /*!
        Шаг 7. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::WAITING_REGION_STATE_S))
    {
        printf("PASS Шаг 7. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 7. Переход в охрану не произошел\n");
    }
}

// Включение HIC по двери и включению ручника с открытой дверью
void AutoTestsModesP2::C11846854_TestCase()
{
    if ((p_gen6->getModules() & BLE_MODULE) != BLE_MODULE)
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    SettingsResetter<AutoTestsModesP2> resetter(this, &AutoTestsModesP2::resetAuthAndImmo);


    if (settings_check(p_c11846848) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка неудачного включения HIC*
        ||Состояние стенда:
        ||Автомобиль в:                                        | Охрана
        ||Дверь:                                               | закрыта
        ||Багажник:                                            | закрыт
        ||Метка:                                               | выключена
        ||Брелок:                                              | включен
        ||Ручник:                                              | выключен
        ||Паркинг:                                             | выключен
        ||Педаль тормоза:                                      | выключена
        ||Двигатель:                                           | заглушен
        ||Зажигание:                                           | выключено
        ||Обороты:                                             | выключены
        ||Настройки:
        ||Свободные руки:                                      | включены
        ||Способ снятия/постановки:                            | по появлении метки/ по пропаданию метки
        ||Постановка после открытия двери или багажника, сек:  | 5
        ||Постановка после закрытия двери или багажника, сек:  | 5
    */
    if (!setInitState(INIT_ST_ARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    p_gen6->resetTagVcc();
    p_gen6->wait_s(TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S);

    /*!
        Шаг 1. Включить метку
    */
    /*!
        Метка найдена
        Переход в снято по СР
    */
    p_gen6->setTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_DISARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_VISIBLE_TIME_S))
    {
        printf("PASS Шаг 1. Переход в снято\n");
    }
    else
    {
        printf("FAIL Шаг 1. Переход в снято не произошел\n");
        return;
    }

    /*!
        Шаг 2. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 2. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 2. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 3. Закрыть дверь
    */
    /*!
        Дверь закрыта
    */
    if (p_gen6->setAndCheckDoor(CLOSE, PIN))
    {
        printf("PASS Шаг 3. Дверь закрыта\n");
    }
    else
    {
        printf("FAIL Шаг 3. Дверь не закрыта\n");
        return;
    }

    /*!
        Шаг 4. Открыть дверь
    */
    /*!
        Дверь открыта
    */
    if (p_gen6->setAndCheckDoor(OPEN, PIN))
    {
        printf("PASS Шаг 4. Дверь открыта\n");
    }
    else
    {
        printf("FAIL Шаг 4. Дверь не открыта\n");
        return;
    }

    /*!
        Шаг 5. Включить ручник
    */
    /*!
        Ручник включен
    */
    if (p_gen6->setAndCheckHandBreak(ON, PIN))
    {
        printf("PASS Шаг 5. Ручник включен\n");
    }
    else
    {
        printf("FAIL Шаг 5. Ручник не включен\n");
        return;
    }

    /*!
        Шаг 6. Выключить метку
    */
    /*!
        Метка потеряна
        Переход в охрану по СР
    */
    p_gen6->resetTagVcc();

    if (p_gen6->waitGuardState(DIAG_GUARD_STATE_ARM,
                               ON,
                               TIME_DELAY::MIN_WAITING_REGION_STATE_S + TIME_DELAY::MAX_TAG_INVISIBLE_TIME_S))
    {
        printf("PASS Шаг 6. Переход в охрану\n");
    }
    else
    {
        printf("FAIL Шаг 6. Переход в охрану не произошел\n");
    }
}

// Индикация настройки по BLE при подключении смартфона
void AutoTestsModesP2::C11946743_TestCase()
{
    if (   (p_gen6->getModules() & BLE_MODULE) != BLE_MODULE
        ||  p_gen6->getDeviceName()            == GEN6_X96V2) // Светодиод на X96v2 не проверяется
    {
        printf(CASE_NOT_FOUND);
        return;
    }

    if (settings_check(p_c11946743) == 0)
    {
        return;
    }

    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка индикации настройки по BLE кнопкой*
        ||Состояние стенда:
        ||Зажигание:            | выключено
        ||Обороты:              | выключены
        ||Автомобиль в:         | Снято
        ||Настройки:
        ||Подключена:           | сервисная кнопка с светодиодом
        ||Задан телефон:        | М1
        ||Настроен выход:       | Статусный светодиод
        ||В ЦБ зарегистрирован: | Смартфон по BLE
    */
    if (!setInitState(INIT_ST_DISARM))
    {
        printf("FAIL Начальные условия\n");
        return;
    }

    /*!
        Шаг 1. Нажать 9 раз сервисную кнопку
    */
    /*!
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 2. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки отключился
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        ЦБ перешел в режим настройки по BLE
        Светодиод на кнопке и статусный светодиод начали моргать вспышками по 100 мс с паузами между ними 400 мс
    */
    if (!setAndCheckBleSettingsMode(ON, BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN_NO_IGN))
    {
        printf("FAIL Шаг 1-2\n");
        return;
    }

    if (!checkServiceLedInBleSettingsMode(MOBILE_DISCONNECTED))
    {
        printf("FAIL Шаг 2\n");
        return;
    }

    /*!
        Шаг 3. Включить BLE на смартфоне
    */
    /*!
        Смартфон подключился по BLE к ЦБ
        Светодиод на кнопке и статусный светодиод начали моргать сериями по две вспышки 100 мс (пауза между двумя вспышками в серии 100 мс) с паузами между сериями 400 мс
        (вспышка 100 мс, пауза 100 мс, вспышка 100 мс, пауза 400 мс - 1 цикл)
    */
    p_gen6->connectMobile();

    if (!checkServiceLedInBleSettingsMode(MOBILE_CONNECTED))
    {
        printf("FAIL Шаг 3\n");
        return;
    }

    /*!
        Шаг 4. Отключить BLE на смартфоне
    */
    /*!
        Смартфон отключился от ЦБ
        Светодиод на кнопке и статусный светодиод начали моргать вспышками по 100 мс с паузами между ними 400 мс
    */
    p_gen6->disconnectMobile();

    if (!checkServiceLedInBleSettingsMode(MOBILE_DISCONNECTED))
    {
        printf("FAIL Шаг 4\n");
        return;
    }

    /*!
        Шаг 5. Нажать 9 раз сервисную кнопку
    */
    /*!
        Сервисный светодиод перестал постоянно моргать
        Подтверждение нажатий кнопки светодиодом (на время нажатия светодиод включается)
        Через 3 сек (внутренний таймаут) включился светодиод сервисной кнопки
    */

    /*!
        Шаг 6. Нажать сервисную кнопку не позднее чем через 3 сек (внутренний таймаут) после включения светодиода (время горения светодиода)
    */
    /*!
        Светодиод сервисной кнопки и статусный светодиод отключились
        9-кратное подтверждение сервисным светодиодом входа в режим настройки по BLE
        2-кратное подтверждение сервисным светодиодом выполнения команды сервисной кнопки
        Режим настройки по BLE отключен
    */
    if (!setAndCheckBleSettingsMode(OFF, BLE_SETTINGS_MODE_EN_TYPE_SRV_BTN_NO_IGN))
    {
        printf("FAIL Шаг 5-6\n");
    }
}

// Переход в авторизацию с помощью Slave
void AutoTestsModesP2::C12037386_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка Keyless при Slave*
        ||Состояние стенда:
        ||Зажигание:                            | выключено
        ||Обороты:                              | выключены
        ||ЦБ в:                                 | Охрана
        ||Keyless:                              | Заблокирован
        ||Метка:                                | Отключена
        ||Брелок:                               | Отключен
        ||Настройки:
        ||Блокировка штатного Keyless-доступа:  | Включена
        ||Авторизация:                          | брелок
        ||Slave при подключении к CAN:          | Включен
        ||Настроен CAN-автомобиль:              | 9999 - Batmobile
    */

    /*!
        Шаг 1. Выключить охрану с помощью Slave по CAN
    */
    /*!
        Переход в авторизацию владельца
        Keyless не разблокирован:
        ЦБ не посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 2. Включить брелок
    */
    /*!
        Брелок обнаружен
        Переход в снято
        Keyless разблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x00
    */
}

// Переход в запрет поездки с помощью Slave
void AutoTestsModesP2::C12037387_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка Keyless при Slave*
        ||Состояние стенда:
        ||Зажигание:                            | выключено
        ||Обороты:                              | выключены
        ||ЦБ в:                                 | Охрана
        ||Keyless:                              | Заблокирован
        ||Метка:                                | Отключена
        ||Брелок:                               | Отключен
        ||Настройки:
        ||Блокировка штатного Keyless-доступа:  | Включена
        ||Снятие запрета поездки:               | штатные кнопки автомобиля
        ||Условие активации запрета поездки:    | при снятии с охраны
        ||Slave при подключении к CAN:          | Включен
        ||Настроен CAN-автомобиль:              | 9999 - Batmobile
    */

    /*!
        Шаг 1. Выключить охрану с помощью Slave по CAN
    */
    /*!
        Переход в запрета поездки
        Keyless не разблокирован:
        ЦБ не посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 2. Ввести код штатными кнопками
    */
    /*!
        Переход в снято
        Keyless разблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x00
    */
}

// Появление метки в авторизации
void AutoTestsModesP2::C12037388_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка Keyless при Slave*
        ||Состояние стенда:
        ||Зажигание:                            | выключено
        ||Обороты:                              | выключены
        ||ЦБ в:                                 | Охрана
        ||Keyless:                              | Заблокирован
        ||Метка:                                | Отключена
        ||Брелок:                               | Отключен
        ||Настройки:
        ||Блокировка штатного Keyless-доступа:  | Включена
        ||Авторизация:                          | брелок
        ||Slave при подключении к CAN:          | Включен
        ||Настроен CAN-автомобиль:              | 9999 - Batmobile
    */

    /*!
        Шаг 1. Выключить охрану с помощью Slave по CAN
    */
    /*!
        Переход в авторизацию владельца
        Keyless не разблокирован:
        ЦБ не посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Keyless разблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
        Через 5 сек (внутренний таймаут) Keyless зблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x20
    */
}

// Появление метки в запрете поездки
void AutoTestsModesP2::C12037389_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка Keyless при Slave*
        ||Состояние стенда:
        ||Зажигание:                            | выключено
        ||Обороты:                              | выключены
        ||ЦБ в:                                 | Охрана
        ||Keyless:                              | Заблокирован
        ||Метка:                                | Отключена
        ||Брелок:                               | Отключен
        ||Настройки:
        ||Блокировка штатного Keyless-доступа:  | Включена
        ||Снятие запрета поездки:               | штатные кнопки автомобиля
        ||Условие активации запрета поездки:    | при снятии с охраны
        ||Slave при подключении к CAN:          | Включен
        ||Настроен CAN-автомобиль:              | 9999 - Batmobile
    */

    /*!
        Шаг 1. Выключить охрану с помощью Slave по CAN
    */
    /*!
        Переход в запрета поездки
        Keyless не разблокирован:
        ЦБ не посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Keyless разблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x00
    */

    /*!
        Шаг 3. Выключить метку
    */
    /*!
        Метка потеряна
        Через 5 сек (внутренний таймаут) Keyless зблокирован:
        ЦБ посылает в CAN: ID = 0x105; D0 = 0x20
    */
}
// Переход в запрет поездки (по снятию с охраны) по выключению охраны и зажигания
void AutoTestsModesP2::C12037397_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки в опасной парковке*
        ||Состояние стенда:
        ||Зажигание:                             | отключено
        ||Обороты:                               | выключены
        ||Автомобиль в:                          | Снято
        ||Режим опасной парковки:                | включен
        ||Метка:                                 | отключена
        ||Настройки:
        ||Подключена:                            | сервисная кнопка с светодиодом
        ||Код штатных кнопок автомобиля:         | задан
        ||Снятие запрета поездки:                | Метка, Штатные кнопки автомобиля
        ||Условие активации запрета поездки:     | При снятии с охраны
        ||CAN-автомобиль:                        | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:  | Включен
    */

    /*!
        Шаг 1. Включить охрану
    */
    /*!
        Переход из Снято в Охрану
    */

    /*!
        Шаг 2. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 3. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// Переход в запрет поездки (по выключению зажигания) по выключению охраны и зажигания
void AutoTestsModesP2::C12037398_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки в опасной парковке*
        ||Состояние стенда:
        ||Зажигание:                             | включено
        ||Обороты:                               | выключены
        ||Автомобиль в:                          | Снято
        ||Режим опасной парковки:                | включен
        ||Метка:                                 | отключена
        ||Настройки:
        ||Подключена:                            | сервисная кнопка с светодиодом
        ||Код штатных кнопок автомобиля:         | задан
        ||Снятие запрета поездки:                | Метка, Штатные кнопки автомобиля
        ||Условие активации запрета поездки:     | При каждом выключении зажигания
        ||CAN-автомобиль:                        | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:  | Включен
    */

    /*!
        Шаг 1. Отключить зажигание
    */
    /*!
        Запрет поездки активен
    */

    /*!
        Шаг 2. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Включить охрану
    */
    /*!
        Переход в Охрану
    */

    /*!
        Шаг 4. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 5. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 6. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 7. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки
    */
}

// Переход в отключенный запрет поездки (по снятию с охраны) по выключению охраны и зажигания
void AutoTestsModesP2::C12037401_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки в опасной парковке*
        ||Состояние стенда:
        ||Зажигание:                             | отключено
        ||Обороты:                               | выключены
        ||Автомобиль в:                          | Снято
        ||Режим опасной парковки:                | включен
        ||Метка:                                 | отключена
        ||Настройки:
        ||Подключена:                            | сервисная кнопка с светодиодом
        ||Код штатных кнопок автомобиля:         | задан
        ||Снятие запрета поездки:                | Отключено
        ||Условие активации запрета поездки:     | При снятии с охраны (настроено до отключения запрета поездки)
        ||CAN-автомобиль:                        | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:  | Включен
    */

    /*!
        Шаг 1. Включить охрану
    */
    /*!
        Переход из Снято в Охрану
    */

    /*!
        Шаг 2. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 3. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// Переход в запрет поездки (по выключению зажигания) по выключению охраны и зажигания
void AutoTestsModesP2::C12037402_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки в опасной парковке*
        ||Состояние стенда:
        ||Зажигание:                             | включено
        ||Обороты:                               | выключены
        ||Автомобиль в:                          | Снято
        ||Режим опасной парковки:                | включен
        ||Метка:                                 | отключена
        ||Настройки:
        ||Подключена:                            | сервисная кнопка с светодиодом
        ||Код штатных кнопок автомобиля:         | задан
        ||Снятие запрета поездки:                | Отключено
        ||Условие активации запрета поездки:     | При каждом выключении зажигания (настроено до отключения запрета поездки)
        ||CAN-автомобиль:                        | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:  | Включен
    */

    /*!
        Шаг 1. Отключить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 2. Включить охрану
    */
    /*!
        Переход в Охрану
    */

    /*!
        Шаг 3. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 4. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 5. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 6. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// При снятии с охраны (М)
void AutoTestsModesP2::C12116944_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Отключено
        ||Условие активации запрета поездки:                  | При снятии с охраны
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Отключить метку
    */
    /*!
        Метка потеряна
        Переход из Снято в Запрет поездки не произошел
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// При снятии с охраны и При каждом выключении зажигания (М)
void AutoTestsModesP2::C12116945_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Отключено
        ||Условие активации запрета поездки:                  | При каждом выключении зажигания
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Запрета поездки в Снято не произошел
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 4. Отключить метку
    */
    /*!
        Метка потеряна
        Переход из Снято в Запрет поездки не произошел
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход из Снято в Запрет поездки
    */
}

// При снятии с охраны (Ш)
void AutoTestsModesP2::C12116946_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Отключено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При снятии с охраны
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 4. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// При снятии с охраны и При каждом выключении зажигания (Ш)
void AutoTestsModesP2::C12116947_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Отключено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При каждом выключении зажигания
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 4. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход из Снято в Запрет поездки
    */
}

// При снятии с охраны (М+Ш) (выключение меткой)
void AutoTestsModesP2::C12116948_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При снятии с охраны
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Отключить метку
    */
    /*!
        Метка потеряна
        Переход из Снято в Запрет поездки не произошел
    */

    /*!
        Шаг 4. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// При снятии с охраны и При каждом выключении зажигания (М+Ш) (выключение меткой)
void AutoTestsModesP2::C12116949_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При каждом выключении зажигания
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Включить метку
    */
    /*!
        Метка обнаружена
        Переход из Запрета поездки в Снято не произошел
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 4. Отключить метку
    */
    /*!
        Метка потеряна
        Переход из Снято в Запрет поездки не произошел
    */

    /*!
        Шаг 5. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход из Снято в Запрет поездки
    */
}

// При снятии с охраны (М+Ш) (выключение кнопками)
void AutoTestsModesP2::C12116950_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При снятии с охраны
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 4. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход в Запрет поездки не произошел
    */
}

// При снятии с охраны и При каждом выключении зажигания (М+Ш) (выключение кнопками)
void AutoTestsModesP2::C12116951_TestCase()
{
    /*!
        Начальные условия
    */
    /*!
        **Описание:** *проверка запрета поездки с различными настройками*
        ||Состояние стенда:
        ||Зажигание:                                          | отключено
        ||Обороты:                                            | выключены
        ||Автомобиль в:                                       | Охрана
        ||Метка:                                              | отключена
        ||Настройки:
        ||Код штатных кнопок автомобиля:                      | задан
        ||Снятие запрета поездки: Метка:                      | Включено
        ||Снятие запрета поездки: Штатные кнопки автомобиля:  | Включено
        ||Условие активации запрета поездки:                  | При каждом выключении зажигания
        ||CAN-автомобиль:                                     | 9999 - Batmobile
        ||CAN-сигнал состояния: Штатные кнопки:               | Включен
    */

    /*!
        Шаг 1. Отключить охрану
    */
    /*!
        Переход из Охраны в Запрет поездки
    */

    /*!
        Шаг 2. Ввести код штатными кнопками автомобиля
    */
    /*!
        Переход из Запрета поездки в Снято
    */

    /*!
        Шаг 3. Включить зажигание
    */
    /*!
        Зажигание включено
    */

    /*!
        Шаг 4. Отключить зажигание
    */
    /*!
        Зажигание отключено
        Переход из Снято в Запрет поездки
    */
}
